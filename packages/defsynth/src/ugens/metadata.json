{
  "_meta": {
    "generated": "2025-12-28T10:35:21.520Z",
    "scSourcePath": "/home/sam/Development/supercollider",
    "ugenCount": 360
  },
  "ugens": {
    "A2K": {
      "name": "A2K",
      "summary": "Audio to control rate converter.",
      "categories": "UGens>Conversion",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        }
      ],
      "description": "Audio to control rate converter. Only needed in specific cases.",
      "related": [
        "K2A"
      ],
      "parent": "PureUGen",
      "signalRange": null
    },
    "APF": {
      "name": "APF",
      "summary": "FIXME: APF purpose.",
      "categories": "UGens>Filters>Linear, UGens>Undocumented",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "FIXME: explain parameter in."
        },
        {
          "name": "freq",
          "default": 440,
          "doc": "FIXME: explain parameter freq."
        },
        {
          "name": "radius",
          "default": 0.8,
          "doc": "FIXME: explain parameter radius."
        }
      ],
      "description": "FIXME: APF description.",
      "related": [],
      "parent": "TwoPole",
      "signalRange": null,
      "inheritedFrom": "TwoPole"
    },
    "AccelerometerX": {
      "name": "AccelerometerX",
      "summary": null,
      "categories": null,
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "minval",
          "default": 0,
          "doc": null
        },
        {
          "name": "maxval",
          "default": 1,
          "doc": null
        },
        {
          "name": "warp",
          "default": 0,
          "doc": null
        },
        {
          "name": "lag",
          "default": 0.2,
          "doc": null
        }
      ],
      "description": null,
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "AccelerometerY": {
      "name": "AccelerometerY",
      "summary": null,
      "categories": null,
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "minval",
          "default": 0,
          "doc": null
        },
        {
          "name": "maxval",
          "default": 1,
          "doc": null
        },
        {
          "name": "warp",
          "default": 0,
          "doc": null
        },
        {
          "name": "lag",
          "default": 0.2,
          "doc": null
        }
      ],
      "description": null,
      "related": [],
      "parent": "AccelerometerX",
      "signalRange": null,
      "inheritedFrom": "AccelerometerX"
    },
    "AccelerometerZ": {
      "name": "AccelerometerZ",
      "summary": null,
      "categories": null,
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "minval",
          "default": 0,
          "doc": null
        },
        {
          "name": "maxval",
          "default": 1,
          "doc": null
        },
        {
          "name": "warp",
          "default": 0,
          "doc": null
        },
        {
          "name": "lag",
          "default": 0.2,
          "doc": null
        }
      ],
      "description": null,
      "related": [],
      "parent": "AccelerometerX",
      "signalRange": null,
      "inheritedFrom": "AccelerometerX"
    },
    "AllpassC": {
      "name": "AllpassC",
      "summary": "Schroeder allpass delay line with cubic interpolation.",
      "categories": "UGens>Delays",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "maxdelaytime",
          "default": 0.2,
          "doc": "The maximum delay time in seconds. Used to initialize the delay buffer size."
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Delay time in seconds."
        },
        {
          "name": "decaytime",
          "default": 1,
          "doc": "Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower."
        }
      ],
      "description": "A Schroeder allpass filter is given by the difference equations\n\ns(t) = x(t) + k * s(t - D)\ny(t) = -k * s(t) + s(t - D)\n\nwhere x(t) is the input signal, y(t) is the output signal,\nD is the delay time, and k is the allpass coefficient.\n\nIn this UGen, k is computed as\nk == 0.001 ** (delay / decay.abs) * decay.sign (0.001 is -60 dBFS).\n\nSee also\nAllpassN  which uses no interpolation, and\nAllpassL  which uses linear interpolation.\nCubic interpolation is more computationally expensive than linear,\nbut more accurate.",
      "related": [
        "AllpassL",
        "AllpassN",
        "BufAllpassC"
      ],
      "parent": "CombN",
      "signalRange": null,
      "inheritedFrom": "CombN"
    },
    "AllpassL": {
      "name": "AllpassL",
      "summary": "Schroeder allpass delay line with linear interpolation.",
      "categories": "UGens>Delays",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "maxdelaytime",
          "default": 0.2,
          "doc": "The maximum delay time in seconds. Used to initialize the delay buffer size."
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Delay time in seconds."
        },
        {
          "name": "decaytime",
          "default": 1,
          "doc": "Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower."
        }
      ],
      "description": "A Schroeder allpass filter is given by the difference equations\n\ns(t) = x(t) + k * s(t - D)\ny(t) = -k * s(t) + s(t - D)\n\nwhere x(t) is the input signal, y(t) is the output signal,\nD is the delay time, and k is the allpass coefficient.\n\nIn this UGen, k is computed as\nk == 0.001 ** (delay / decay.abs) * decay.sign (0.001 is -60 dBFS).\n\nSee also\nAllpassN  which uses no interpolation, and\nAllpassC  which uses cubic interpolation.\nCubic interpolation is more computationally expensive than linear,\nbut more accurate.",
      "related": [
        "AllpassC",
        "AllpassN",
        "BufAllpassL"
      ],
      "parent": "CombN",
      "signalRange": null,
      "inheritedFrom": "CombN"
    },
    "AllpassN": {
      "name": "AllpassN",
      "summary": "Schroeder allpass delay line with no interpolation.",
      "categories": "UGens>Delays",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "maxdelaytime",
          "default": 0.2,
          "doc": "The maximum delay time in seconds. Used to initialize the delay buffer size."
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Delay time in seconds."
        },
        {
          "name": "decaytime",
          "default": 1,
          "doc": "Time for the echoes to decay by 60 decibels. If this time is negative, then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower."
        }
      ],
      "description": "A Schroeder allpass filter is given by the difference equations\n\ns(t) = x(t) + k * s(t - D)\ny(t) = -k * s(t) + s(t - D)\n\nwhere x(t) is the input signal, y(t) is the output signal,\nD is the delay time, and k is the allpass coefficient.\n\nIn this UGen, k is computed as\nk == 0.001 ** (delay / decay.abs) * decay.sign (0.001 is -60 dBFS).\n\nThis UGen quantizes the delay time to the nearest sample period, and will\nproduce aliasing artifacts if the delay time is modulated. If these\nare undesirable properties, the more CPU-expensive alternatives are\nAllpassL which uses linear interpolation, and\nAllpassC which uses cubic interpolation.",
      "related": [
        "AllpassC",
        "AllpassL",
        "BufAllpassN"
      ],
      "parent": "CombN",
      "signalRange": null,
      "inheritedFrom": "CombN"
    },
    "AmpComp": {
      "name": "AmpComp",
      "summary": "Basic psychoacoustic amplitude compensation.",
      "categories": "UGens>Analysis>Amplitude",
      "rates": [
        "ar",
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "freq",
          "default": null,
          "doc": "Input frequency value. For freq == root, the output is 1.0."
        },
        {
          "name": "root",
          "default": "60.midicps",
          "doc": "Root freq relative to which the curve is calculated\n(usually lowest freq)."
        },
        {
          "name": "exp",
          "default": 0.3333,
          "doc": "Exponent: how steep the curve decreases for increasing freq."
        }
      ],
      "description": "Implements the (optimized) formula:\n\ncompensationFactor = (root / freq) ** exp\n\nHigher frequencies are normally perceived as louder, which AmpComp\ncompensates.",
      "related": [
        "AmpCompA"
      ],
      "parent": "PureUGen",
      "signalRange": null
    },
    "AmpCompA": {
      "name": "AmpCompA",
      "summary": "Basic psychoacoustic amplitude compensation (ANSI A-weighting curve).",
      "categories": "UGens>Analysis>Amplitude",
      "rates": [
        "ar",
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "freq",
          "default": 1000,
          "doc": "Input frequency value. For freq == root, the output is rootAmp."
        },
        {
          "name": "root",
          "default": 0,
          "doc": "Root freq relative to which the curve is calculated (usually lowest freq). Non-modulatable."
        },
        {
          "name": "minAmp",
          "default": 0.32,
          "doc": "Amplitude at the minimum point of the curve (around 2512 Hz). Non-modulatable."
        },
        {
          "name": "rootAmp",
          "default": 1,
          "doc": "Amplitude at the root frequency. Non-modulatable.\n\nExamples::\n\n// compare a sine without compensation\n\n{ SinOsc.ar(MouseX.kr(300, 15000, 1)) * 0.1 }.play;\n\n// with one that uses amplitude compensation\n(\n{\n\tvar freq;\n\tfreq = MouseX.kr(300, 15000, 1);\n\tSinOsc.ar(freq) * 0.3 * AmpCompA.kr(freq)\n}.play;\n)\n\n// adjust the minimum and root amp\n// (in this way one can flatten out the curve for higher amplitudes)\n\n(\n{\n\tvar freq;\n\tfreq = MouseX.kr(300, 18000, 1);\n\tFormant.ar(300, freq, 20, 0.1) * AmpCompA.kr(freq, 300, 0.6, 0.3)\n}.play;\n)\n\n// the curve:\n\n{ AmpCompA.ar(Line.ar(48, 120, 1).midicps, 48.midicps) }.plot(1.0);\n\n// freqs:\n\n{ AmpCompA.ar(Line.ar(0, 20000, 1)) }.plot(1.0);\n\n// compare with AmpComp (exponential decay)\n\n{ AmpComp.ar(Line.ar(48, 120, 1).midicps, 48.midicps) }.plot(1.0);\n\n// freqs:\n\n{ AmpComp.ar(Line.ar(40, 20000, 1), 40) }.plot(1.0);\n\n// amplitude compensation in frequency modulation (using Fletscher-Munson curve)\n(\n{\n\tvar freq;\n\tfreq = MouseX.kr(300, 15000, 1);\n\tfreq = freq * SinOsc.ar(MouseY.kr(3, 200, 1), 0, 0.5, 1);\n\tSinOsc.ar(freq) * 0.1 * AmpCompA.ar(freq, 300)\n}.play;\n)\n\n// amplitude compensation in frequency modulation (using AmpComp exponential decay)\n(\n{\n\tvar freq;\n\tfreq = MouseX.kr(300, 15000, 1);\n\tfreq = freq * SinOsc.ar(MouseY.kr(3, 200, 1), 0, 0.5, 1);\n\tSinOsc.ar(freq) * 0.1 * AmpComp.ar(freq, 300)\n}.play;\n)\n\n// without amplitude compensation\n(\n{\n\tvar freq;\n\tfreq = MouseX.kr(300, 15000, 1);\n\tfreq = freq * SinOsc.ar(MouseY.kr(3, 200, 1), 0, 0.5, 1);\n\tSinOsc.ar(freq) * 0.1\n}.play;\n)"
        }
      ],
      "description": "Higher frequencies are normally perceived as louder, which AmpCompA\ncompensates. Following the measurements by Fletcher and Munson, the\nANSI standard describes a function for loudness vs. frequency.\n\nNote that this curve is only valid for standardized amplitude.\nfoot(Note:  Function freq → dB, derived from http://www.beis.de/Elektronik/AudioMeasure/WeightingFilters.html and modified to map freq → amp.\n\n(\nvar k =  3.5041384e16;\nvar c1 = 424.31867740601;\nvar c2 = 11589.093052022;\nvar c3 = 544440.67046057;\nvar c4 = 148698928.24309;\nf = { |f|\nvar r = squared(f);\nvar m1 = pow(r, 4);\nvar n1 = squared(c1 + r);\nvar n2 = c2 + r;\nvar n3 = c3 + r;\nvar n4 = squared(c4 + r);\nvar level = k * m1 / (n1 * n2 * n3 * n4);\nsqrt(level)\n};\n)\n\n)\n\nFor a simpler but more flexible curve, see  AmpComp",
      "related": [
        "AmpComp"
      ],
      "parent": "AmpComp",
      "signalRange": null
    },
    "Amplitude": {
      "name": "Amplitude",
      "summary": "Amplitude follower",
      "categories": "UGens>Analysis>Amplitude",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "Input signal"
        },
        {
          "name": "attackTime",
          "default": 0.01,
          "doc": "20dB convergence time for following attacks."
        },
        {
          "name": "releaseTime",
          "default": 0.01,
          "doc": "20dB convergence time for following decays."
        }
      ],
      "description": "Tracks the relative amplitude of a signal, using an envelope follower algorithm. An envelope follower converges toward rising amplitude according to attackTime, and toward falling amplitude according to releaseTime. See the plot under Examples.",
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "AnalogIn": {
      "name": "AnalogIn",
      "summary": "Read data from an analog input",
      "categories": "UGens>Bela",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "analogPin",
          "default": 0,
          "doc": "Analog pin number to read. Pin numbers begin at 0."
        }
      ],
      "description": "Read a DC-coupled analog input connected to a sensor (e.g.: a potentiometer or CV in).\n\n(Note: \nThis UGen only works on Bela\n)",
      "related": [
        "AnalogOut",
        "DigitalIn",
        "DigitalOut",
        "DigitalIO"
      ],
      "parent": "UGen",
      "signalRange": "unipolar"
    },
    "AnalogOut": {
      "name": "AnalogOut",
      "summary": "Write data to an analog output",
      "categories": "UGens>Bela",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "analogPin",
          "default": 0,
          "doc": "Analog pin number to read. Pin numbers begin at 0."
        },
        {
          "name": "output",
          "default": 0,
          "doc": "Value to write out to the pin."
        }
      ],
      "description": "Writes an output to a DC-coupled analog output (e.g.: CV out).\n\n(Note: \nThis UGen only works on Bela\n)",
      "related": [
        "AnalogIn",
        "DigitalIn",
        "DigitalOut",
        "DigitalIO"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "AudioControl": {
      "name": "AudioControl",
      "summary": null,
      "categories": null,
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "values",
          "default": null,
          "doc": null
        }
      ],
      "description": null,
      "related": [],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "BAllPass": {
      "name": "BAllPass",
      "summary": "All Pass Filter",
      "categories": "UGens>Filters>BEQSuite",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": null
        },
        {
          "name": "freq",
          "default": 1200,
          "doc": null
        },
        {
          "name": "rq",
          "default": 1,
          "doc": null
        }
      ],
      "description": "The B equalization suite is based on the Second Order Section (SOS) biquad UGen.\n\n(Note: \nBiquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.\n)",
      "related": [
        "SOS",
        "BLowPass",
        "BLowPass4",
        "BHiPass",
        "BHiPass4",
        "BPeakEQ",
        "BLowShelf",
        "BHiShelf",
        "BBandPass",
        "BBandStop"
      ],
      "parent": "BEQSuite",
      "signalRange": null
    },
    "BBandPass": {
      "name": "BBandPass",
      "summary": "Band Pass Filter",
      "categories": "UGens>Filters>BEQSuite",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": null
        },
        {
          "name": "freq",
          "default": 1200,
          "doc": null
        },
        {
          "name": "bw",
          "default": 1,
          "doc": null
        }
      ],
      "description": "The B equalization suite is based on the Second Order Section (SOS) biquad UGen.\n\n(Note: \nBiquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.\n)",
      "related": [
        "SOS",
        "BLowPass",
        "BLowPass4",
        "BHiPass",
        "BHiPass4",
        "BPeakEQ",
        "BLowShelf",
        "BHiShelf",
        "BBandStop",
        "BAllPass"
      ],
      "parent": "BEQSuite",
      "signalRange": null
    },
    "BBandStop": {
      "name": "BBandStop",
      "summary": "Band reject filter",
      "categories": "UGens>Filters>BEQSuite",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": null
        },
        {
          "name": "freq",
          "default": 1200,
          "doc": null
        },
        {
          "name": "bw",
          "default": 1,
          "doc": null
        }
      ],
      "description": "The B equalization suite is based on the Second Order Section (SOS) biquad UGen.\n\n(Note: \nBiquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.\n)",
      "related": [
        "SOS",
        "BLowPass",
        "BLowPass4",
        "BHiPass",
        "BHiPass4",
        "BPeakEQ",
        "BLowShelf",
        "BHiShelf",
        "BBandPass",
        "BAllPass"
      ],
      "parent": "BEQSuite",
      "signalRange": null
    },
    "BEQSuite": {
      "name": "BEQSuite",
      "summary": "Base class for B Equalization Suite",
      "categories": "UGens>Filters>BEQSuite",
      "rates": [],
      "args": [],
      "description": null,
      "related": [],
      "parent": "Filter",
      "signalRange": null
    },
    "BHiPass": {
      "name": "BHiPass",
      "summary": "12db/oct rolloff - 2nd order resonant  Hi Pass Filter",
      "categories": "UGens>Filters>BEQSuite",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": null
        },
        {
          "name": "freq",
          "default": 1200,
          "doc": null
        },
        {
          "name": "rq",
          "default": 1,
          "doc": null
        }
      ],
      "description": "The B equalization suite is based on the Second Order Section (SOS) biquad UGen.\n\n(Note: \nBiquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.\n)",
      "related": [
        "SOS",
        "BLowPass",
        "BLowPass4",
        "BHiPass4",
        "BPeakEQ",
        "BLowShelf",
        "BHiShelf",
        "BBandPass",
        "BBandStop",
        "BAllPass"
      ],
      "parent": "BEQSuite",
      "signalRange": null
    },
    "BHiShelf": {
      "name": "BHiShelf",
      "summary": "Hi Shelf",
      "categories": "UGens>Filters>BEQSuite",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": null
        },
        {
          "name": "freq",
          "default": 1200,
          "doc": null
        },
        {
          "name": "rs",
          "default": 1,
          "doc": null
        },
        {
          "name": "db",
          "default": 0,
          "doc": null
        }
      ],
      "description": "The B equalization suite is based on the Second Order Section (SOS) biquad UGen.\n\n(Note: \nBiquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.\n)",
      "related": [
        "SOS",
        "BLowPass",
        "BLowPass4",
        "BHiPass",
        "BHiPass4",
        "BPeakEQ",
        "BLowShelf",
        "BBandPass",
        "BBandStop",
        "BAllPass"
      ],
      "parent": "BEQSuite",
      "signalRange": null
    },
    "BLowPass": {
      "name": "BLowPass",
      "summary": "12db/oct rolloff - 2nd order resonant Low Pass Filter",
      "categories": "UGens>Filters>BEQSuite",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": null
        },
        {
          "name": "freq",
          "default": 1200,
          "doc": null
        },
        {
          "name": "rq",
          "default": 1,
          "doc": null
        }
      ],
      "description": "The B equalization suite is based on the Second Order Section (SOS) biquad UGen.\n\n(Note: \nBiquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.\n)",
      "related": [
        "SOS",
        "BLowPass4",
        "BHiPass",
        "BHiPass4",
        "BPeakEQ",
        "BLowShelf",
        "BHiShelf",
        "BBandPass",
        "BBandStop",
        "BAllPass"
      ],
      "parent": "BEQSuite",
      "signalRange": null
    },
    "BLowShelf": {
      "name": "BLowShelf",
      "summary": "Low Shelf",
      "categories": "UGens>Filters>BEQSuite",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": null
        },
        {
          "name": "freq",
          "default": 1200,
          "doc": null
        },
        {
          "name": "rs",
          "default": 1,
          "doc": null
        },
        {
          "name": "db",
          "default": 0,
          "doc": null
        }
      ],
      "description": "The B equalization suite is based on the Second Order Section (SOS) biquad UGen.\n\n(Note: \nBiquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.\n)",
      "related": [
        "SOS",
        "BLowPass",
        "BLowPass4",
        "BHiPass",
        "BHiPass4",
        "BPeakEQ",
        "BHiShelf",
        "BBandPass",
        "BBandStop",
        "BAllPass"
      ],
      "parent": "BEQSuite",
      "signalRange": null
    },
    "BPF": {
      "name": "BPF",
      "summary": "2nd order Butterworth bandpass filter.",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "freq",
          "default": 440,
          "doc": "Centre frequency in Hertz.\nWARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!"
        },
        {
          "name": "rq",
          "default": 1,
          "doc": "The reciprocal of Q. Q is conventionally defined as freq / bandwidth, meaning rq = (bandwidth / freq)."
        }
      ],
      "description": "A second order band pass filter.",
      "related": [
        "BRF",
        "HPF",
        "LPF"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "BPZ2": {
      "name": "BPZ2",
      "summary": "Two zero fixed midpass.",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal.\n\nExamples::\n\n// Compare:\n\n{ WhiteNoise.ar(0.25) }.play;\n\n{ BPZ2.ar(WhiteNoise.ar(0.25)) }.play;"
        }
      ],
      "description": "A special case fixed filter. Implements the formula:\n\nout(i) = 0.5 * (in(i) - in(i - 2)).\n\nThis filter cuts out 0 Hz and the Nyquist frequency.",
      "related": [
        "BRZ2",
        "HPZ2",
        "LPZ2"
      ],
      "parent": "LPZ2",
      "signalRange": null,
      "inheritedFrom": "LPZ2"
    },
    "BPeakEQ": {
      "name": "BPeakEQ",
      "summary": "Parametric equalizer",
      "categories": "UGens>Filters>BEQSuite",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": null
        },
        {
          "name": "freq",
          "default": 1200,
          "doc": null
        },
        {
          "name": "rq",
          "default": 1,
          "doc": null
        },
        {
          "name": "db",
          "default": 0,
          "doc": null
        }
      ],
      "description": "The B equalization suite is based on the Second Order Section (SOS) biquad UGen.\n\n(Note: \nBiquad coefficient calculations imply certain amount of CPU overhead. These plugin UGens contain optimizations such that the coefficients get updated only when there has been a change to one of the filter's parameters. This can cause spikes in CPU performance and should be considered when using several of these units.\n)",
      "related": [
        "SOS",
        "BLowPass",
        "BLowPass4",
        "BHiPass",
        "BHiPass4",
        "BPeakEQ",
        "BLowShelf",
        "BHiShelf",
        "BBandPass",
        "BBandStop",
        "BAllPass"
      ],
      "parent": "BEQSuite",
      "signalRange": null
    },
    "BRF": {
      "name": "BRF",
      "summary": "2nd order Butterworth band reject filter.",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "freq",
          "default": 440,
          "doc": "Cutoff frequency in Hertz.\nWARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!"
        },
        {
          "name": "rq",
          "default": 1,
          "doc": "The reciprocal of Q (bandwidth / cutoffFreq).\n\nExamples::\n\n{ BRF.ar(Saw.ar(200, 0.1), FSinOsc.kr(XLine.kr(0.7, 300, 20), 0, 3800, 4000), 0.3) }.play;\n\n{ BRF.ar(Saw.ar(200, 0.5), MouseX.kr(100, 10000, 1), 0.3) }.play;\n\n\t// BRF on control signals:\n(\n{ \tvar vib = BRF.kr(SinOsc.kr([1, 3, 10], 0, [1, 0.5, 0.25]).sum, MouseX.kr(1, 10, 1), 0.3);\n\tSinOsc.ar(vib * 200 + 600) * 0.2 }.play;\n)"
        }
      ],
      "description": "A second order band reject filter.",
      "related": [
        "BPF",
        "HPF",
        "LPF"
      ],
      "parent": "BPF",
      "signalRange": null,
      "inheritedFrom": "BPF"
    },
    "BRZ2": {
      "name": "BRZ2",
      "summary": "Two zero fixed midcut.",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal.\n\nExamples::\n\n// Compare:\n\n{ WhiteNoise.ar(0.25) }.play;\n\n{ BRZ2.ar(WhiteNoise.ar(0.25)) }.play;"
        }
      ],
      "description": "A special case fixed filter. Implements the formula:\n\nout(i) = 0.5 * (in(i) + in(i - 2)).\n\nThis filter cuts out frequencies around ½ of the Nyquist frequency.",
      "related": [
        "BPZ2",
        "HPZ2",
        "LPZ2"
      ],
      "parent": "LPZ2",
      "signalRange": null,
      "inheritedFrom": "LPZ2"
    },
    "Balance2": {
      "name": "Balance2",
      "summary": "Stereo signal balancer",
      "categories": "UGens>Multichannel>Panners",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "left",
          "default": null,
          "doc": "channel 1 of input stereo signal"
        },
        {
          "name": "right",
          "default": null,
          "doc": "channel 2 of input stereo signal"
        },
        {
          "name": "pos",
          "default": 0,
          "doc": "pan position, -1 is left, +1 is right"
        },
        {
          "name": "level",
          "default": 1,
          "doc": "a control rate level input.\n\nExamples::\n\n// a stereo signal, both channels at 0dB\n{ [SinOsc.ar(440), SinOsc.ar(440)] }.play\n\n// using Balance on a stereo signal with the position parameter at 0, effectively the same sound but both channels at -3dB\n{ Balance2.ar(SinOsc.ar(440), SinOsc.ar(440), 0) }.play\n\n// pan sweep from left to right\n{ Balance2.ar(SinOsc.ar(440), SinOsc.ar(1000), Line.kr(-1, 1, 5)) }.play\n\n// other examples\n{ Balance2.ar(LFSaw.ar(44), Pulse.ar(33), FSinOsc.kr(0.5), 0.1) }.play;\n{ var source; source = SinOsc.ar([440, 550]); Balance2.ar(source[0], source[1], LFNoise0.kr(4), 0.3) }.play;"
        }
      ],
      "description": "Equal power panning balances two channels. By panning from left (pos = -1) to right (pos = 1) you are decrementing the level of the left channel from 1 to 0 taking the square root of the linear scaling factor, while at the same time incrementing the level of the right channel from 0 to 1 using the same curve. In the center position (pos = 0) this results in a level for both channels of 0.5.sqrt (~=0.707 or -3dB). The output of Balance2 remains a stereo signal.",
      "related": [
        "LinPan2",
        "Pan2",
        "Pan4",
        "PanAz"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "Ball": {
      "name": "Ball",
      "summary": "physical model of bouncing object",
      "categories": "UGens>Filters>Nonlinear, UGens>Generators>PhysicalModels",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "modulated surface level"
        },
        {
          "name": "g",
          "default": 1,
          "doc": "gravity"
        },
        {
          "name": "damp",
          "default": 0,
          "doc": "damping on impact"
        },
        {
          "name": "friction",
          "default": 0.01,
          "doc": "proximity from which on attraction to surface starts"
        }
      ],
      "description": "Ball models the path of a bouncing object that is reflected by a vibrating surface.",
      "related": [
        "TBall",
        "Spring"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "BeatTrack": {
      "name": "BeatTrack",
      "summary": "Autocorrelation beat tracker",
      "categories": "UGens>Analysis, UGens>FFT",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "chain",
          "default": null,
          "doc": null
        },
        {
          "name": "lock",
          "default": 0,
          "doc": null
        }
      ],
      "description": "Autocorrelation based beat tracker; foot(Note: \nResearch note: This UGen is a derivation following:\nDavies, M. E. P.  and Plumbley, M. D. Beat Tracking With A Two State Model. Proceedings of the IEEE International Conference on Acoustics, Speech and Signal Processing (ICASSP 2005), Philadelphia, USA, March 19-23, 2005\n\nThe UGen was converted by Nick Collins for beat tracking research in the course of his PhD and uses an original C implementation of Matthew Davies' MATLAB model. It first appeared as part of BBCut2 as AutoTrack but has now been added to core to enhance SuperCollider's realtime machine listening options.\n) the underlying model assumes 4/4, but it should work on any isochronous beat structure, though there are biases to 100-120 bpm; a fast 7/8 may not be tracked in that sense.\nThere are four k-rate outputs, being ticks at quarter, eighth and sixteenth level from the determined beat, and the current detected tempo. Note that the sixteenth note output won't necessarily make much sense if the music being tracked has swing; it is provided just as a convenience.\n\nThis beat tracker determines the beat, biased to the midtempo range by weighting functions. It does not determine the measure level, only a tactus.\nIt is also slow reacting, using a 6 second temporal window for its autocorrelation maneouvres. Don't expect human musician level predictive tracking.\n\nOn the other hand, it is tireless, relatively general (though obviously best at transient 4/4 heavy material without much expressive tempo variation), and can form the basis of computer processing that is decidedly faster than human.",
      "related": [
        "BeatTrack2"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "BeatTrack2": {
      "name": "BeatTrack2",
      "summary": "Template matching beat tracker",
      "categories": "UGens>Analysis, UGens>FFT",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "busindex",
          "default": null,
          "doc": null
        },
        {
          "name": "numfeatures",
          "default": null,
          "doc": null
        },
        {
          "name": "windowsize",
          "default": 2,
          "doc": null
        },
        {
          "name": "phaseaccuracy",
          "default": 0.02,
          "doc": null
        },
        {
          "name": "lock",
          "default": 0,
          "doc": null
        },
        {
          "name": "weightingscheme",
          "default": null,
          "doc": null
        }
      ],
      "description": "This beat tracker foot(Note: \nResearch note: Designed by Nick Collins following work by Jean Laroche\n) is based on exhaustively testing particular template patterns against feature streams; the testing takes place every 0.5 seconds. The two basic templates are a straight (groove = 0) and a swung triplet (groove = 1) pattern of 16th notes; this pattern is tried out at scalings corresponding to the tempi from 60 to 180 bpm.\nThis is the cross-correlation method of beat tracking. A majority vote is taken on the best tempo detected, but this must be confirmed by a consistency check after a phase estimate. Such a consistency check helps to avoid wild fluctuating estimates, but is at the expense of an additional half second delay.\nThe latency of the beat tracker with default settings is thus at least 2.5 seconds; because of block-based amortisation of calculation, it is actually around 2.8 seconds latency for a 2.0 second temporal window.\n\nThis beat tracker is designed to be flexible for user needs; you can try out different window sizes, tempo weights and combinations of features. However, there are no guarantees on stability and effectiveness, and you will need to explore such parameters for a particular situation.",
      "related": [
        "BeatTrack"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "BelaScopeOut": {
      "name": "BelaScopeOut",
      "summary": "Bela's Oscilloscope interface",
      "categories": "UGens>Bela",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "offset",
          "default": 0,
          "doc": "The Bela Oscilloscope's channel where to start writing. This is read only at construction time and thus it's not modulatable."
        },
        {
          "name": "channelsArray",
          "default": null,
          "doc": "An array of UGens to be scoped."
        }
      ],
      "description": "(Note: \nThis UGen only works on Bela\n)\nThis UGen effectively sends audio signals to Bela Oscilloscope, analogously to how /Classes/Out writes to a bus.\nIt can be used directly, or through Classes/UGen#-belaScope, Classes/Array#-belaScope, Classes/Bus#-belaScope, Classes/Function#-belaScope and Classes/Server#-belaScope convenience functions.",
      "related": [],
      "parent": "AbstractOut",
      "signalRange": null
    },
    "BiPanB2": {
      "name": "BiPanB2",
      "summary": "2D Ambisonic B-format panner.",
      "categories": "UGens>Multichannel>Ambisonics",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "inA",
          "default": null,
          "doc": "Input signal A"
        },
        {
          "name": "inB",
          "default": null,
          "doc": "Input signal B."
        },
        {
          "name": "azimuth",
          "default": null,
          "doc": "Position around the circle from -1 to +1.\n\n-1 is behind, -0.5 is left, 0 is forward, +0.5 is right, +1 is behind."
        },
        {
          "name": "gain",
          "default": 1,
          "doc": "Amplitude control.\n\nExamples::\n\n(\n{\n\tvar w, x, y, p, q, a, b, c, d;\n\n\tp = LFSaw.ar(200);\n\tq = LFSaw.ar(301);\n\n\t// B-format encode\n\t#w, x, y = BiPanB2.ar(p, q, MouseX.kr(-1, 1), 0.1);\n\n\t// B-format decode to quad\n\t#a, b, c, d = DecodeB2.ar(4, w, x, y);\n\n\t[a, b, d, c] // reorder to my speaker arrangement: Lf Rf Lr Rr\n}.play;\n)"
        }
      ],
      "description": "Encode a two channel signal to two dimensional ambisonic B-format. This\nputs two channels at opposite poles of a 2D ambisonic field. This is one\nway to map a stereo sound onto a soundfield. It is equivalent to:\n\nPanB2(inA, azimuth, gain) + PanB2(inB, azimuth + 1, gain)",
      "related": [
        "DecodeB2",
        "PanB",
        "PanB2",
        "Rotate2"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "Blip": {
      "name": "Blip",
      "summary": "Band limited impulse oscillator.",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 440,
          "doc": "Frequency in Hertz."
        },
        {
          "name": "numharm",
          "default": 200,
          "doc": "Number of harmonics. This may be lowered internally if it would cause aliasing."
        }
      ],
      "description": "Band Limited ImPulse generator. All harmonics have equal amplitude.\nThis is the equivalent of 'buzz' in  MusicN languages.\n\nSynth-O-Matic (1990) had an impulse generator\ncalled blip, hence that name here rather than 'buzz'.\n\nIt is improved from other implementations in that it will crossfade\nin a control period when the number of  harmonics changes,\nso that there are no audible pops. It also eliminates the divide in\nthe formula by using a 1/sin table (with special precautions taken for\n1/0).  The lookup tables are linearly interpolated for better quality.\n\n(Warning: \nThis waveform in its raw form could be damaging to your ears at high\namplitudes or for long periods.\n)",
      "related": [
        "Impulse"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "BlockSize": {
      "name": "BlockSize",
      "summary": null,
      "categories": null,
      "rates": [
        "ir"
      ],
      "args": [],
      "description": null,
      "related": [],
      "parent": "InfoUGenBase",
      "signalRange": null
    },
    "BrownNoise": {
      "name": "BrownNoise",
      "summary": "Brown Noise.",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [],
      "description": "Generates noise whose spectrum falls off in power by 6 dB per octave.",
      "related": [
        "ClipNoise",
        "GrayNoise",
        "PinkNoise",
        "WhiteNoise"
      ],
      "parent": "WhiteNoise",
      "signalRange": null
    },
    "BufAllpassC": {
      "name": "BufAllpassC",
      "summary": "Buffer based all pass delay line with cubic interpolation.",
      "categories": "UGens>Delays>Buffer",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "buf",
          "default": 0,
          "doc": "Buffer number."
        },
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Delay time in seconds."
        },
        {
          "name": "decaytime",
          "default": 1,
          "doc": "Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower."
        }
      ],
      "description": "All pass delay line with cubic interpolation which uses a buffer for its\ninternal memory. See also  BufAllpassN  which uses no\ninterpolation, and  which  BufAllpassL  uses linear\ninterpolation. Cubic interpolation is more computationally expensive\nthan linear, but more accurate.",
      "related": [
        "BufAllpassL",
        "BufAllpassN",
        "AllpassC"
      ],
      "parent": "BufCombN",
      "signalRange": null,
      "inheritedFrom": "BufCombN"
    },
    "BufAllpassL": {
      "name": "BufAllpassL",
      "summary": "Buffer based all pass delay line with linear interpolation.",
      "categories": "UGens>Delays>Buffer",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "buf",
          "default": 0,
          "doc": "Buffer number."
        },
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Delay time in seconds."
        },
        {
          "name": "decaytime",
          "default": 1,
          "doc": "Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower."
        }
      ],
      "description": "All pass delay line with linear interpolation which uses a buffer for its\ninternal memory. See also  BufAllpassN  which uses no\ninterpolation, and  which  BufAllpassC  uses cubic\ninterpolation. Cubic interpolation is more computationally expensive\nthan linear, but more accurate.",
      "related": [
        "BufAllpassC",
        "BufAllpassN",
        "AllpassL"
      ],
      "parent": "BufCombN",
      "signalRange": null,
      "inheritedFrom": "BufCombN"
    },
    "BufAllpassN": {
      "name": "BufAllpassN",
      "summary": "Buffer based all pass delay line with no interpolation.",
      "categories": "UGens>Delays>Buffer",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "buf",
          "default": 0,
          "doc": "Buffer number."
        },
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Delay time in seconds."
        },
        {
          "name": "decaytime",
          "default": 1,
          "doc": "Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower."
        }
      ],
      "description": "All pass delay line with no interpolation which uses a buffer for its\ninternal memory. See also  BufAllpassC  which uses cubic\ninterpolation, and  which  BufAllpassL  uses linear\ninterpolation. Cubic interpolation is more computationally expensive\nthan linear, but more accurate.",
      "related": [
        "BufAllpassC",
        "BufAllpassL",
        "AllpassN"
      ],
      "parent": "BufCombN",
      "signalRange": null,
      "inheritedFrom": "BufCombN"
    },
    "BufChannels": {
      "name": "BufChannels",
      "summary": "Current number of channels of soundfile in buffer.",
      "categories": "UGens>Buffer>Info",
      "rates": [
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": "Buffer index."
        }
      ],
      "description": "Get the current number of channels of soundfile.",
      "related": [
        "BufDur",
        "BufFrames",
        "BufRateScale",
        "BufSampleRate",
        "BufSamples"
      ],
      "parent": "BufInfoUGenBase",
      "signalRange": null,
      "inheritedFrom": "BufInfoUGenBase"
    },
    "BufCombC": {
      "name": "BufCombC",
      "summary": "Buffer based comb delay line with cubic interpolation.",
      "categories": "UGens>Delays>Buffer",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "buf",
          "default": 0,
          "doc": "Buffer number."
        },
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Delay time in seconds."
        },
        {
          "name": "decaytime",
          "default": 1,
          "doc": "Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower."
        }
      ],
      "description": "Comb delay line with cubic interpolation which uses a buffer for its\ninternal memory. See also  BufCombN  which uses no\ninterpolation, and  BufCombL  which uses linear\ninterpolation. Cubic interpolation is more computationally expensive\nthan linear, but more accurate.",
      "related": [
        "BufCombL",
        "BufCombN",
        "CombC"
      ],
      "parent": "BufCombN",
      "signalRange": null,
      "inheritedFrom": "BufCombN"
    },
    "BufCombL": {
      "name": "BufCombL",
      "summary": "Buffer based comb delay line with linear interpolation.",
      "categories": "UGens>Delays>Buffer",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "buf",
          "default": 0,
          "doc": "Buffer number."
        },
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Delay time in seconds."
        },
        {
          "name": "decaytime",
          "default": 1,
          "doc": "Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower."
        }
      ],
      "description": "Comb delay line with linear interpolation which uses a buffer for its\ninternal memory. See also  BufCombN  which uses no\ninterpolation, and  BufCombC  which uses cubic\ninterpolation. Cubic interpolation is more computationally expensive\nthan linear, but more accurate.",
      "related": [
        "BufCombC",
        "BufCombN",
        "CombL"
      ],
      "parent": "BufCombN",
      "signalRange": null,
      "inheritedFrom": "BufCombN"
    },
    "BufCombN": {
      "name": "BufCombN",
      "summary": "Buffer based comb delay line with no interpolation.",
      "categories": "UGens>Delays>Buffer",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "buf",
          "default": 0,
          "doc": "Buffer number."
        },
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Delay time in seconds."
        },
        {
          "name": "decaytime",
          "default": 1,
          "doc": "Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower."
        }
      ],
      "description": "Comb delay line with no interpolation which uses a buffer for its\ninternal memory. See also  BufCombL  which uses linear\ninterpolation, and  BufCombC  which uses cubic\ninterpolation. Cubic interpolation is more computationally\nexpensive than linear, but more accurate.",
      "related": [
        "BufCombC",
        "BufCombL",
        "CombN"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "BufDelayC": {
      "name": "BufDelayC",
      "summary": "Buffer based simple delay line with cubic interpolation.",
      "categories": "UGens>Delays>Buffer",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "buf",
          "default": 0,
          "doc": "Buffer number.\n\n(Note:  The buffers provided to any of the BufDelay units must be one channel. If you want to delay a multichannel signal, you must provide as many separate (one-channel) buffers as there are input channels.)"
        },
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Delay time in seconds."
        }
      ],
      "description": "Simple delay line with cubic interpolation which uses a buffer for its\ninternal memory. See also  BufDelayN  which uses no\ninterpolation, and  BufDelayL  which uses linear\ninterpolation. Cubic interpolation is more computationally expensive\nthan linear, but more accurate.",
      "related": [
        "BufDelayL",
        "BufDelayN",
        "DelayC"
      ],
      "parent": "BufDelayN",
      "signalRange": null,
      "inheritedFrom": "BufDelayN"
    },
    "BufDelayL": {
      "name": "BufDelayL",
      "summary": "Buffer based simple delay line with linear interpolation.",
      "categories": "UGens>Delays>Buffer",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "buf",
          "default": 0,
          "doc": "Buffer number.\n\n(Note:  The buffers provided to any of the BufDelay units must be one channel. If you want to delay a multichannel signal, you must provide as many separate (one-channel) buffers as there are input channels.)"
        },
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Delay time in seconds."
        }
      ],
      "description": "Simple delay line with linear interpolation which uses a buffer for its\ninternal memory. See also  BufDelayN  which uses no\ninterpolation, and  BufDelayC  which uses cubic\ninterpolation. Cubic interpolation is more computationally expensive\nthan linear, but more accurate.",
      "related": [
        "BufDelayC",
        "BufDelayN",
        "DelayL"
      ],
      "parent": "BufDelayN",
      "signalRange": null,
      "inheritedFrom": "BufDelayN"
    },
    "BufDelayN": {
      "name": "BufDelayN",
      "summary": "Buffer based simple delay line with no interpolation.",
      "categories": "UGens>Delays>Buffer",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "buf",
          "default": 0,
          "doc": "Buffer number.\n\n(Note:  The buffers provided to any of the BufDelay units must be one channel. If you want to delay a multichannel signal, you must provide as many separate (one-channel) buffers as there are input channels.)"
        },
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Delay time in seconds."
        }
      ],
      "description": "Simple delay line with no interpolation which uses a buffer for its\ninternal memory. See also  BufDelayL  which uses linear\ninterpolation, and  BufDelayC  which uses cubic\ninterpolation. Cubic interpolation is more computationally expensive\nthan linear, but more accurate.",
      "related": [
        "BufDelayC",
        "BufDelayL",
        "DelayN"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "BufDur": {
      "name": "BufDur",
      "summary": "Current duration of soundfile in buffer.",
      "categories": "UGens>Buffer>Info",
      "rates": [
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": "Buffer index."
        }
      ],
      "description": "Get the current duration of soundfile.",
      "related": [
        "BufChannels",
        "BufFrames",
        "BufRateScale",
        "BufSampleRate",
        "BufSamples"
      ],
      "parent": "BufInfoUGenBase",
      "signalRange": null,
      "inheritedFrom": "BufInfoUGenBase"
    },
    "BufFrames": {
      "name": "BufFrames",
      "summary": "Current number of frames allocated in the buffer.",
      "categories": "UGens>Buffer>Info",
      "rates": [
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": "Buffer index."
        }
      ],
      "description": "Get the current number of allocated frames.",
      "related": [
        "BufChannels",
        "BufDur",
        "BufRateScale",
        "BufSampleRate",
        "BufSamples"
      ],
      "parent": "BufInfoUGenBase",
      "signalRange": null,
      "inheritedFrom": "BufInfoUGenBase"
    },
    "BufInfoUGenBase": {
      "name": "BufInfoUGenBase",
      "summary": "Base class for buffer info ugens",
      "categories": "UGens>Base",
      "rates": [
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": null
        }
      ],
      "description": null,
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "BufRateScale": {
      "name": "BufRateScale",
      "summary": "Buffer rate scaling in respect to server samplerate.",
      "categories": "UGens>Buffer>Info",
      "rates": [
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": "Buffer index.\n\nReturns:: a ratio by which the playback of a soundfile is to be scaled."
        }
      ],
      "description": "Returns a ratio by which the playback of a soundfile is to be scaled.",
      "related": [
        "BufChannels",
        "BufDur",
        "BufFrames",
        "BufSampleRate",
        "BufSamples"
      ],
      "parent": "BufInfoUGenBase",
      "signalRange": null,
      "inheritedFrom": "BufInfoUGenBase"
    },
    "BufRd": {
      "name": "BufRd",
      "summary": "Buffer reading oscillator.",
      "categories": "UGens>Buffer",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "numChannels",
          "default": null,
          "doc": "Number of channels that the buffer will be. This must be a fixed\ninteger. The architecture of the SynthDef cannot change after it\nis compiled.\n(Note: \nIf you supply a bufnum of a buffer that has a\ndifferent numChannels than you have specified to\nthe BufRd, it will post a warning and output the channels it can.)"
        },
        {
          "name": "bufnum",
          "default": 0,
          "doc": "The index of the buffer to use."
        },
        {
          "name": "phase",
          "default": 0,
          "doc": "Audio rate modulateable index into the buffer.\nWarning:: The phase argument only offers precision for addressing 2**24 samples (about 6.3 minutes at 44100Hz).::"
        },
        {
          "name": "loop",
          "default": 1,
          "doc": "1 means true, 0 means false. This is modulateable."
        },
        {
          "name": "interpolation",
          "default": 2,
          "doc": "1 means no interpolation, 2 is linear, 4 is cubic interpolation. \n(The numbers one, two, and four correspond to the number of consecutive\nsamples needed to compute each type of interpolation.)\nAny other values for this argument will silently default to no interpolation."
        }
      ],
      "description": "Read the content of a buffer at an index.\n\nIn comparison to PlayBuf :\nPlayBuf plays through the buffer by itself, BufRd only moves its read point by the phase input and\ntherefore has no pitch input. BufRd has variable interpolation.",
      "related": [
        "BufWr"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "BufSampleRate": {
      "name": "BufSampleRate",
      "summary": "Buffer sample rate.",
      "categories": "UGens>Buffer>Info",
      "rates": [
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": "Buffer index."
        }
      ],
      "description": "Returns the buffer's current sample rate.",
      "related": [
        "BufChannels",
        "BufDur",
        "BufFrames",
        "BufRateScale",
        "BufSamples"
      ],
      "parent": "BufInfoUGenBase",
      "signalRange": null,
      "inheritedFrom": "BufInfoUGenBase"
    },
    "BufSamples": {
      "name": "BufSamples",
      "summary": "Current number of samples in buffer.",
      "categories": "UGens>Buffer>Info",
      "rates": [
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": "Buffer index."
        }
      ],
      "description": "Returns the current number of allocated samples. A sample is not the same as a frame (compare with BufFrames); a frame includes the samples in each channel of the buffer. Only for a mono buffer are samples the same as frames.\n\nsamples = frames * numChannels",
      "related": [
        "BufChannels",
        "BufDur",
        "BufFrames",
        "BufRateScale",
        "BufSampleRate"
      ],
      "parent": "BufInfoUGenBase",
      "signalRange": null,
      "inheritedFrom": "BufInfoUGenBase"
    },
    "BufWr": {
      "name": "BufWr",
      "summary": "Buffer writing oscillator.",
      "categories": "UGens>Buffer",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "inputArray",
          "default": null,
          "doc": "Input UGens (channelArray)."
        },
        {
          "name": "bufnum",
          "default": 0,
          "doc": "The index of the buffer to use."
        },
        {
          "name": "phase",
          "default": 0,
          "doc": "Modulateable index into the buffer (has to be audio rate).\nWarning:: The phase argument only offers precision for addressing 2**24 samples (about 6.3 minutes at 44100Hz) ::"
        },
        {
          "name": "loop",
          "default": 1,
          "doc": "1 means true, 0 means false. This is modulateable."
        }
      ],
      "description": "Write to a buffer at an index.\n\n(Note:  BufWr (in difference to  BufRd) does not do multichannel expansion, because input is an array. )",
      "related": [
        "BufRd"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "COsc": {
      "name": "COsc",
      "summary": "Chorusing wavetable oscillator.",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": "The number of a buffer filled in wavetable format."
        },
        {
          "name": "freq",
          "default": 440,
          "doc": "Frequency in Hertz."
        },
        {
          "name": "beats",
          "default": 0.5,
          "doc": "Beat frequency in Hertz."
        }
      ],
      "description": "Chorusing wavetable lookup oscillator. Produces sum of two signals at\n\n(freq ± (beats / 2)).\n\nDue to summing, the peak amplitude is not the same as the wavetable and can be twice of that.",
      "related": [
        "Osc",
        "OscN",
        "VOsc",
        "VOsc3"
      ],
      "parent": "PureUGen",
      "signalRange": null
    },
    "Changed": {
      "name": "Changed",
      "summary": "Triggers when a value changes",
      "categories": "UGens>Triggers, UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "input",
          "default": null,
          "doc": null
        },
        {
          "name": "threshold",
          "default": 0,
          "doc": null
        }
      ],
      "description": "Triggers when a value changes.",
      "related": [],
      "parent": "Filter",
      "signalRange": null
    },
    "ChaosGen": {
      "name": "ChaosGen",
      "summary": "UGens that cause chaos",
      "categories": "UGens>Generators>Chaotic",
      "rates": [],
      "args": [],
      "description": null,
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "CheckBadValues": {
      "name": "CheckBadValues",
      "summary": "Test for infinity, not-a-number, and denormals",
      "categories": "UGens>Info",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": null
        },
        {
          "name": "id",
          "default": 0,
          "doc": null
        },
        {
          "name": "post",
          "default": 2,
          "doc": null
        }
      ],
      "description": "This UGen tests for infinity, NaN (not a number), and denormals. If one of these is found, it posts a warning. Its output is as follows: 0 = a normal float, 1 = NaN, 2 = infinity, and 3 = a denormal.",
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "Clip": {
      "name": "Clip",
      "summary": "Clip a signal outside given thresholds.",
      "categories": "UGens>Maths",
      "rates": [
        "ar",
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "Signal to be clipped."
        },
        {
          "name": "lo",
          "default": 0,
          "doc": "Low threshold of clipping. Must be less then hi."
        },
        {
          "name": "hi",
          "default": 1,
          "doc": "High threshold of clipping. Must be greater then lo.\n\nExamples::\n\ns.boot;\n\n{ Clip.ar(SinOsc.ar(440, 0, 0.2), -0.07, 0.07) }.scope;"
        }
      ],
      "description": "This differs from the  BinaryOpUGen  Overviews/Methods#clip2#clip2 in that it\nallows one to set both low and high thresholds.",
      "related": [
        "Fold",
        "Wrap"
      ],
      "parent": "InRange",
      "signalRange": null,
      "inheritedFrom": "InRange"
    },
    "ClipNoise": {
      "name": "ClipNoise",
      "summary": "Clip Noise.",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [],
      "description": "Generates noise whose values are either -1 or 1. This produces\nthe maximum energy for the least peak to peak amplitude.",
      "related": [
        "BrownNoise",
        "GrayNoise",
        "PinkNoise",
        "WhiteNoise"
      ],
      "parent": "WhiteNoise",
      "signalRange": null
    },
    "CoinGate": {
      "name": "CoinGate",
      "summary": "Statistical gate.",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "prob",
          "default": null,
          "doc": "Value between 0.0 and 1.0 determines probability of either possibilities."
        },
        {
          "name": "in",
          "default": null,
          "doc": "The trigger input.\n\nExamples::\n\n(\na = SynthDef(\"help-TCoin\", { |out = 0, prob = 0.5|\n\tvar trig;\n\ttrig = CoinGate.kr(prob, Impulse.kr(10));\n\tOut.ar(out,\n\t\tSinOsc.ar(\n\t\t\tTRand.kr(300.0, 400.0, trig), 0, 0.2\n\t\t)\n\t)\n}).play;\n)\n\na.set(\\prob, 1.0);\na.set(\\prob, 0.0);\na.set(\\prob, 0.1);\n\n(\na = SynthDef(\"help-TCoin\", { |out = 0, prob = 0.5|\n\tvar trig;\n\ttrig = Impulse.ar(20, 0, SinOsc.kr(0.5, 0, 1, 1));\n\tOut.ar(out,\n\t\tMix.fill(3, { Ringz.ar(CoinGate.ar(prob, trig*0.5), #[1, 1.5]*Rand(1000, 9000), 0.01) })\n\t)\n}).play;\n)\n\na.set(\\prob, 1.0);\na.set(\\prob, 0.0);\na.set(\\prob, 0.1);"
        }
      ],
      "description": "When CoinGate receives a trigger, it tosses a coin\nand either passes the trigger or doesn't.",
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "CombC": {
      "name": "CombC",
      "summary": "Comb delay line with cubic interpolation.",
      "categories": "UGens>Delays",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "maxdelaytime",
          "default": 0.2,
          "doc": "The maximum delay time in seconds. Used to initialize the delay buffer size."
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Delay time in seconds."
        },
        {
          "name": "decaytime",
          "default": 1,
          "doc": "Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.\n\nLarge decay times are sensitive to DC bias, so use a LeakDC if this is an issue.\n\nInfinite decay times are permitted. A decay time of inf leads to a feedback coefficient of 1, and a decay time of -inf leads to a feedback coefficient of -1."
        }
      ],
      "description": "Comb delay line with cubic interpolation. See also CombN which uses no interpolation, and CombL which uses linear interpolation. Cubic interpolation is more computationally expensive than linear, but more accurate.\n\nThe feedback coefficient is given by the equation  fb == 0.001 ** (delay / decay.abs) * decay.sign  where 0.001 is -60 dBFS.",
      "related": [
        "CombL",
        "CombN",
        "BufCombC"
      ],
      "parent": "CombN",
      "signalRange": null,
      "inheritedFrom": "CombN"
    },
    "CombL": {
      "name": "CombL",
      "summary": "Comb delay line with linear interpolation.",
      "categories": "UGens>Delays",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "maxdelaytime",
          "default": 0.2,
          "doc": "The maximum delay time in seconds. Used to initialize the delay buffer size."
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Delay time in seconds."
        },
        {
          "name": "decaytime",
          "default": 1,
          "doc": "Time for the echoes to decay by 60 decibels. If this time is negative then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.\n\nLarge decay times are sensitive to DC bias, so use a LeakDC if this is an issue.\n\nInfinite decay times are permitted. A decay time of inf leads to a feedback coefficient of 1, and a decay time of -inf leads to a feedback coefficient of -1."
        }
      ],
      "description": "Comb delay line with linear interpolation. See also  CombN\nwhich uses no interpolation, and  CombC  which uses cubic\ninterpolation. Cubic interpolation is more computationally expensive\nthan linear, but more accurate.\n\nThe feedback coefficient is given by the equation  fb == 0.001 ** (delay / decay.abs) * decay.sign  where 0.001 is -60 dBFS.",
      "related": [
        "CombC",
        "CombN",
        "BufCombL"
      ],
      "parent": "CombN",
      "signalRange": null,
      "inheritedFrom": "CombN"
    },
    "CombN": {
      "name": "CombN",
      "summary": "Comb delay line with no interpolation.",
      "categories": "UGens>Delays",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "maxdelaytime",
          "default": 0.2,
          "doc": "The maximum delay time in seconds. Used to initialize the delay buffer size."
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Delay time in seconds."
        },
        {
          "name": "decaytime",
          "default": 1,
          "doc": "Time for the echoes to decay by 60 decibels. If this time is negative, then the feedback coefficient will be negative, thus emphasizing only odd harmonics at an octave lower.\n\nLarge decay times are sensitive to DC bias, so use a LeakDC if this is an issue.\n\nInfinite decay times are permitted. A decay time of inf leads to a feedback coefficient of 1, and a decay time of -inf leads to a feedback coefficient of -1."
        }
      ],
      "description": "Comb delay line with no interpolation. See also  CombL\nwhich uses linear interpolation, and  CombC  which uses\ncubic interpolation. Cubic and linear interpolation are more computationally\nexpensive, but more accurate.\n\nThis UGen will create aliasing artifacts if you modulate the delay time, which is also quantized to the nearest sample period. If these are undesirable properties, use CombL or CombC. But if your delay time is fixed and sub-sample accuracy is not needed, this is the most CPU-efficient choice with no loss in quality.\n\nThe feedback coefficient is given by the equation  fb == 0.001 ** (delay / decay.abs) * decay.sign  where 0.001 is -60 dBFS.",
      "related": [
        "CombC",
        "CombL",
        "BufCombN"
      ],
      "parent": "PureUGen",
      "signalRange": null
    },
    "Compander": {
      "name": "Compander",
      "summary": "Compressor, expander, limiter, gate, ducker",
      "categories": "UGens>Dynamics",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The signal to be compressed / expanded / gated."
        },
        {
          "name": "control",
          "default": 0,
          "doc": "The signal whose amplitude determines the gain applied to the input signal. Often the same as in (for standard gating or compression) but should be different for ducking."
        },
        {
          "name": "thresh",
          "default": 0.5,
          "doc": "Usually between 0 and 1. Amplitude threshold of the control signal, which determines the break point between slopeBelow and slopeAbove. The control signal amplitude is calculated using RMS."
        },
        {
          "name": "slopeBelow",
          "default": 1,
          "doc": "Slope of applied amplitude curve if control signal amplitude is below thresh. If > 1.0, the amplitude drops off more quickly the softer the control signal gets; when the control signal is close to 0 amplitude, the output should be exactly zero -- hence, noise gating. Values < 1.0 are possible, but it means that a very low-level control signal will cause the input signal to be amplified, which would raise the noise floor."
        },
        {
          "name": "slopeAbove",
          "default": 1,
          "doc": "Slope of applied amplitude curve if control signal amplitude is above thresh.\nValues < 1.0 achieve compression (louder signals are attenuated) whereas values > 1.0 expand (louder signals are made even louder). A value of 1/3 achieves a 3:1 compression."
        },
        {
          "name": "clampTime",
          "default": 0.01,
          "doc": "time (in seconds) it takes for the amplitude adjustment to kick in fully after the control signal is above thresh. Usually a small value around 10ms (0.01), often set as low as 2ms (0.002)."
        },
        {
          "name": "relaxTime",
          "default": 0.1,
          "doc": "time (in seconds) for the amplitude adjustment to be released (control signal below thresh). Usually longer than clampTime; depending on the input and control signal, setting both times too short results in (possibly unwanted) artifacts."
        }
      ],
      "description": "General purpose (hard-knee) dynamics processor.",
      "related": [
        "Normalizer",
        "CompanderD",
        "Limiter"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "CompanderD": {
      "name": "CompanderD",
      "summary": "Compressor, expander, limiter, gate, ducker.",
      "categories": "UGens>Dynamics",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The signal to be compressed / expanded / gated."
        },
        {
          "name": "thresh",
          "default": 0.5,
          "doc": "Control signal amplitude threshold, which determines the break point between slopeBelow and slopeAbove. Usually 0..1. The control signal amplitude is calculated using RMS."
        },
        {
          "name": "slopeBelow",
          "default": 1,
          "doc": "Slope of the amplitude curve below the threshold. If this slope > 1.0, the amplitude will drop off more quickly the softer the control signal gets; when the control signal is close to 0 amplitude, the output should be exactly zero -- hence, noise gating. Values < 1.0 are possible, but it means that a very low-level control signal will cause the input signal to be amplified, which would raise the noise floor."
        },
        {
          "name": "slopeAbove",
          "default": 1,
          "doc": "Same thing, but above the threshold. Values < 1.0 achieve compression (louder signals are attenuated); > 1.0, you get expansion (louder signals are made even louder). For 3:1 compression, you would use a value of 1/3 here."
        },
        {
          "name": "clampTime",
          "default": 0.01,
          "doc": "The amount of time it takes for the amplitude adjustment to kick in fully. This is usually pretty small, not much more than 10 milliseconds (the default value). I often set it as low as 2 milliseconds (0.002)."
        },
        {
          "name": "relaxTime",
          "default": 0.01,
          "doc": "The amount of time for the amplitude adjustment to be released. Usually a bit longer than clampTime; if both times are too short, you can get some (possibly unwanted) artifacts."
        }
      ],
      "description": "CompanderD passes the signal directly to the control input, but\nadds a delay to the process input so that the lag in the gain clamping\nwill not lag the attacks in the input sound.",
      "related": [
        "Amplitude",
        "Compander",
        "Normalizer",
        "Limiter"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Control": {
      "name": "Control",
      "summary": "Bring signals and floats into the ugenGraph function of a SynthDef.",
      "categories": "UGens>Synth control",
      "rates": [
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "values",
          "default": null,
          "doc": "default values."
        }
      ],
      "description": "A Control is a UGen that can be set and routed externally to interact with a running Synth.\nTypically, Controls are created from the arguments of a SynthDef function.\n\nGenerally you do not create Controls yourself. (See Arrays example\nbelow).\n\nThe rate may be either .kr (continuous control rate signal) or .ir (a\nstatic value, set at the time the synth starts up, and subsequently\nunchangeable). For .ar, see AudioControl\n\nSynthDef creates these when compiling the ugenGraph function. They are\ncreated for you, you use them, and you don't really need to worry about\nthem if you don't want to.\n\nFor a more concise combination of name, default value and lag, see NamedControl",
      "related": [
        "NamedControl",
        "LagControl",
        "TrigControl"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "ControlDur": {
      "name": "ControlDur",
      "summary": "Duration of one block",
      "categories": "UGens>Info",
      "rates": [
        "ir"
      ],
      "args": [],
      "description": "Returns the current block duration of the server in seconds. Equivalent to  1 / ControlRate.",
      "related": [
        "ControlRate"
      ],
      "parent": "InfoUGenBase",
      "signalRange": null
    },
    "ControlRate": {
      "name": "ControlRate",
      "summary": "Server control rate.",
      "categories": "UGens>Info",
      "rates": [
        "ir"
      ],
      "args": [],
      "description": "Get the current control rate of the server.",
      "related": [
        "RadiansPerSample",
        "SampleDur",
        "SampleRate",
        "SubsampleOffset"
      ],
      "parent": "InfoUGenBase",
      "signalRange": null
    },
    "Convolution": {
      "name": "Convolution",
      "summary": "Real-time convolver.",
      "categories": "UGens>FFT, UGens>Convolution",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "Processing target."
        },
        {
          "name": "kernel",
          "default": null,
          "doc": "Processing kernel."
        },
        {
          "name": "framesize",
          "default": 512,
          "doc": "Size of FFT frame, must be a power of two (512, 1024, 2048, 4096 are standard choices).\nConvolution uses twice this number internally.\nNote that the convolution gets progressively more expensive to run for higher powers!\nThe maximum value you can use is 2^16 = 16384.\n(This upper limit is half of \"SC_FFT_MAXSIZE\" defined in the SC source code.)\nLarger convolutions than this can be done using PartConv."
        }
      ],
      "description": "Strict convolution of two continuously changing inputs. Also see\nConvolution2  for a cheaper CPU cost alternative for the\ncase of a fixed kernel which can be changed with a trigger message.\n\nSee also  link::http://www.dspguide.com/ch18.htm::  by Steven W.\nSmith.",
      "related": [
        "Convolution2",
        "Convolution2L",
        "Convolution3"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Convolution2": {
      "name": "Convolution2",
      "summary": "Real-time fixed kernel convolver.",
      "categories": "UGens>FFT, UGens>Convolution",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "Processing target."
        },
        {
          "name": "kernel",
          "default": null,
          "doc": "Buffer index for the fixed kernel, may be modulated in\ncombination with the trigger. It's size must be <= framesize."
        },
        {
          "name": "trigger",
          "default": 0,
          "doc": "Update the kernel on a change from non-positive to positive\nvalue."
        },
        {
          "name": "framesize",
          "default": 2048,
          "doc": "Size of FFT frame, must be a power of two (512, 1024, 2048, 4096 are standard choices).\nConvolution uses twice this number internally.\nNote that the convolution gets progressively more expensive to run for higher powers!\nThe maximum value you can use is 2^16 = 16384.\n(This upper limit is half of \"SC_FFT_MAXSIZE\" defined in the SC source code.)\nLarger convolutions than this can be done using PartConv."
        }
      ],
      "description": "Strict convolution with fixed kernel which can be updated using a trigger\nsignal.\n\nInternally, this unit uses FFT to accelerate the calculation, which means that\n(a) you must specify a \"framesize\", and\n(b) if the kernel is longer than this framesize, the end of it will be ignored.\n\nSee also link::http://www.dspguide.com/ch18.htm:: by Steven W.\nSmith.",
      "related": [
        "Convolution",
        "Convolution2L",
        "Convolution3"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Convolution2L": {
      "name": "Convolution2L",
      "summary": "Real-time convolver with linear interpolation",
      "categories": "UGens>FFT, UGens>Convolution",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "processing target"
        },
        {
          "name": "kernel",
          "default": null,
          "doc": "buffer index for the fixed kernel, may be modulated in combination with the trigger"
        },
        {
          "name": "trigger",
          "default": 0,
          "doc": "update the kernel on a change from <=0 to >0"
        },
        {
          "name": "framesize",
          "default": 2048,
          "doc": "size of FFT frame, must be a power of two (512, 1024, 2048, 4096 are standard choices).\nConvolution uses twice this number internally.\nNote that the convolution gets progressively more expensive to run for higher powers!\nThe maximum value you can use is 2^16 = 16384.\n(This upper limit is half of \"SC_FFT_MAXSIZE\" defined in the SC source code.)\nLarger convolutions than this can be done using PartConv."
        },
        {
          "name": "crossfade",
          "default": 1,
          "doc": "The number of periods over which a crossfade is made. The default is 1. This must be an integer."
        }
      ],
      "description": "Strict convolution with fixed kernel which can be updated using a trigger signal. There is a linear crossfade between the buffers upon change.\n\nSee  Steven W Smith, The Scientist and Engineer's Guide to Digital Signal Processing: chapter 18 -\nhttp://www.dspguide.com/ch18.htm",
      "related": [
        "Convolution",
        "Convolution2",
        "Convolution3",
        "StereoConvolution2L"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Convolution3": {
      "name": "Convolution3",
      "summary": "Time based convolver.",
      "categories": "UGens>Convolution",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "processing target"
        },
        {
          "name": "kernel",
          "default": null,
          "doc": "buffer index for the fixed kernel, may be modulated in combination with the trigger"
        },
        {
          "name": "trigger",
          "default": 0,
          "doc": "update the kernel on a change from <=0 to >0"
        },
        {
          "name": "framesize",
          "default": 2048,
          "doc": "maximum size of the buffer containing the kernel"
        }
      ],
      "description": "Strict convolution with fixed kernel which can be updated using a trigger signal. The convolution is performed in the time domain.\n\n(Note: \nDoing convolution in time domain is highly inefficient, and probably only useful for either very short kernel sizes, or for control rate signals.\nSee Convolution2 and Convolution2L for more efficient convolution UGens.\n)",
      "related": [
        "Convolution",
        "Convolution2",
        "Convolution2L"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Crackle": {
      "name": "Crackle",
      "summary": "Chaotic noise function.",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "chaosParam",
          "default": 1.5,
          "doc": "A parameter of the chaotic function with useful values from\njust below 1.0 to just above 2.0. Towards 2.0 the sound crackles."
        }
      ],
      "description": "A noise generator based on a chaotic function.",
      "related": [
        "LatoocarfianN",
        "Logistic"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "CuspL": {
      "name": "CuspL",
      "summary": "Cusp map chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": "Iteration frequency in Hertz"
        },
        {
          "name": "a",
          "default": 1,
          "doc": "Equation variable"
        },
        {
          "name": "b",
          "default": 1.9,
          "doc": "Equation variable"
        },
        {
          "name": "xi",
          "default": 0,
          "doc": "Initial value of x"
        }
      ],
      "description": "A linear-interpolating sound generator based on the difference equation:\n\nteletype::\n\tx(n+1) = a - b * sqrt(|x(n)|)\n\nsclang code translation:\n\n(\nvar a = 1.0, b = 1.9, xi = 0, size = 64;\nplot(size.collect { xi = a - (b * sqrt(abs(xi))) });\n)",
      "related": [
        "CuspN"
      ],
      "parent": "CuspN",
      "signalRange": null,
      "inheritedFrom": "CuspN"
    },
    "CuspN": {
      "name": "CuspN",
      "summary": "Cusp map chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": "Iteration frequency in Hertz"
        },
        {
          "name": "a",
          "default": 1,
          "doc": "Equation variable"
        },
        {
          "name": "b",
          "default": 1.9,
          "doc": "Equation variable"
        },
        {
          "name": "xi",
          "default": 0,
          "doc": "Initial value of x"
        }
      ],
      "description": "A non-interpolating sound generator based on the difference equation:\n\nteletype::\n\tx(n+1) = a - b * sqrt(|x(n)|)\n\nsclang code translation:\n\n(\nvar a = 1.0, b = 1.9, xi = 0, size = 64;\nplot(size.collect { xi = a - (b * sqrt(abs(xi))) });\n)",
      "related": [
        "CuspL"
      ],
      "parent": "ChaosGen",
      "signalRange": null
    },
    "DC": {
      "name": "DC",
      "summary": "Create a constant amplitude signal",
      "categories": "UGens>Generators>Single-value",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "constant value to output, cannot be modulated, set at initialisation time"
        }
      ],
      "description": "This UGen simply outputs the initial value you give it.",
      "related": [
        "LeakDC"
      ],
      "parent": "PureMultiOutUGen",
      "signalRange": null
    },
    "Decay": {
      "name": "Decay",
      "summary": "Exponential decay",
      "categories": "UGens>Filters>Linear, UGens>Envelopes",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "decayTime",
          "default": 1,
          "doc": "The time it takes for the input signal to decay 60 dB."
        }
      ],
      "description": "An integrating filter which, if given an impulse, will produce an exponentially decaying envelope.\nDecay is essentially the same as Integrator, but instead of specifying the integration coefficient directly, it is calculated from the decayTime—the time required for input signal to attentuate 60 dB, or decay to 99.9% of its value.",
      "related": [
        "Decay2",
        "Integrator"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "Decay2": {
      "name": "Decay2",
      "summary": "Exponential decay",
      "categories": "UGens>Filters>Linear, UGens>Envelopes",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "attackTime",
          "default": 0.01,
          "doc": "60 dB attack time in seconds."
        },
        {
          "name": "decayTime",
          "default": 1,
          "doc": "60 dB decay time in seconds."
        }
      ],
      "description": "An integrating filter like Decay, but both the onset time and decay time can be specified.\n\nteletype::\nDecay2.ar(in, attackTime, decayTime)\n\nis equivalent to:\n\nteletype::\nDecay.ar(in, decayTime) - Decay.ar(in, attackTime)\n\nFor precise control over the attack, decay, and level of Decay2 see #Onset control and normalizing the envelope of Decay2 and #Calculating rise time and maximum rise time of Decay2 below.",
      "related": [
        "Decay",
        "Integrator"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "DecodeB2": {
      "name": "DecodeB2",
      "summary": "2D Ambisonic B-format decoder.",
      "categories": "UGens>Multichannel>Ambisonics",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "numChans",
          "default": null,
          "doc": "Number of output speakers. Typically 4 to 8. Must be a nonzero, positive integer. This is fixed when the SynthDef is compiled so cannot be assigned to a SynthDef argument."
        },
        {
          "name": "w",
          "default": null,
          "doc": "The B-format signal."
        },
        {
          "name": "x",
          "default": null,
          "doc": "The B-format signal."
        },
        {
          "name": "y",
          "default": null,
          "doc": "The B-format signal."
        },
        {
          "name": "orientation",
          "default": 0.5,
          "doc": "Should be zero if the front is a vertex of the polygon. The first\nspeaker will be directly in front. Should be 0.5 if the front\nbisects a side of the polygon. Then the first speaker will be the\none left of center."
        }
      ],
      "description": "Decode a two dimensional ambisonic B-format signal to a set of speakers\nin a regular polygon. The outputs will be in clockwise order. The\nposition of the first speaker is either center or left of center.",
      "related": [
        "BiPanB2",
        "PanB",
        "PanB2",
        "Rotate2"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "DegreeToKey": {
      "name": "DegreeToKey",
      "summary": "Convert signal to modal pitch.",
      "categories": "UGens>Conversion",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": "Index of the buffer which contains the steps for each scale\ndegree."
        },
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "octave",
          "default": 12,
          "doc": "The number of steps per octave in the scale."
        }
      ],
      "description": "The input signal value is truncated to an integer value and used as an\nindex into an octave repeating table of note values. Indices wrap around\nthe table and shift octaves as they do.",
      "related": [],
      "parent": "PureUGen",
      "signalRange": null
    },
    "DelTapRd": {
      "name": "DelTapRd",
      "summary": "Tap a delay line from a DelTapWr UGen",
      "categories": "UGens>Buffer, UGens>Delays",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "buffer",
          "default": null,
          "doc": null
        },
        {
          "name": "phase",
          "default": null,
          "doc": null
        },
        {
          "name": "delTime",
          "default": null,
          "doc": null
        },
        {
          "name": "interp",
          "default": 1,
          "doc": null
        }
      ],
      "description": "Tap a delay line from a DelTapWr UGen.\n\n(Note:  If you run a DelTapRd.ar and a DelTapWr.ar in tandem, keep in mind that they read and write in blocks\nequal to the server's block size. If the delay time is greater than the buffer size minus a block, the write and read\nheads might interfere in unintended ways. Use a slightly larger buffer if this happens.)",
      "related": [
        "DelTapWr"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "DelTapWr": {
      "name": "DelTapWr",
      "summary": "Write to a buffer for a DelTapRd UGen",
      "categories": "UGens>Buffer, UGens>Delays",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "buffer",
          "default": null,
          "doc": null
        },
        {
          "name": "in",
          "default": null,
          "doc": null
        }
      ],
      "description": "Write to a buffer for a DelTapRd UGen.\n\n(Note:  If you run a DelTapRd.ar and a DelTapWr.ar in tandem, keep in mind that they read and write in blocks\nequal to the server's block size. If the delay time is greater than the buffer size minus a block, the write and read\nheads might interfere in unintended ways. Use a slightly larger buffer if this happens. )",
      "related": [
        "DelTapRd"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Delay1": {
      "name": "Delay1",
      "summary": "Single sample delay.",
      "categories": "UGens>Delays",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "x1",
          "default": 0,
          "doc": "The sample value preceding the delayed input, which is the value of the first output sample.\nThis can be a numeric value or a UGen.\n\n(Note: \nWhen running at audio rate, x1 defaults to 0.0, i.e. \"silence\" precedes the delayed input.\nAt control rate, the default value is set to the first sample of in, i.e. the first input sample is held during the delay.\n)"
        }
      ],
      "description": "Delays the input by one audio frame or control period.",
      "related": [
        "Delay2",
        "TDelay"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "Delay2": {
      "name": "Delay2",
      "summary": "Two sample delay.",
      "categories": "UGens>Delays",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "x1",
          "default": 0,
          "doc": "The sample directly preceding the delayed input signal, which is the second output sample.\nThis can be a numeric value or a UGen."
        },
        {
          "name": "x2",
          "default": 0,
          "doc": "The sample preceding the delayed input signal by two samples, which is the first output sample.\nThis can be a numeric value or a UGen.\n\n(Note: \nWhen running at audio rate, x1 and x2 default to 0.0, i.e. \"silence\" precedes the delayed input.\nAt control rate, the default values are set to the first sample of in, i.e. the first input sample is held during the delay.\n)"
        }
      ],
      "description": "Delays the input by two samples.",
      "related": [
        "Delay1",
        "TDelay"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "DelayC": {
      "name": "DelayC",
      "summary": "Simple delay line with cubic interpolation.",
      "categories": "UGens>Delays",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "maxdelaytime",
          "default": 0.2,
          "doc": "The maximum delay time in seconds. used to initialize the delay buffer size."
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Delay time in seconds."
        }
      ],
      "description": "Simple delay line with cubic interpolation. See also\nDelayN  which uses no interpolation, and\nDelayL  which uses linear interpolation. Cubic\ninterpolation is more computationally expensive than linear,\nbut more accurate.\n\nThe term \"delay\" is often used in electronic music to refer to a delay line with feedback. If you are looking for that, try CombC.",
      "related": [
        "DelayL",
        "DelayN",
        "BufDelayC"
      ],
      "parent": "DelayN",
      "signalRange": null,
      "inheritedFrom": "DelayN"
    },
    "DelayL": {
      "name": "DelayL",
      "summary": "Simple delay line with linear interpolation.",
      "categories": "UGens>Delays",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "maxdelaytime",
          "default": 0.2,
          "doc": "The maximum delay time in seconds. used to initialize the delay buffer size."
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Delay time in seconds."
        }
      ],
      "description": "Simple delay line with linear interpolation. See also\nDelayN  which uses no interpolation, and\nDelayC  which uses cubic interpolation. Cubic\ninterpolation is more computationally expensive than linear,\nbut more accurate.\n\nThe term \"delay\" is often used in electronic music to refer to a delay line with feedback. If you are looking for that, try CombL.",
      "related": [
        "DelayC",
        "DelayN",
        "BufDelayL"
      ],
      "parent": "DelayN",
      "signalRange": null,
      "inheritedFrom": "DelayN"
    },
    "DelayN": {
      "name": "DelayN",
      "summary": "Simple delay line with no interpolation.",
      "categories": "UGens>Delays",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "maxdelaytime",
          "default": 0.2,
          "doc": "The maximum delay time in seconds, used to initialize the delay buffer size."
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Delay time in seconds."
        }
      ],
      "description": "Simple delay line with no interpolation. See also\nDelayL  which uses linear interpolation, and\nDelayC  which uses cubic interpolation.\n\nThis UGen will create aliasing artifacts if you modulate the delay time, which is also quantized to the nearest sample period. If these are undesirable properties, use DelayL or DelayC. But if your delay time is fixed and sub-sample accuracy is not needed, this is the most CPU-efficient choice with no loss in quality.\n\nThe term \"delay\" is often used in electronic music to refer to a delay line with feedback. If you are looking for that, try CombN.",
      "related": [
        "Delay1",
        "Delay2",
        "DelayC",
        "DelayL",
        "BufDelayN"
      ],
      "parent": "PureUGen",
      "signalRange": null
    },
    "Demand": {
      "name": "Demand",
      "summary": "Demand results from demand rate UGens.",
      "categories": "UGens>Demand",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "trig",
          "default": null,
          "doc": "Trigger. Can be any signal. A trigger happens when the signal\nchanges from non-positive to positive."
        },
        {
          "name": "reset",
          "default": null,
          "doc": "Trigger. Resets the list of UGens when triggered."
        },
        {
          "name": "demandUGens",
          "default": null,
          "doc": "List of demand-rate UGens to get values from. When the shortest stream ends, this ugen will set the Classes/Done##'done' flag."
        }
      ],
      "description": "When there is a trigger at the trig input, a value is demanded each UGen\nin the list and output. The unit generators in the list should be\n'demand' rate.\n\nWhen there is a trigger at the reset input, the demand rate UGens in the\nlist are reset.",
      "related": [
        "Duty",
        "TDuty"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "DemandEnvGen": {
      "name": "DemandEnvGen",
      "summary": "Demand rate envelope generator",
      "categories": "UGens>Demand, UGens>Envelopes",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "level",
          "default": null,
          "doc": "A demand UGen or any other UGen returning level values. If this ends, the\n\ndoneAction  is evaluated."
        },
        {
          "name": "dur",
          "default": null,
          "doc": "A demand UGen or any other UGen returning time values. If this ends, the\n\ndoneAction  is evaluated."
        },
        {
          "name": "shape",
          "default": 1,
          "doc": "A demand UGen or any other UGen: the number given is the shape\nnumber according to Env."
        },
        {
          "name": "curve",
          "default": 0,
          "doc": "A demand UGen or any other UGen returning curve values. if shape is 5, this is the\ncurve factor.\n\nThe possible values are:\ntable::\n- 0 || flat segments\n- 1 || linear segments, the default\n- 2 || natural exponential growth and decay. In this case, the levels must all be nonzero and the have the same sign.\n- 3 || sinusoidal S shaped segments.\n- 4 || sinusoidal segments shaped like the sides of a Welch window.\n- a Float || a curvature value for all segments.\n- An Array of Floats || curvature values for each segments."
        },
        {
          "name": "gate",
          "default": 1,
          "doc": "If gate is x ≥ 1, the UGen runs.\n\nIf gate is 0 > x > 1, the UGen is released at the next\nlevel (doneAction).\n\nIf gate is x < 0, the UGen is sampled and held."
        },
        {
          "name": "reset",
          "default": 1,
          "doc": "If reset crosses from non-positive to positive, the UGen is reset\nat the next level. If it is > 1, it is reset immediately."
        },
        {
          "name": "levelScale",
          "default": 1,
          "doc": "demand ugen returning level scaling values"
        },
        {
          "name": "levelBias",
          "default": 0,
          "doc": "demand ugen returning level offset values"
        },
        {
          "name": "timeScale",
          "default": 1,
          "doc": "demand ugen returning time scaling values"
        },
        {
          "name": "doneAction",
          "default": 0,
          "doc": "A doneAction that is evaluated when level or duration stream\nends. See Done  for more detail.\n\nExamples::\n\n// frequency envelope with random times\n(\n\t{\n\t\tvar freq;\n\t\tfreq = DemandEnvGen.ar(\n\t\t\t\tDseq([204, 400, 201, 502, 300, 200], inf),\n\t\t\t\tDrand([1.01, 0.2, 0.1, 2], inf) * MouseY.kr(0.01, 3, 1),\n\t\t\t\t7 // cubic interpolation\n\t\t\t);\n\t\tSinOsc.ar(freq * [1, 1.01]) * 0.1\n\n\t}.play;\n)\n\n// frequency modulation\n(\n\t{\n\t\tvar freq, list;\n\t\tlist = { exprand(200, 1000.0) } ! 32;\n\t\tfreq = DemandEnvGen.ar(\n\t\t\t\t{ Dseq(list.scramble, inf) } ! 2,\n\t\t\t\tSampleDur.ir * MouseY.kr(1, 3000, 1),\n\t\t\t\t5, // curve interpoaltion\n\t\t\t\tMouseX.kr(-0.01, -4) // curve must be negative for fast interpol.\n\t\t\t);\n\t\tSinOsc.ar(freq) * 0.1\n\n\t}.play;\n)\n\n//  gate\n// mouse x on right side of screen toggles gate\n(\n\t{\n\t\tvar freq;\n\t\tfreq = DemandEnvGen.kr(\n\t\t\t\tDwhite(300, 1000, inf).round(100),\n\t\t\t\t0.1,\n\t\t\t\t5, 0.3, // curve: 0.3\n\t\t\t\tMouseX.kr > 0.5,\n\t\t\t\t1\n\t\t\t);\n\t\tSinOsc.ar(freq * [1, 1.21]) * 0.1\n\n\t}.play;\n)\n\n// sample and hold (0.5 > gate > 0)\n// mouse x on right side of screen toggles gate\n// mouse y scales frequency\n(\n\t{\n\t\tvar freq;\n\t\tfreq = DemandEnvGen.kr(\n\t\t\t\tDwhite(300, 1000, inf).round(100),\n\t\t\t\t0.1,\n\t\t\t\t5, 0.3,\n\t\t\t\tMouseX.kr > 0.5 + 0.1\n\t\t\t);\n\t\tSinOsc.ar(freq * [1, 1.21]) * 0.1\n\n\t}.play;\n)\n\n// gate\n// mouse x on right side of screen toggles gate\n// mouse button does soft reset\n(\n\t{\n\t\tvar freq;\n\t\tfreq = DemandEnvGen.kr(\n\t\t\t\tDseq([Dseries(400, 200, 5), 500, 800, 530, 4000, 900], 2),\n\t\t\t\tDseq([0.2, 0.1, 0.2, 0.3, 0.1], inf),\n\t\t\t\tDseq([1, 0, 0, 6, 1, 1, 0, 2], inf), // shapes\n\t\t\t\t0,\n\t\t\t\tMouseX.kr > 0.5, // gate\n\t\t\t\tMouseButton.kr > 0.5, // reset\n\t\t\t\tdoneAction: Done.none\n\t\t\t);\n\t\tSinOsc.ar(freq * [1, 1.001]) * 0.1\n\n\t}.play;\n)\n\n//  gate\n// mouse x on right side of screen toggles sample and hold\n// mouse button does hard reset\n(\n\t{\n\t\tvar freq;\n\t\tfreq = DemandEnvGen.kr(\n\t\t\t\tDseq([Dseries(400, 200, 5), 500, 800, 530, 4000, 900], 2),\n\t\t\t\t0.1,\n\t\t\t\t3, 0,\n\t\t\t\tMouseX.kr > 0.5 - 0.1, // gate: sample and hold\n\t\t\t\tMouseButton.kr > 0.5 * 2, // hard reset\n\t\t\t\tdoneAction: Done.none\n\t\t\t);\n\t\tSinOsc.ar(freq * [1, 1.001]) * 0.1\n\n\t}.play;\n)\n\n// short sequence with doneAction, linear\n(\n\t{\n\t\tvar freq;\n\t\tfreq = DemandEnvGen.kr(\n\t\t\t\tDseq([1300, 500, 800, 300, 400], 1),\n\t\t\t\t0.2,\n\t\t\t\t1,\n\t\t\t\tdoneAction: Done.freeSelf\n\t\t\t);\n\t\tSinOsc.ar(freq * [1, 1.01]) * 0.1\n\n\t}.play;\n)\n\n// short sequence with doneAction, step\n(\n\t{\n\t\tvar freq;\n\t\tfreq = DemandEnvGen.kr(\n\t\t\t\tDseq([1300, 500, 800, 300, 400], 1),\n\t\t\t\t0.2,\n\t\t\t\t0,\n\t\t\t\tdoneAction: Done.freeSelf\n\t\t\t);\n\t\tSinOsc.ar(freq * [1, 1.01]) * 0.1\n\n\t}.play;\n)\n\n// a linear ramp\n(\n\t{\n\t\tvar freq;\n\t\tfreq = DemandEnvGen.kr(\n\t\t\t\tDseq([300, 800], 1),\n\t\t\t\t1,\n\t\t\t\t1\n\t\t\t);\n\t\tSinOsc.ar(freq * [1, 1.01]) * 0.1\n\n\t}.play;\n)\n\n// random gate:  release. gate low level > 0.\n// only end points are kept as release levels\n(\n\t{\n\t\tvar freq;\n\t\tfreq = DemandEnvGen.kr(\n\t\t\t\tDseq([500, 800], inf),\n\t\t\t\t0.03,\n\t\t\t\t1, 0, // linear\n\t\t\t\tToggleFF.kr(Dust.kr(5)) + 0.1 // gate\n\n\t\t\t);\n\t\tSinOsc.ar(freq * [1, 1.01]) * 0.1\n\n\t}.play;\n)\n\n// random gate: sample and hold. gate low level = 0.\n(\n\t{\n\t\tvar freq;\n\t\tfreq = DemandEnvGen.kr(\n\t\t\t\tDseq([500, 800, 600], inf),\n\t\t\t\t0.03,\n\t\t\t\t1, 0, // linear\n\t\t\t\tToggleFF.kr(Dust.kr(5)), // gate\n\t\t\t\t0 // reset\n\n\t\t\t);\n\t\tSinOsc.ar(freq * [1, 1.01]) * 0.1\n\n\t}.play;\n)\n\n// lfnoise1\n(\n\t{\n\t\t\tDemandEnvGen.ar(\n\t\t\t\tDwhite(-0.1, 0.1, inf),\n\t\t\t\tSampleDur.ir * MouseY.kr(0.5, 20),\n\t\t\t\t5,\n\t\t\t\t-4\n\t\t\t);\n\n\t}.play;\n)\n\n// lfbrownnoise\n(\n\t{\n\t\t\tDemandEnvGen.ar(\n\t\t\t\tDbrown(-0.1, 0.1, 0.1, inf),\n\t\t\t\tSampleDur.ir * MouseY.kr(1, 100, 1)\n\t\t\t);\n\n\t}.play;\n)\n\n// hardsyncing a saw\n(\n\t{\n\n\t\t\tDemandEnvGen.ar(\n\t\t\t\tDseq([Dseries(-0.1, 0.01, 20)], inf),\n\t\t\t\tSampleDur.ir * MouseY.kr(1, 100, 1),\n\t\t\t\t1, 0,\n\t\t\t\tK2A.ar(1),\n\t\t\t\tImpulse.ar(MouseX.kr(1, SampleRate.ir * MouseX.kr(0.002, 1, 1), 1), 0, 1.5)\n\n\t\t\t)\n\n\t}.scope;\n)\n\n// softsyncing a saw\n(\n\t{\n\n\t\t\tDemandEnvGen.ar(\n\t\t\t\tDseq([Dseries(-0.1, 0.01, 20)], inf),\n\t\t\t\tSampleDur.ir * MouseY.kr(1, 100, 1),\n\t\t\t\t1, 0,\n\t\t\t\tK2A.ar(1),\n\t\t\t\tImpulse.ar(MouseX.kr(1, SampleRate.ir * MouseX.kr(0.002, 1, 1), 1)) + [0, 0.3]\n\n\t\t\t)\n\n\t}.scope;\n)\n\n// hardsyncing a saw, some random elements\n(\n\t{\n\n\t\t\tDemandEnvGen.ar(\n\t\t\t\tDseq([Dseries(-0.1, 0.01, 20), Dseries(-0.1, 0.01, 20), Dwhite(-0.1, 0.1, 5)], inf),\n\t\t\t\tSampleDur.ir * MouseY.kr(1, 100, 1),\n\t\t\t\t3, 0,\n\t\t\t\t1,\n\t\t\t\tImpulse.ar(MouseX.kr(1, SampleRate.ir * MouseX.kr(0.002, 1, 1), 1), 0, 1.5)\n\n\t\t\t)\n\n\t}.scope;\n)\n\n// softsyncing a saw, some random elements\n(\n\t{\n\n\t\t\tDemandEnvGen.ar(\n\t\t\t\tDseq([Dseries(-0.1, 0.01, 20), Dseries(-0.1, 0.01, 20), Dwhite(-0.1, 0.1, 5)], inf),\n\t\t\t\tSampleDur.ir * MouseY.kr(1, 100, 1),\n\t\t\t\t1, 0, // linear interpolation\n\t\t\t\t1,\n\t\t\t\tImpulse.ar(MouseX.kr(1, SampleRate.ir * MouseX.kr(0.002, 1, 1), 1))\n\n\t\t\t)\n\n\t}.scope;\n)\n\n// multichannel expansion\n// mouse x on right side of screen toggles gate\n// mouse y controls speed\n\n(\n\t{\n\t\tvar freq;\n\t\tfreq = DemandEnvGen.kr(\n\t\t\t\t{ Dseq([300, 800, Drand([1000, 460, 300], 1), 400], inf) + 3.0.rand } ! 2,\n\t\t\t\tMouseY.kr(0.001, 2, 1),\n\t\t\t\t5, -4,\n\t\t\t\tMouseX.kr > 0.5\n\t\t\t);\n\t\tSinOsc.ar(freq) * 0.1\n\n\t}.play;\n)"
        }
      ],
      "description": "Plays back break point envelope contours (levels, times, shapes) given by demand ugens. The next values are called when the next node is reached.",
      "related": [
        "Demand",
        "Duty",
        "TDuty"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "DetectIndex": {
      "name": "DetectIndex",
      "summary": "Search a buffer for a value",
      "categories": "UGens>Buffer",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": null
        },
        {
          "name": "in",
          "default": 0,
          "doc": null
        }
      ],
      "description": "Linearly searches a buffer for a value (i.e., loops over the frames in the\nbuffer from the beginning, checking for float equality), and returns index of first occurrence of said value.\nReturns -1 if value is not found.\nThe object performs a search whenever a change in the in argument is\ndetected; \nchanges in the bufnum argument do not trigger searches.\nChecks for changes occur at the selected rate (ar or kr).",
      "related": [],
      "parent": "Index",
      "signalRange": null,
      "inheritedFrom": "Index"
    },
    "DetectSilence": {
      "name": "DetectSilence",
      "summary": "Detect when input falls below an amplitude threshold",
      "categories": "UGens>Synth control, UGens>Analysis>Amplitude",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "amp",
          "default": 0.0001,
          "doc": "When input falls below this for long enough, evaluate\n\ndoneAction ."
        },
        {
          "name": "time",
          "default": 0.1,
          "doc": "The minimum duration for which input must fall below\n\namp  before this triggers."
        },
        {
          "name": "doneAction",
          "default": 0,
          "doc": "An integer representing the doneAction. See\n\nDone  for more detail."
        }
      ],
      "description": "When the absolute value of the input signal remains below the threshold for a given window of time, output 1. Otherwise, output 0. If the output transitions from 0 to 1, doneAction is also evaluated.\n\n// this frees after the Decay has become quiet enough for a long enough time\n{ var signal = Decay.ar(Impulse.ar(0), 2, PinkNoise.ar(0.2)); DetectSilence.ar(signal, doneAction: Done.freeSelf); signal }.play;\n\nIf the input signal starts with silence at the beginning of the synth's duration, then DetectSilence will wait indefinitely until the first sound before starting to monitor for silence. To avoid a hanging silent sound where the input may remain zero, you can add an Impulse.ar(0) to its input.\n\nDetectSilence does not distinguish a DC-biased signal from a loud signal. If your signal has DC bias, you should wrap it in LeakDC.\n\n(Warning:  DetectSilence can be tricky with multi-channel input! See below. )",
      "related": [],
      "parent": "Filter",
      "signalRange": null
    },
    "Dibrown": {
      "name": "Dibrown",
      "summary": "Demand rate brownian movement generator.",
      "categories": "UGens>Demand",
      "rates": [],
      "args": [],
      "description": "Dbrown  returns numbers in the continuous range between\nlo  and  hi,\nDibrown returns integer values.\n\nThe arguments can be a number or any other UGen.\n\nSee Pbrown, BrownNoise  for structurally related\nequivalents.",
      "related": [
        "Dbrown",
        "Demand",
        "Duty",
        "TDuty"
      ],
      "parent": "Dbrown",
      "signalRange": null
    },
    "DigitalIO": {
      "name": "DigitalIO",
      "summary": "Read or write data to a digital pin",
      "categories": "UGens>Bela",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "digitalPin",
          "default": 0,
          "doc": "Digital pin number to write to. Pin numbers begin at 0."
        },
        {
          "name": "output",
          "default": 0,
          "doc": "Value to write out to the pin - the value will be 1 when the argument is larger than 0, otherwise 0."
        },
        {
          "name": "pinMode",
          "default": 0,
          "doc": "Value to write out to the pin - the pin will be an input when the argument is smaller than 0.5, otherwise an output."
        }
      ],
      "description": "Reads or writes digital data from or to a digital pin.\nThe pin number of this UGen can be modulated, as well as its I/O mode, which allows to tri-state the pin.\n\n(Note: \nThis UGen only works on Bela.\n)\n\n(Note: \nIf you do not need to change the pin mode or the pin, you should use the UGen DigitalIn or DigitalOut\n)",
      "related": [
        "AnalogIn",
        "AnalogOut",
        "DigitalIn",
        "DigitalOut"
      ],
      "parent": "UGen",
      "signalRange": "unipolar"
    },
    "DigitalIn": {
      "name": "DigitalIn",
      "summary": "Read data from a digital input",
      "categories": "UGens>Bela",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "digitalPin",
          "default": 0,
          "doc": "Digital pin number to read. Pin numbers begin at 0. This value cannot be modulated."
        }
      ],
      "description": "Reads digital data from a digital sensor input (e.g.: a button or trigger input).\n\n(Note: \nThis UGen only works on Bela.\n)\n\n(Note: \nIf you want to modulate the pin number, you should use the UGen DigitalIO\n)",
      "related": [
        "AnalogIn",
        "AnalogOut",
        "DigitalOut",
        "DigitalIO"
      ],
      "parent": "UGen",
      "signalRange": "unipolar"
    },
    "DigitalOut": {
      "name": "DigitalOut",
      "summary": "Write data to a digital output",
      "categories": "UGens>Bela",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "digitalPin",
          "default": 0,
          "doc": "Digital pin number to write to. Pin numbers begin at 0. This value cannot be modulated."
        },
        {
          "name": "output",
          "default": 0,
          "doc": "Value to write out to the pin - the value will be 1 when the argument is larger than 0, otherwise 0."
        }
      ],
      "description": "Writes digital data to a digital output (e.g.: an LED or a trigger/gate output).\n\n(Note: \nThis UGen only works on Bela.\n)\n\n(Note: \nIf you want to modulate the pin number, you should use the UGen DigitalIO\n)",
      "related": [
        "AnalogIn",
        "AnalogOut",
        "DigitalIn",
        "DigitalIO"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "DiskIn": {
      "name": "DiskIn",
      "summary": "Stream in audio from a file.",
      "categories": "UGens>InOut, UGens>Buffer",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "numChannels",
          "default": null,
          "doc": "Number of channels. This must match the number of channels in the buffer. Must be a nonzero, positive integer. This is fixed when the SynthDef is compiled so cannot be assigned to a SynthDef argument."
        },
        {
          "name": "bufnum",
          "default": null,
          "doc": "Buffer number\nNote:: The Buffer's numFrames must be a power of two and is recommended to be at least 65536 -- preferably 131072 or 262144. Smaller buffer sizes mean more frequent disk access, which can cause glitches. ::"
        },
        {
          "name": "loop",
          "default": 0,
          "doc": null
        }
      ],
      "description": "Continuously play a longer soundfile from disk. This requires a buffer to\nbe preloaded with one buffer size of sound.\n\nDiskIn cannot alter playback rate. See VDiskIn for a\ndisk-streaming UGen with rate control.",
      "related": [
        "PlayBuf",
        "VDiskIn",
        "DiskOut"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "DiskOut": {
      "name": "DiskOut",
      "summary": "Record to a soundfile to disk.",
      "categories": "UGens>InOut, UGens>Buffer",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": "The number of the buffer to write to (prepared with /b-write or\nBuffer.write)\nNote:: The Buffer's numFrames must be a power of two and is recommended to be at least 65536 -- preferably 131072 or 262144. Smaller buffer sizes mean more frequent disk access, which can cause glitches. ::"
        },
        {
          "name": "channelsArray",
          "default": null,
          "doc": "The Array of channels to write to the file.\nNote:: The number of channels in the buffer and the channelsArray must be the same, otherwise DiskOut will fail silently (and not write anything to your file). ::"
        }
      ],
      "description": "Record to a soundfile to disk. Uses a Buffer.\n\nSee RecordBuf for recording into a buffer in memory.",
      "related": [
        "RecordBuf",
        "DiskIn",
        "VDiskIn"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Diwhite": {
      "name": "Diwhite",
      "summary": "Demand rate white noise random generator.",
      "categories": "UGens>Demand",
      "rates": [],
      "args": [],
      "description": "Dwhite  returns numbers in the continuous range between\nlo  and  hi .\nDiwhite returns integer values.\n\nThe arguments can be a number or any other UGen.\n\nSee Pwhite, WhiteNoise  for structurally related\nequivalents.",
      "related": [
        "Dwhite",
        "Demand",
        "Duty",
        "TDuty"
      ],
      "parent": "Dwhite",
      "signalRange": null
    },
    "Done": {
      "name": "Done",
      "summary": "Monitors another UGen to see when it is finished",
      "categories": "UGens>Synth control, Server>Nodes",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "src",
          "default": null,
          "doc": "The UGen to monitor"
        }
      ],
      "description": "Some UGens set a 'done' flag when they are finished playing. This UGen echoes that flag when it is set to track a particular UGen.\n\nThe UGens trackable by Done are:\nlist::\n- PlayBuf\n- RecordBuf\n- Line\n- XLine\n- EnvGen\n- Linen\n- BufRd\n- BufWr\n- Dbufrd\n- Dbufwr\n- DiskIn\n- VDiskIn\n- Demand",
      "related": [
        "UGen",
        "FreeSelfWhenDone",
        "PauseSelfWhenDone"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Drand": {
      "name": "Drand",
      "summary": "Demand rate random sequence generator.",
      "categories": "UGens>Demand",
      "rates": [],
      "args": [],
      "description": "Dxrand  never plays the same value twice, whereas Drand\nchooses any value in the list.\n\nSee Prand for structurally related equivalent.",
      "related": [
        "Demand",
        "Dseq",
        "Dser",
        "Duty",
        "Dxrand",
        "TDuty"
      ],
      "parent": "ListDUGen",
      "signalRange": null
    },
    "Dseq": {
      "name": "Dseq",
      "summary": "Demand rate sequence generator.",
      "categories": "UGens>Demand",
      "rates": [],
      "args": [],
      "description": "Demand rate sequence generator.\n\nSee Pseq for structurally related equivalent.",
      "related": [
        "Demand",
        "Drand",
        "Dser",
        "Duty",
        "Dxrand",
        "TDuty"
      ],
      "parent": "ListDUGen",
      "signalRange": null
    },
    "Dser": {
      "name": "Dser",
      "summary": "Demand rate sequence generator.",
      "categories": "UGens>Demand",
      "rates": [],
      "args": [],
      "description": "Demand rate sequence generator.\n\nSee Pser for structurally related equivalent.",
      "related": [
        "Demand",
        "Drand",
        "Dseq",
        "Duty",
        "Dxrand",
        "TDuty"
      ],
      "parent": "ListDUGen",
      "signalRange": null
    },
    "Dshuf": {
      "name": "Dshuf",
      "summary": "Demand rate random sequence generator",
      "categories": "UGens>Demand, UGens>Random",
      "rates": [],
      "args": [],
      "description": null,
      "related": [],
      "parent": "ListDUGen",
      "signalRange": null
    },
    "Dswitch": {
      "name": "Dswitch",
      "summary": "Demand rate generator for embedding different inputs",
      "categories": "UGens>Demand",
      "rates": [],
      "args": [],
      "description": "Demand rate generator for embedding different inputs.\nIn difference to Dswitch1, Dswitch embeds all items of\nan input demand ugen first before looking up the next index.",
      "related": [
        "Demand",
        "Dswitch1"
      ],
      "parent": "Dswitch1",
      "signalRange": null
    },
    "Dust": {
      "name": "Dust",
      "summary": "Random impulses.",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "density",
          "default": 0,
          "doc": "Average number of impulses per second."
        }
      ],
      "description": "Generates random impulses from 0 to +1.",
      "related": [
        "Dust2"
      ],
      "parent": "UGen",
      "signalRange": "unipolar"
    },
    "Dust2": {
      "name": "Dust2",
      "summary": "Random impulses.",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "density",
          "default": 0,
          "doc": "Average number of impulses per second."
        }
      ],
      "description": "Generates random impulses from -1 to +1.",
      "related": [
        "Dust"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Duty": {
      "name": "Duty",
      "summary": "Demand results from demand rate UGens.",
      "categories": "UGens>Demand",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "dur",
          "default": 1,
          "doc": "Time values. Can be a demand UGen or any signal. The next level\nis acquired after duration."
        },
        {
          "name": "reset",
          "default": 0,
          "doc": "Trigger or reset time values. Resets the list of UGens and the\nduration UGen when triggered. The reset input may also be a\ndemand UGen, providing a stream of reset times."
        },
        {
          "name": "level",
          "default": 1,
          "doc": "Demand UGen providing the output values."
        },
        {
          "name": "doneAction",
          "default": 0,
          "doc": "A doneAction that is evaluated when the duration stream ends. See\n\nDone  for more detail.\n\nExamples::\n\n(\n\t{\n\t\tvar freq;\n\t\tfreq = Duty.kr(\n\t\t\t\tDrand([0.01, 0.2, 0.4], inf), // demand ugen as durations\n\t\t\t\t0,\n\t\t\t\tDseq([204, 400, 201, 502, 300, 200], inf)\n\t\t\t);\n\t\tSinOsc.ar(freq * [1, 1.01]) * 0.1\n\n\t}.play;\n)\n\n(\n\t{\n\t\tvar freq;\n\t\tfreq = Duty.kr(\n\t\t\t\tMouseX.kr(0.001, 2, 1), // control rate ugen as durations\n\t\t\t\t0,\n\t\t\t\tDseq([204, 400, 201, 502, 300, 200], inf)\n\t\t\t);\n\t\tSinOsc.ar(freq * [1, 1.01]) * 0.1\n\n\t}.play;\n)\n\nResetting the demand ugens:\n\n(\n\t{\n\t\tvar freq;\n\t\tfreq = Duty.kr(\n\t\t\t\tDseq([0.2, 0.3, 0.4, Dseq([1, 1, 1, 2, 1, 2], inf)]) / 2,\n\t\t\t\tDust.kr(1), // control rate reset\n\t\t\t\tDseq([0, 1, 2, Dseq([1, 2, 3, 4, 5], inf)])\n\t\t\t) * 30 + 250;\n\t\tSinOsc.ar(freq * [1, 1.01]) * 0.1\n\n\t}.play;\n)\n\n(\n\t{\n\t\tvar freq;\n\t\tfreq = Duty.kr(\n\t\t\t\tDseq([0.2, 0.3, 0.4, Dseq([1, 1, 1, 2, 1, 2], inf)]) / 2,\n\t\t\t\tDseq([1, 2, 4, 5], inf), // demand rate reset\n\t\t\t\tDseq([0, 1, 2, Dseq([1, 2, 3, 4, 5], inf)])\n\t\t\t) * 30 + 250;\n\t\tSinOsc.ar(freq * [1, 1.01]) * 0.1\n\n\t}.play;\n)\n\nDemand ugen as audio oscillator:\n\n(\n\t{\n\t\tvar a, n = 5, m = 64;\n\t\ta = {\n\t\t\tvar x;\n\t\t\tx = { 0.2.rand2 } ! m;\n\t\t\tx = x ++ ({  Drand({ 0.2.rand2 } ! n) } ! m.rand);\n\t\t\tDseq(x.scramble, inf)\n\t\t} ! n;\n\t\tDuty.ar(\n\t\t\t\tMouseX.kr(1, 125, 1) * SampleDur.ir * [1, 1.02],\n\t\t\t\t0,\n\t\t\t\tDswitch1(a, MouseY.kr(0, n-1))\n\t\t\t)\n\n\t}.play;\n)\n\nsingle sample feedback: a lin cong algorithm:\n\n(\nb = Buffer.alloc(s, 1);\n{\nvar x, y, rate, a, c, m;\n\trate = MouseX.kr(100, SampleRate.ir);\n\ta = 1.1;\n\tc = 0.13;\n\tm = 1.0;\n\tx = Dbufrd(b); // read from buffer\n\tx = x * a + c % m;\n\ty = Dbufwr(x, b); // write to buffer\n\tDuty.ar(1 / rate, 0, y) * 0.1;\n}.play;\n)"
        }
      ],
      "description": "A value is demanded of each UGen in the list and output according to a\nstream of duration values. The unit generators in the list should be\n'demand' rate.\n\nWhen there is a trigger at the reset input, the demand rate UGens in the\nlist and the duration are reset. The reset input may also be a demand\nUGen, providing a stream of reset times.",
      "related": [
        "Demand",
        "TDuty"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Dxrand": {
      "name": "Dxrand",
      "summary": "Demand rate random sequence generator.",
      "categories": "UGens>Demand",
      "rates": [],
      "args": [],
      "description": "Dxrand never plays the same value twice, whereas Drand chooses\nany value in the list.\n\nSee Pxrand for structurally related equivalent.",
      "related": [
        "Demand",
        "Drand",
        "Dseq",
        "Dser",
        "Duty",
        "TDuty"
      ],
      "parent": "ListDUGen",
      "signalRange": null
    },
    "DynKlang": {
      "name": "DynKlang",
      "summary": "Dynamic sine oscillator bank",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "specificationsArrayRef",
          "default": null,
          "doc": null
        },
        {
          "name": "freqscale",
          "default": 1,
          "doc": null
        },
        {
          "name": "freqoffset",
          "default": 0,
          "doc": null
        }
      ],
      "description": "DynKlang is a bank of sine oscillators. It is less efficient than Klang, as it is basically a wrapper around SinOsc UGens in order to provide a similar interface to Klang.\n\nUnlike Klang, parameters in specificationsArrayRef can be changed after it has been started.",
      "related": [
        "Klang",
        "DynKlank",
        "Klank"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "DynKlank": {
      "name": "DynKlank",
      "summary": "Bank of resonators.",
      "categories": "UGens>Generators>Deterministic, UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "specificationsArrayRef",
          "default": null,
          "doc": "A Ref to an Array of three Arrays: [frequencies, amplitudes, ringtimes]\n\ndefinitionlist::\n- frequencies: || An Array of filter frequencies.\n- amplitudes: || An Array of filter amplitudes, or nil. If nil, then amplitudes default to 1.0.\n- ring times: || An Array of 60 dB decay times for the filters.\n\nAll subarrays, if not nil, should have the same length."
        },
        {
          "name": "input",
          "default": null,
          "doc": "The excitation input to the resonant filter bank."
        },
        {
          "name": "freqscale",
          "default": 1,
          "doc": "A scale factor multiplied by all frequencies at initialization time."
        },
        {
          "name": "freqoffset",
          "default": 0,
          "doc": "An offset added to all frequencies at initialization time."
        },
        {
          "name": "decayscale",
          "default": 1,
          "doc": "A scale factor multiplied by all ring times at initialization time.\n\nExamples::\n\nFour resonators each at maximum amplitude of 1.0 and ring times of 1 second, different exciters and no scaling:\nNote:: Watch the ` before the opening bracket of the parameter array! Also see Guides/Multichannel-Expansion::\n\n{ DynKlank.ar(`[[800, 1071, 1153, 1723], nil, [1, 1, 1, 1]], Impulse.ar(2, 0, 0.1)) }.play;\n\n{ DynKlank.ar(`[[800, 1071, 1353, 1723], nil, [1, 1, 1, 1]], Dust.ar(8, 0.1)) }.play;\n\n{ DynKlank.ar(`[[800, 1071, 1353, 1723], nil, [1, 1, 1, 1]], PinkNoise.ar(0.007)) }.play;\n\n{ DynKlank.ar(`[[200, 671, 1153, 1723], nil, [1, 1, 1, 1]], PinkNoise.ar([0.007, 0.007])) }.play;\n\nChanging parameters in realtime:\n\n(\n// change freqs and ringtimes with mouse\n{\tvar freqs, ringtimes;\n\tfreqs = [800, 1071, 1153, 1723] * MouseX.kr(0.5, 2, 1);\n\tringtimes = [1, 1, 1, 1] * MouseY.kr(0.1, 10, 1);\n\tDynKlank.ar(`[freqs, nil, ringtimes], Impulse.ar(2, 0, 0.1))\n}.play;\n)\n\n(\n// set them from outside later:\nSynthDef('help-dynKlank', { |out|\n\tvar freqs, ringtimes, signal;\n\tfreqs = Control.names([\\freqs]).kr([800, 1071, 1153, 1723]);\n\tringtimes = Control.names([\\ringtimes]).kr([1, 1, 1, 1]);\n\tsignal = DynKlank.ar(`[freqs, nil, ringtimes], Impulse.ar(2, 0, 0.1));\n\tOut.ar(out, signal);\n}).add;\n)\n\na = Synth('help-dynKlank');\n\na.setn(\\freqs, Array.rand(4, 500, 2000));\na.setn(\\ringtimes, Array.rand(4, 0.2, 4));\na.setn(\\ringtimes, Array.rand(4, 0.02, 0.4));\n\n// create multichannel controls directly with literal arrays:\n(\nSynthDef('help-dynKlank', { |out,\n\tfreqs (#[100, 200, 300, 400]),\n\tamps (#[1, 0.3, 0.2, 0.05]),\n\trings (#[1, 1, 1, 2])|\n\n\tOut.ar(out, DynKlank.ar(`[freqs, amps, rings], WhiteNoise.ar * 0.001))\n}).add\n)\n\na = Synth('help-dynKlank');\n\na.setn(\\freqs, Array.rand(4, 500, 2000));\na.setn(\\amps, Array.exprand(4, 0.01, 1));\n\n{ Out.kr(102, MouseX.kr(1, 2) * Array.rand(4, 500, 2000)) }.play;\na.mapn(\\freqs, 102, 4);"
        }
      ],
      "description": "DynKlank is a bank of frequency resonators which can be used to simulate\nthe resonant modes of an object. Each mode is given a ring time, which is\nthe time for the mode to decay by 60 dB.\n\nUnlike  Klank, all parameters in DynKlank can be changed in real-time after it has been started.\n\nNote::\nThe amplitude of the resulting signal depends on the server's sample rate. See link::Classes/Ringz#Interaction with sample rate#Ringz: Interaction with sample rate:: for details.",
      "related": [
        "Klang",
        "DynKlang",
        "Klank"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "EnvGen": {
      "name": "EnvGen",
      "summary": "Envelope generator",
      "categories": "UGens>Envelopes",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "envelope",
          "default": null,
          "doc": "An Env instance, or an Array of Controls.\n(See Control  and the example below for how to use\nthis.)\n\nThe envelope is polled when the EnvGen is triggered, and at the start of a new envelope segment. The Env inputs can be other UGens."
        },
        {
          "name": "gate",
          "default": 1,
          "doc": "This triggers the envelope and holds it open while > 0. If the\nEnv is fixed-length (e.g. Env.linen, Env.perc), the gate argument\nis used as a simple trigger. If it is an sustaining envelope\n(e.g. Env.adsr, Env.asr), the envelope is held open until the\ngate becomes 0, at which point is released.\n\nIf gate < 0, force release with time  -1.0 - gate . See #Forced release below."
        },
        {
          "name": "levelScale",
          "default": 1,
          "doc": "The levels of the breakpoints are multiplied by this value. This\nvalue can be modulated, but is only sampled at the start of a new\nenvelope segment."
        },
        {
          "name": "levelBias",
          "default": 0,
          "doc": "This value is added as an offset to the levels of the breakpoints.\nThis value can be modulated, but is only sampled at the start of a\nnew envelope segment."
        },
        {
          "name": "timeScale",
          "default": 1,
          "doc": "The durations of the segments are multiplied by this value. This\nvalue can be modulated, but is only sampled at the start of a new\nenvelope segment."
        },
        {
          "name": "doneAction",
          "default": 0,
          "doc": "An integer representing an action to be executed when the env is\nfinished playing. This can be used to free the enclosing synth,\netc. See Done  for more detail."
        }
      ],
      "description": "Plays back break point envelopes. The envelopes are instances of the\nEnv class. The envelope and the arguments for  levelScale,\nlevelBias, and  timeScale are polled when the EnvGen is\ntriggered, and at the start of a new envelope segment. All values remain constant\nfor the duration of each segment.\n\n{ PinkNoise.ar(EnvGen.kr(Env.perc, doneAction: Done.freeSelf)) }.play",
      "related": [
        "Linen",
        "Env"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "FBSineC": {
      "name": "FBSineC",
      "summary": "Feedback sine with chaotic phase indexing",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "im",
          "default": 1,
          "doc": null
        },
        {
          "name": "fb",
          "default": 0.1,
          "doc": null
        },
        {
          "name": "a",
          "default": 1.1,
          "doc": null
        },
        {
          "name": "c",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "xi",
          "default": 0.1,
          "doc": null
        },
        {
          "name": "yi",
          "default": 0.1,
          "doc": null
        }
      ],
      "description": "A cubic-interpolating sound generator based on the difference equations:\n\nteletype::\n\tx(n+1) = sin(im * y(n) + fb * x(n))\n\ty(n+1) = (a * y(n) + c) % 2pi\n\nThis uses a linear congruential function to drive the phase indexing of a sine wave. For  im = 1 ,  fb = 0 , and  a = 1  a normal sinewave results.\n\nsclang code translation:\n\n(\nvar im = 1, fb = 0.1, a = 1.1, c = 0.5, xi = 0.1, yi = 0.1, size = 64;\nplot(size.collect { xi = sin((im * yi) + (fb * xi)); yi = (a * yi + c) % 2pi; xi });\n)",
      "related": [
        "FBSineN",
        "FBSineL"
      ],
      "parent": "FBSineN",
      "signalRange": null,
      "inheritedFrom": "FBSineN"
    },
    "FBSineL": {
      "name": "FBSineL",
      "summary": "Feedback sine with chaotic phase indexing",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "im",
          "default": 1,
          "doc": null
        },
        {
          "name": "fb",
          "default": 0.1,
          "doc": null
        },
        {
          "name": "a",
          "default": 1.1,
          "doc": null
        },
        {
          "name": "c",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "xi",
          "default": 0.1,
          "doc": null
        },
        {
          "name": "yi",
          "default": 0.1,
          "doc": null
        }
      ],
      "description": "A linear-interpolating sound generator based on the difference equations:\n\nteletype::\n        x(n+1) = sin(im * y(n) + fb * x(n))\n        y(n+1) = (a * y(n) + c) % 2pi\n\nThis uses a linear congruential function to drive the phase indexing of a sine wave. For  im = 1 ,  fb = 0 , and  a = 1  a normal sinewave results.\n\nsclang code translation:\n\n(\nvar im = 1, fb = 0.1, a = 1.1, c = 0.5, xi = 0.1, yi = 0.1, size = 64;\nplot(size.collect { xi = sin((im * yi) + (fb * xi)); yi = (a * yi + c) % 2pi; xi });\n)",
      "related": [
        "FBSineC",
        "FBSineN"
      ],
      "parent": "FBSineN",
      "signalRange": null,
      "inheritedFrom": "FBSineN"
    },
    "FBSineN": {
      "name": "FBSineN",
      "summary": "Feedback sine with chaotic phase indexing",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "im",
          "default": 1,
          "doc": null
        },
        {
          "name": "fb",
          "default": 0.1,
          "doc": null
        },
        {
          "name": "a",
          "default": 1.1,
          "doc": null
        },
        {
          "name": "c",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "xi",
          "default": 0.1,
          "doc": null
        },
        {
          "name": "yi",
          "default": 0.1,
          "doc": null
        }
      ],
      "description": "A non-interpolating sound generator based on the difference equations:\n\nteletype::\n        x(n+1) = sin(im * y(n) + fb * x(n))\n        y(n+1) = (a * y(n) + c) % 2pi\n\nThis uses a linear congruential function to drive the phase indexing of a sine wave. For  im = 1 ,  fb = 0 , and  a = 1  a normal sinewave results.\n\nsclang code translation:\n\n(\nvar im = 1, fb = 0.1, a = 1.1, c = 0.5, xi = 0.1, yi = 0.1, size = 64;\nplot(size.collect { xi = sin((im * yi) + (fb * xi)); yi = (a * yi + c) % 2pi; xi });\n)",
      "related": [
        "FBSineL",
        "FBSineC"
      ],
      "parent": "ChaosGen",
      "signalRange": null
    },
    "FOS": {
      "name": "FOS",
      "summary": "First order filter section.",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "Signal input."
        },
        {
          "name": "a0",
          "default": 0,
          "doc": "See formula above."
        },
        {
          "name": "a1",
          "default": 0,
          "doc": "See formula above."
        },
        {
          "name": "b1",
          "default": 0,
          "doc": "See formula above."
        }
      ],
      "description": "A standard first order filter section. Filter coefficients are given\ndirectly rather than calculated for you. Formula is equivalent to:\n\nout(i) = (a0 * in(i)) + (a1 * in(i-1)) + (b1 * out(i-1))",
      "related": [
        "SOS"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "FSinOsc": {
      "name": "FSinOsc",
      "summary": "Fast sine oscillator.",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 440,
          "doc": "Frequency in Hertz.\n(Note:  While an audio-rate frequency input is accepted, frequency is\nis currently only updated internally at only control-rate.)"
        },
        {
          "name": "iphase",
          "default": 0,
          "doc": "Initial phase offset."
        }
      ],
      "description": "Very fast sine wave generator (2 PowerPC instructions per output sample!)\nimplemented using a ringing filter. This generates a much cleaner sine\nwave than a table lookup oscillator and is a lot faster. However, the\namplitude of the wave will vary with frequency. Generally the amplitude\nwill go down as you raise the frequency and go up as you lower the frequency.\n\n(Warning: \nIn the current implementation, the amplitude can blow up if the\nfrequency is modulated by certain alternating signals.\n)",
      "related": [
        "SinOsc",
        "SinOscFB"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Fold": {
      "name": "Fold",
      "summary": "Fold a signal outside given thresholds.",
      "categories": "UGens>Maths",
      "rates": [
        "ar",
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "Signal to be folded."
        },
        {
          "name": "lo",
          "default": 0,
          "doc": "Low threshold of folding. Sample values < lo will be folded. must be less then hi."
        },
        {
          "name": "hi",
          "default": 1,
          "doc": "High threshold of folding. Sample values > hi will be folded. must be greater then lo.\n\nExamples::\n\ns.boot;\n\n{ Fold.ar(SinOsc.ar(440, 0, 0.2), -0.1, 0.1) }.scope;"
        }
      ],
      "description": "This differs from the  BinaryOpUGen  Overviews/Methods#fold2#fold2 in that it\nallows one to set low and high thresholds.",
      "related": [
        "Clip",
        "Wrap"
      ],
      "parent": "InRange",
      "signalRange": null,
      "inheritedFrom": "InRange"
    },
    "FoldIndex": {
      "name": "FoldIndex",
      "summary": "Index into a table with a signal.",
      "categories": "UGens>Buffer",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": "Index of the buffer."
        },
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        }
      ],
      "description": "The input signal value is truncated to an integer value and used as an\nindex into the table. Out-of-range index values are folded into\nthe valid range.",
      "related": [
        "Index",
        "Shaper"
      ],
      "parent": "Index",
      "signalRange": null,
      "inheritedFrom": "Index"
    },
    "Formant": {
      "name": "Formant",
      "summary": "Formant oscillator",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "fundfreq",
          "default": 440,
          "doc": "Fundamental frequency in Hertz. (control rate)"
        },
        {
          "name": "formfreq",
          "default": 1760,
          "doc": "Formant frequency in Hertz. (control rate)"
        },
        {
          "name": "bwfreq",
          "default": 880,
          "doc": "Pulse width frequency in Hertz. Controls the bandwidth of the\nformant. (control rate)\n\nMust be greater than or equal to fundfreq."
        }
      ],
      "description": "Generates a set of harmonics around a formant frequency at a given\nfundamental frequency.",
      "related": [],
      "parent": "PureUGen",
      "signalRange": null
    },
    "Formlet": {
      "name": "Formlet",
      "summary": "FOF-like filter.",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "freq",
          "default": 440,
          "doc": "Resonant frequency in Hertz."
        },
        {
          "name": "attacktime",
          "default": 1,
          "doc": "60 dB attack time in seconds."
        },
        {
          "name": "decaytime",
          "default": 1,
          "doc": "60 dB decay time in seconds."
        }
      ],
      "description": "This is a resonant filter whose impulse response is like that of a sine\nwave with a  Decay2  envelope over it. It is possible to\ncontrol the attacktime and decaytime.\n\nFormlet is equivalent to:\n\nRingz(in, freq, decaytime) - Ringz(in, freq, attacktime)\n\nThe great advantage to this filter over FOF is that there is no limit to\nthe number of overlapping grains since the grain is just the impulse\nresponse of the filter.\n\nNote::\nThe amplitude of the resulting signal depends on the server's sample rate. See link::Classes/Ringz#Interaction with sample rate#Ringz: Interaction with sample rate:: for details.",
      "related": [
        "RHPF",
        "RLPF",
        "Resonz",
        "Ringz"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "Free": {
      "name": "Free",
      "summary": "When triggered, frees a node.",
      "categories": "UGens>Synth control",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "trig",
          "default": null,
          "doc": "Trigger input"
        },
        {
          "name": "id",
          "default": null,
          "doc": "Node to be freed.\n\nExamples::\n\ns.boot;\n\nSynthDef(\"a\", { Out.ar(0, SinOsc.ar(800, 0, 0.2)) }).add;\n\nSynthDef(\"b\", { |t_t = 0| Out.ar(1, PinkNoise.ar(0.3)); Free.kr(t_t, 1001) }).add;\n\ns.sendMsg(\\s_new, \\a, 1001, 0, 0);\n\ns.sendMsg(\\s_new, \\b, 1002, 0, 0);\n\ns.sendMsg(\\n_set, 1002, \\t_t, 1);\n\ns.sendMsg(\\s_new, \\a, 1001, 0, 0);\n\ns.sendMsg(\\n_set, 1002, \\t_t, 1);\n\ns.sendMsg(\\s_new, \\a, 1001, 0, 0);\n\ns.sendMsg(\\n_set, 1002, \\t_t, 1);"
        }
      ],
      "description": "When triggered, frees a node.",
      "related": [
        "Pause",
        "FreeSelf"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "FreeSelf": {
      "name": "FreeSelf",
      "summary": "When triggered, free enclosing synth.",
      "categories": "UGens>Synth control",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "The input signal.\n\nExamples::\n\n(\nSynthDef(\"freeSelf-help\", { |out, t_trig|\n\tFreeSelf.kr(t_trig);\n\tOut.ar(out, SinOsc.ar(400, 0, 0.2));\n}).add;\n)\n\ns.sendMsg(\"/s_new\", \"freeSelf-help\", 1731);\ns.sendMsg(\"/n_set\", 1731, \\t_trig, 1);\n\n// a single impulse SynthDef:\n\n(\nSynthDef(\"dirac\", { |out, amp = 0.1|\n\tvar u;\n\tu = Impulse.ar(1);\n\tFreeSelf.kr(u);\n\tOut.ar(out, u * amp);\n\t\t// multiply by amp after using for release, so amp = 0\n\t\t// doesn't cause synth buildup.\n}).add;\n)\n\n(\nTask {\n\tloop({\n\t\tfork {\n\t\t\texprand(34, 156).do { |i|\n\t\t\t\ti = i + 1;\n\t\t\t\ts.sendMsg(\"/s_new\", \"dirac\", -1, 0, 0, \\amp, 1 / i);\n\t\t\t\t(0.006 * i).wait;\n\t\t\t};\n\t\t};\n\t\t1.wait;\n\t})\n} .play;\n)"
        }
      ],
      "description": "Free enclosing synth when input signal crosses from non-positive to\npositive.",
      "related": [
        "PauseSelf",
        "Free"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "FreeSelfWhenDone": {
      "name": "FreeSelfWhenDone",
      "summary": "Free the enclosing synth when a UGen is finished",
      "categories": "UGens>Synth control",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "src",
          "default": null,
          "doc": "the UGen to check for done."
        }
      ],
      "description": "Some UGens set a 'done' flag when they are finished playing.\nFreeSelfWhenDone will free the enclosing synth when this flag is set to true.\n\nSee Done for a complete list of these UGens.\n\nNote that many of these UGens have doneActions, which are another way of accomplishing the same thing. See Done for more detail.\n\n(Note:  One must be careful when using binary operations on UGens with done flags, as these will return a BinaryOpUGen, and thus prevent the done flag from being accessible. See example below. )",
      "related": [
        "Done",
        "PauseSelfWhenDone",
        "Done"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "FreeVerb": {
      "name": "FreeVerb",
      "summary": "A reverb",
      "categories": "UGens>Reverbs",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": null
        },
        {
          "name": "mix",
          "default": 0.33,
          "doc": null
        },
        {
          "name": "room",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "damp",
          "default": 0.5,
          "doc": null
        }
      ],
      "description": "Coded from experiments with faust.",
      "related": [
        "FreeVerb2",
        "GVerb"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "FreeVerb2": {
      "name": "FreeVerb2",
      "summary": "A two-channel reverb",
      "categories": "UGens>Reverbs",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": null
        },
        {
          "name": "in2",
          "default": null,
          "doc": null
        },
        {
          "name": "mix",
          "default": 0.33,
          "doc": null
        },
        {
          "name": "room",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "damp",
          "default": 0.5,
          "doc": null
        }
      ],
      "description": "Coded from experiments with faust.",
      "related": [
        "FreeVerb",
        "GVerb"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "FreqShift": {
      "name": "FreqShift",
      "summary": "Frequency Shifter.",
      "categories": "UGens>Filters>Nonlinear, UGens>Filters>Pitch",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "The input signal."
        },
        {
          "name": "// input signal\n\t\tfreq",
          "default": 0,
          "doc": null
        },
        {
          "name": "// shift",
          "default": null,
          "doc": null
        },
        {
          "name": "in cps\n\t\tphase",
          "default": 0,
          "doc": null
        },
        {
          "name": "// phase of SSB\n\t\tmul",
          "default": 1,
          "doc": null
        }
      ],
      "description": "FreqShift implements single sideband amplitude modulation, also known as\nfrequency shifting, but not to be confused with pitch shifting. Frequency\nshifting moves all the components of a signal by a fixed amount but does\nnot preserve the original harmonic relationships.",
      "related": [
        "Hilbert",
        "HilbertFIR"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "GVerb": {
      "name": "GVerb",
      "summary": "A two-channel reverb",
      "categories": "UGens>Reverbs",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": null
        },
        {
          "name": "roomsize",
          "default": 10,
          "doc": null
        },
        {
          "name": "revtime",
          "default": 3,
          "doc": null
        },
        {
          "name": "damping",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "inputbw",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "spread",
          "default": 15,
          "doc": null
        },
        {
          "name": "drylevel",
          "default": 1,
          "doc": null
        },
        {
          "name": "earlyreflevel",
          "default": 0.7,
          "doc": null
        },
        {
          "name": "taillevel",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "maxroomsize",
          "default": 300,
          "doc": null
        }
      ],
      "description": "A two-channel reverb UGen, based on the \"GVerb\" LADSPA effect by Juhana Sadeharju (kouhia at nic.funet.fi).",
      "related": [
        "FreeVerb",
        "FreeVerb2"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "Gate": {
      "name": "Gate",
      "summary": "Gate or hold.",
      "categories": "UGens>Triggers",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "trig",
          "default": 0,
          "doc": "Gate - can be any signal. The output is held fixed when this is non-positive.\n\nExamples::\n\ns.boot;\n// Control rate so as not to whack your speakers with DC\n{ Gate.kr(WhiteNoise.kr(1, 0), LFPulse.kr(1.333, 0.5)) }.scope(zoom: 20);"
        }
      ],
      "description": "Allows input signal value to pass when gate is positive, otherwise holds last value.",
      "related": [
        "Latch"
      ],
      "parent": "Latch",
      "signalRange": null,
      "inheritedFrom": "Latch"
    },
    "GbmanL": {
      "name": "GbmanL",
      "summary": "Gingerbreadman map chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "xi",
          "default": 1.2,
          "doc": null
        },
        {
          "name": "yi",
          "default": 2.1,
          "doc": null
        }
      ],
      "description": "A linear-interpolating sound generator based on the difference equations:\n\nteletype::\n\tx(n+1) = 1 - y(n) + |x(n)|\n\ty(n+1) = x(n)\n\nThe behavior of the system is dependent only on its initial conditions and cannot be changed once it's started.\n\nsclang code translation:\n\n(\nvar xi = 1.2, yi = 2.1, size = 64;\nplot(size.collect { var x; xi = 1 - yi + abs(x = xi); yi = x; xi });\n)\n\nReference: Devaney, R. L. \"The Gingerbreadman.\" Algorithm 3, 15-16, Jan. 1992.",
      "related": [
        "GbmanN"
      ],
      "parent": "GbmanN",
      "signalRange": null,
      "inheritedFrom": "GbmanN"
    },
    "GbmanN": {
      "name": "GbmanN",
      "summary": "Gingerbreadman map chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "xi",
          "default": 1.2,
          "doc": null
        },
        {
          "name": "yi",
          "default": 2.1,
          "doc": null
        }
      ],
      "description": "A non-interpolating sound generator based on the difference equations:\n\nteletype::\n        x(n+1) = 1 - y(n) + |x(n)|\n        y(n+1) = x(n)\n\nThe behavior of the system is only dependent on its initial conditions.\n\nsclang code translation:\n\n(\nvar xi = 1.2, yi = 2.1, size = 64;\nplot(size.collect { var x; xi = 1 - yi + abs(x = xi); yi = x; xi });\n)\n\nReference:  Devaney, R. L. \"The Gingerbreadman.\" Algorithm 3, 15-16, Jan. 1992.",
      "related": [
        "GbmanL"
      ],
      "parent": "ChaosGen",
      "signalRange": null
    },
    "Gendy1": {
      "name": "Gendy1",
      "summary": "Dynamic stochastic synthesis generator.",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "ampdist",
          "default": 1,
          "doc": "Choice of probability distribution for the next perturbation of\nthe amplitude of a control point.\n\nThe distributions are (adapted from the GENDYN program in Formalized Music):\n\ntable::\n- 0: || LINEAR.\n- 1: || CAUCHY.\n- 2: || LOGIST.\n- 3: || HYPERBCOS.\n- 4: || ARCSINE.\n- 5: || EXPON.\n- 6: || SINUS.\n\nWhere the sinus (Xenakis' name) is in this implementation taken\nas sampling from a third party oscillator. See example below."
        },
        {
          "name": "durdist",
          "default": 1,
          "doc": "Choice of distribution for the perturbation of the current inter\ncontrol point duration."
        },
        {
          "name": "adparam",
          "default": 1,
          "doc": "A parameter for the shape of the amplitude probability\ndistribution, requires values in the range 0.0001 to 1 (there are\nsafety checks in the code so don't worry too much if you want to\nmodulate!)."
        },
        {
          "name": "ddparam",
          "default": 1,
          "doc": "A parameter for the shape of the duration probability\ndistribution, requires values in the range 0.0001 to 1."
        },
        {
          "name": "minfreq",
          "default": 440,
          "doc": "Minimum allowed frequency of oscillation for the Gendy1\noscillator, so gives the largest period the duration is allowed\nto take on."
        },
        {
          "name": "maxfreq",
          "default": 660,
          "doc": "Maximum allowed frequency of oscillation for the Gendy1\noscillator, so gives the smallest period the duration is allowed\nto take on."
        },
        {
          "name": "ampscale",
          "default": 0.5,
          "doc": "Normally 0.0 to 1.0, multiplier for the distribution's delta\nvalue for amplitude. An ampscale of 1.0 allows the full range\nof  -1 to 1 for a change of amplitude."
        },
        {
          "name": "durscale",
          "default": 0.5,
          "doc": "Normally 0.0 to 1.0, multiplier for the distribution's delta\nvalue for duration. An ampscale of 1.0 allows the full range of\n-1 to 1 for a change of duration."
        },
        {
          "name": "initCPs",
          "default": 12,
          "doc": "Initialise the number of control points in the memory.\nXenakis specifies 12. There would be this number of control\npoints per cycle of the oscillator, though the oscillator's\nperiod will constantly change due to the duration distribution."
        },
        {
          "name": "knum",
          "default": null,
          "doc": "Current number of utilised control points, allows modulation."
        }
      ],
      "description": "An implementation of the dynamic stochastic synthesis generator conceived\nby Iannis Xenakis and described in  Formalized Music (1992, Stuyvesant, NY: Pendragon Press) chapter 9 (pp 246-254) and chapters 13 and 14 (pp 289-322).\n\nThe BASIC program in the book was written by Marie-Helene Serra so I\nthink it helpful to credit her too.\n\nThe program code has been adapted to avoid infinities in the probability\ndistribution functions.\n\nThe distributions are hard-coded in C but there is an option to have new\namplitude or time breakpoints sampled from a continuous controller input.",
      "related": [
        "Gendy2",
        "Gendy3"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Gendy2": {
      "name": "Gendy2",
      "summary": "Dynamic stochastic synthesis generator.",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "ampdist",
          "default": 1,
          "doc": "Choice of probability distribution for the next perturbation of\nthe amplitude of a control point.\n\nThe distributions are (adapted from the GENDYN program in Formalized Music):\ntable::\n- 0: || LINEAR.\n- 1: || CAUCHY.\n- 2: || LOGIST.\n- 3: || HYPERBCOS.\n- 4: || ARCSINE.\n- 5: || EXPON.\n- 6: || SINUS.\n\nWhere the sinus (Xenakis' name) is in this implementation taken\nas sampling from a third party oscillator. See example below."
        },
        {
          "name": "durdist",
          "default": 1,
          "doc": "Choice of distribution for the perturbation of the current inter\ncontrol point duration."
        },
        {
          "name": "adparam",
          "default": 1,
          "doc": "A parameter for the shape of the amplitude probability\ndistribution, requires values in the range 0.0001 to 1 (there are\nsafety checks in the code so don't worry too much if you want to\nmodulate!)."
        },
        {
          "name": "ddparam",
          "default": 1,
          "doc": "A parameter for the shape of the duration probability\ndistribution, requires values in the range 0.0001 to 1."
        },
        {
          "name": "minfreq",
          "default": 440,
          "doc": "Minimum allowed frequency of oscillation for the Gendy1\noscillator, so gives the largest period the duration is allowed\nto take on."
        },
        {
          "name": "maxfreq",
          "default": 660,
          "doc": "Maximum allowed frequency of oscillation for the Gendy1\noscillator, so gives the smallest period the duration is allowed\nto take on."
        },
        {
          "name": "ampscale",
          "default": 0.5,
          "doc": "Normally 0.0 to 1.0, multiplier for the distribution's delta\nvalue for amplitude. An ampscale of 1.0 allows the full range\nof  -1 to 1 for a change of amplitude."
        },
        {
          "name": "durscale",
          "default": 0.5,
          "doc": "Normally 0.0 to 1.0, multiplier for the distribution's delta\nvalue for duration. An ampscale of 1.0 allows the full range of\n-1 to 1 for a change of duration."
        },
        {
          "name": "initCPs",
          "default": 12,
          "doc": "Initialise the number of control points in the memory.\nXenakis specifies 12. There would be this number of control\npoints per cycle of the oscillator, though the oscillator's\nperiod will constantly change due to the duration distribution."
        },
        {
          "name": "knum",
          "default": null,
          "doc": "Current number of utilised control points, allows modulation."
        },
        {
          "name": "a",
          "default": 1.17,
          "doc": "Parameter for Lehmer random number generator perturbed by\nXenakis as in\n\n((old*a)+c)%1.0"
        },
        {
          "name": "c",
          "default": 0.31,
          "doc": "Parameter for Lehmer random number generator perturbed by\nXenakis."
        }
      ],
      "description": "See  Gendy1  help file for background. This variant of\nGENDYN is closer to that presented in Hoffmann, Peter. (2000) The New GENDYN Program. Computer Music Journal 24:2, pp 31-38.\n\n(Note: \nRandom walk is of the amplitude and time delta, not the amp and time\ndirectly. The amplitude step random walk uses a Lehmer style number\ngenerator whose parameters are accessible.\n)\n\nSuperCollider implementation by Nick Collins",
      "related": [
        "Gendy1",
        "Gendy3"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Gendy3": {
      "name": "Gendy3",
      "summary": "Dynamic stochastic synthesis generator.",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "ampdist",
          "default": 1,
          "doc": "Choice of probability distribution for the next perturbation of\nthe amplitude of a control point.\n\nThe distributions are (adapted from the GENDYN program in Formalized Music):\n\ntable::\n- 0: || LINEAR.\n- 1: || CAUCHY.\n- 2: || LOGIST.\n- 3: || HYPERBCOS.\n- 4: || ARCSINE.\n- 5: || EXPON.\n- 6: || SINUS.\n\nWhere the sinus (Xenakis' name) is in this implementation taken\nas sampling from a third party oscillator. See example below."
        },
        {
          "name": "durdist",
          "default": 1,
          "doc": "Choice of distribution for the perturbation of the current inter\ncontrol point duration."
        },
        {
          "name": "adparam",
          "default": 1,
          "doc": "A parameter for the shape of the amplitude probability\ndistribution, requires values in the range 0.0001 to 1 (there are\nsafety checks in the code so don't worry too much if you want to\nmodulate!)."
        },
        {
          "name": "ddparam",
          "default": 1,
          "doc": "A parameter for the shape of the duration probability\ndistribution, requires values in the range 0.0001 to 1."
        },
        {
          "name": "freq",
          "default": 440,
          "doc": "Oscillation frequency."
        },
        {
          "name": "ampscale",
          "default": 0.5,
          "doc": "Normally 0.0 to 1.0, multiplier for the distribution's delta\nvalue for amplitude. An ampscale of 1.0 allows the full range\nof  -1 to 1 for a change of amplitude."
        },
        {
          "name": "durscale",
          "default": 0.5,
          "doc": "Normally 0.0 to 1.0, multiplier for the distribution's delta\nvalue for duration. An ampscale of 1.0 allows the full range of\n-1 to 1 for a change of duration."
        },
        {
          "name": "initCPs",
          "default": 12,
          "doc": "Initialise the number of control points in the memory.\nXenakis specifies 12. There would be this number of control\npoints per cycle of the oscillator, though the oscillator's\nperiod will constantly change due to the duration distribution."
        },
        {
          "name": "knum",
          "default": null,
          "doc": "Current number of utilised control points, allows modulation."
        }
      ],
      "description": "See  Gendy1  help file for background. This variant of\nGENDYN normalises the durations in each period to force oscillation at\nthe desired pitch. The breakpoints still get perturbed as in\nGendy1 .\n\nThere is some glitching in the oscillator caused by the stochastic\neffects - control points as they vary cause big local jumps of amplitude.\nPut  ampscale  and  durscale\nlow to minimise the rate of this.\n\nSuperCollider implementation by Nick Collins",
      "related": [
        "Gendy1",
        "Gendy2"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "GrainBuf": {
      "name": "GrainBuf",
      "summary": "Granular synthesis with sound stored in a buffer",
      "categories": "UGens>Buffer, UGens>Generators>Granular",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "numChannels",
          "default": 1,
          "doc": null
        },
        {
          "name": "trigger",
          "default": 0,
          "doc": null
        },
        {
          "name": "dur",
          "default": 1,
          "doc": null
        },
        {
          "name": "sndbuf",
          "default": null,
          "doc": null
        },
        {
          "name": "rate",
          "default": 1,
          "doc": null
        },
        {
          "name": "pos",
          "default": 0,
          "doc": null
        },
        {
          "name": "interp",
          "default": 2,
          "doc": null
        },
        {
          "name": "pan",
          "default": 0,
          "doc": null
        },
        {
          "name": "envbufnum",
          "default": -1,
          "doc": null
        },
        {
          "name": "maxGrains",
          "default": 512,
          "doc": null
        }
      ],
      "description": null,
      "related": [
        "GrainIn",
        "GrainFM",
        "GrainSin",
        "TGrains"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "GrainFM": {
      "name": "GrainFM",
      "summary": "Granular synthesis with frequency modulated sine tones",
      "categories": "UGens>Generators>Granular",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "numChannels",
          "default": 1,
          "doc": null
        },
        {
          "name": "trigger",
          "default": 0,
          "doc": null
        },
        {
          "name": "dur",
          "default": 1,
          "doc": null
        },
        {
          "name": "carfreq",
          "default": 440,
          "doc": null
        },
        {
          "name": "modfreq",
          "default": 200,
          "doc": null
        },
        {
          "name": "index",
          "default": 1,
          "doc": null
        },
        {
          "name": "pan",
          "default": 0,
          "doc": null
        },
        {
          "name": "envbufnum",
          "default": -1,
          "doc": null
        },
        {
          "name": "maxGrains",
          "default": 512,
          "doc": null
        }
      ],
      "description": null,
      "related": [
        "GrainIn",
        "GrainSin",
        "GrainBuf"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "GrainIn": {
      "name": "GrainIn",
      "summary": "Granulate an input signal",
      "categories": "UGens>Generators>Granular",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "numChannels",
          "default": 1,
          "doc": null
        },
        {
          "name": "trigger",
          "default": 0,
          "doc": null
        },
        {
          "name": "dur",
          "default": 1,
          "doc": null
        },
        {
          "name": "in",
          "default": null,
          "doc": null
        },
        {
          "name": "pan",
          "default": 0,
          "doc": null
        },
        {
          "name": "envbufnum",
          "default": -1,
          "doc": null
        },
        {
          "name": "maxGrains",
          "default": 512,
          "doc": null
        }
      ],
      "description": null,
      "related": [
        "GrainSin",
        "GrainFM",
        "GrainBuf"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "GrainSin": {
      "name": "GrainSin",
      "summary": "Granular synthesis with sine tones",
      "categories": "UGens>Generators>Granular",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "numChannels",
          "default": 1,
          "doc": null
        },
        {
          "name": "trigger",
          "default": 0,
          "doc": null
        },
        {
          "name": "dur",
          "default": 1,
          "doc": null
        },
        {
          "name": "freq",
          "default": 440,
          "doc": null
        },
        {
          "name": "pan",
          "default": 0,
          "doc": null
        },
        {
          "name": "envbufnum",
          "default": -1,
          "doc": null
        },
        {
          "name": "maxGrains",
          "default": 512,
          "doc": null
        }
      ],
      "description": null,
      "related": [
        "GrainIn",
        "GrainFM",
        "GrainBuf"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "GrainTap": {
      "name": "GrainTap",
      "summary": null,
      "categories": null,
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "grainDur",
          "default": 0.2,
          "doc": null
        },
        {
          "name": "pchRatio",
          "default": 1,
          "doc": null
        },
        {
          "name": "pchDispersion",
          "default": 0,
          "doc": null
        },
        {
          "name": "timeDispersion",
          "default": 0,
          "doc": null
        },
        {
          "name": "overlap",
          "default": 2,
          "doc": null
        }
      ],
      "description": null,
      "related": [],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "GrayNoise": {
      "name": "GrayNoise",
      "summary": "Bit-flipping Noise",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [],
      "description": "Generates noise which results from flipping random bits in a word.foot(Note: \nGenerated through math)X_{0} = 1;\\;X_{n+1} = X_{n} \\oplus z::,\nwhere math::\\oplus:: is bitwise exclusive or,\nand math::z:: is a 32-bit binary number with exactly one nonzero digit;\nthe position of the nonzero digit is a uniform random variable.\n\nThis type of noise has a high RMS level relative to its peak to peak level.\nThe spectrum is emphasized towards lower frequencies.\n\nGrey/gray noise does not have a standard definition as pink and white noise do.\nWhile GrayNoise generates bit-flipping noise, the term \"grey/gray noise\" may also refer to noise shaped to perceptual equal loudness contours.foot(Note: \nSee link)https://web.archive.org/web/20090427190825/http://www.ptpart.co.uk:80/show.php?contentid=71##Joseph Wisniewski's 1996 usenet message:: that seems to have informed the wikipedia articles on link::https://en.wikipedia.org/wiki/Grey_noise##Grey noise:: and on link::https://en.wikipedia.org/wiki/Colors_of_noise##Colors of noise::.\nNotice that the bit-flipping version of gray noise is mentioned in a reply to said usenet message.",
      "related": [
        "BrownNoise",
        "ClipNoise",
        "PinkNoise",
        "WhiteNoise"
      ],
      "parent": "WhiteNoise",
      "signalRange": null
    },
    "HPF": {
      "name": "HPF",
      "summary": "2nd order Butterworth highpass filter.",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "freq",
          "default": 440,
          "doc": "Cutoff frequency in Hertz.\nWARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!"
        }
      ],
      "description": "A second order high pass filter.",
      "related": [
        "BPF",
        "BRF",
        "LPF"
      ],
      "parent": "LPF",
      "signalRange": null,
      "inheritedFrom": "LPF"
    },
    "HPZ1": {
      "name": "HPZ1",
      "summary": "Two point difference filter",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        }
      ],
      "description": "A special case fixed filter. Implements the formula:\n\nout(i) = 0.5 * (in(i) - in(i-1))\n\nWhich is a two point differentiator.",
      "related": [
        "LPZ1",
        "HPZ2"
      ],
      "parent": "LPZ1",
      "signalRange": null,
      "inheritedFrom": "LPZ1"
    },
    "HPZ2": {
      "name": "HPZ2",
      "summary": "Two zero fixed midcut.",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        }
      ],
      "description": "A special case fixed filter. Implements the formula:\n\nout(i) = 0.25 * (in(i) - (2 * in(i - 1)) + in(i - 2)).",
      "related": [
        "BPZ2",
        "BRZ2",
        "LPZ2",
        "HPZ1"
      ],
      "parent": "LPZ2",
      "signalRange": null,
      "inheritedFrom": "LPZ2"
    },
    "Hasher": {
      "name": "Hasher",
      "summary": "Scrambled value with a hash function.",
      "categories": "UGens>Filters>Nonlinear, UGens>Random",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        }
      ],
      "description": "Returns a unique output value from -1 to +1 for each input value\naccording to a hash function. The same input value will always produce\nthe same output value. The input need not be in the range -1 to +1.",
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "HenonC": {
      "name": "HenonC",
      "summary": "Henon map chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "a",
          "default": 1.4,
          "doc": null
        },
        {
          "name": "b",
          "default": 0.3,
          "doc": null
        },
        {
          "name": "x0",
          "default": 0,
          "doc": null
        },
        {
          "name": "x1",
          "default": 0,
          "doc": null
        }
      ],
      "description": "A cubic-interpolating sound generator based on the difference equation:\n\nteletype::\n\tx(n+2) = 1 - a * x(n+1)^2 + b * x(n)\n\nThis equation was discovered by French astronomer Michel Hénon while studying the orbits of stars in globular clusters.\n\nfor more information on chaos theory henon formulas:\n\n\"https://en.wikipedia.org/wiki/Chaos_theory\"\n\n\"https://en.wikipedia.org/wiki/Hénon_map\"\n\nsclang code translation:\n\n(\nvar a = 1.4, b = 0.3, x0 = 0, x1 = 1, size = 64;\nplot(size.collect { var aux = 1 - (a * (x1 ** 2)) + (b * x0); x0 = x1; x1 = aux; aux });\n)",
      "related": [
        "HenonN",
        "HenonL"
      ],
      "parent": "HenonN",
      "signalRange": null,
      "inheritedFrom": "HenonN"
    },
    "HenonL": {
      "name": "HenonL",
      "summary": "Henon map chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "a",
          "default": 1.4,
          "doc": null
        },
        {
          "name": "b",
          "default": 0.3,
          "doc": null
        },
        {
          "name": "x0",
          "default": 0,
          "doc": null
        },
        {
          "name": "x1",
          "default": 0,
          "doc": null
        }
      ],
      "description": "A linear-interpolating sound generator based on the difference equation:\n\nteletype::\n        x(n+2) = 1 - a * x(n+1)^2 + b * x(n)\n\nThis equation was discovered by French astronomer Michel Hénon while studying the orbits of stars in globular clusters.\n\nsclang code translation:\n\n(\nvar a = 1.4, b = 0.3, x0 = 0, x1 = 1, size = 64;\nplot(size.collect { var aux = 1 - (a * (x1 ** 2)) + (b * x0); x0 = x1; x1 = aux; aux });\n)",
      "related": [
        "HenonC",
        "HenonN"
      ],
      "parent": "HenonN",
      "signalRange": null,
      "inheritedFrom": "HenonN"
    },
    "HenonN": {
      "name": "HenonN",
      "summary": "Henon map chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "a",
          "default": 1.4,
          "doc": null
        },
        {
          "name": "b",
          "default": 0.3,
          "doc": null
        },
        {
          "name": "x0",
          "default": 0,
          "doc": null
        },
        {
          "name": "x1",
          "default": 0,
          "doc": null
        }
      ],
      "description": "A non-interpolating sound generator based on the difference equation:\n\nteletype::\n        x(n+2) = 1 - a * x(n+1)^2 + b * x(n)\n\nThis equation was discovered by French astronomer Michel Hénon while studying the orbits of stars in globular clusters.\n\nsclang code translation:\n\n(\nvar a = 1.4, b = 0.3, x0 = 0, x1 = 1, size = 64;\nplot(size.collect { var aux = 1 - (a * (x1 ** 2)) + (b * x0); x0 = x1; x1 = aux; aux });\n)",
      "related": [
        "HenonL",
        "HenonC"
      ],
      "parent": "ChaosGen",
      "signalRange": null
    },
    "Hilbert": {
      "name": "Hilbert",
      "summary": "Applies the Hilbert transform to an input signal.",
      "categories": "UGens>Filters>Nonlinear",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "The input signal to transform."
        }
      ],
      "description": "Returns two channels with the original signal and a copy of that signal that has been shifted in phase by 90 degrees (0.5 pi radians). Hilbert outputs two channels containing the input signal and the transformed signal. Due to the method used, distortion occurs in the upper octave of the frequency spectrum (See HilbertFIR for an FFT implementation that avoids this, but introduces a significant delay).",
      "related": [
        "HilbertFIR",
        "FreqShift"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "HilbertFIR": {
      "name": "HilbertFIR",
      "summary": "Applies the Hilbert transform to an input signal.",
      "categories": "UGens>Filters>Nonlinear",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "The input signal to transform."
        },
        {
          "name": "buffer",
          "default": null,
          "doc": "A Buffer to be used for the inter FFT processing. Best results with a size of 1024 or 2048. 1024 gives an acceptable result (though a little choppy), 2048 is much smoother but creates more delay.\n\ns.boot;\ns.scope;\na = { HilbertFIR.ar(SinOsc.ar(100) * -20.dbamp, LocalBuf(2048)) }.play;\na.release;"
        }
      ],
      "description": "Returns two channels with the original signal and a copy of that signal that has been shifted in phase by 90 degrees (0.5 pi radians). HilbertFIR outputs two channels containing the input signal and the transformed signal. HilbertFIR uses FFTs and a 90 degree phase shift to transform the signal, and results in a delay equal to the size of the buffer used for the FFT divided by the sample rate. The Hilbert UGen has less delay, but distorts in the upper octave of the frequency spectrum.",
      "related": [
        "Hilbert",
        "FreqShift"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "IEnvGen": {
      "name": "IEnvGen",
      "summary": "Envelope generator for polling values from an Env",
      "categories": "UGens>Envelopes",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "envelope",
          "default": null,
          "doc": null
        },
        {
          "name": "index",
          "default": null,
          "doc": null
        }
      ],
      "description": "Envelope generator for polling values from an envelope. IEnvGen plays back break point envelopes from the index point. The envelopes are instances of the Env class.",
      "related": [
        "Env"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "IFFT": {
      "name": "IFFT",
      "summary": "Inverse Fast Fourier Transform",
      "categories": "UGens>FFT",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [],
      "description": "The inverse fast fourier transform converts from frequency content to a\nsignal.\n\nThe fast fourier transform analyzes the frequency content of a signal. The IFFT UGen converts this frequency-domain information back into time-domain audio data. Most often this is used as the end of a process which begins with FFT, followed by frequency-domain processing using PV (phase-vocoder) UGens, followed by IFFT.",
      "related": [
        "FFT"
      ],
      "parent": "WidthFirstUGen",
      "signalRange": null
    },
    "Impulse": {
      "name": "Impulse",
      "summary": "Impulse oscillator.",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 440,
          "doc": "Frequency in Hertz. freq may be negative."
        },
        {
          "name": "phase",
          "default": 0,
          "doc": "Phase offset in cycles (0..1). Staying in this range offers a slight efficiency\nadvantage, though phase offsets outside this range are supported and wrapped\ninternally."
        }
      ],
      "description": "Outputs non-bandlimited single sample impulses.",
      "related": [
        "Blip"
      ],
      "parent": "PureUGen",
      "signalRange": "unipolar"
    },
    "In": {
      "name": "In",
      "summary": "Read a signal from a bus.",
      "categories": "UGens>InOut",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "bus",
          "default": 0,
          "doc": "The index of the bus to read in from."
        },
        {
          "name": "numChannels",
          "default": 1,
          "doc": "The number of channels (i.e. adjacent buses) to read in. You\ncannot modulate this number by assigning it to an argument in a\nSynthDef.\n\nExamples::\n\nread from an audio bus:\n\ns.boot;\n\n(\nSynthDef(\"help-PinkNoise\", { |out = 0|\n\tOut.ar(out, PinkNoise.ar(0.1))\n}).add;\n\nSynthDef(\"help-In\", { |out = 0, in = 0|\n\tvar input;\n\t\tinput = In.ar(in, 1);\n\t\tOut.ar(out, input);\n\n}).add;\n)\n\n// play noise on the right channel\nx = Synth(\"help-PinkNoise\", [\\out, 1]);\n\n// read the input and play it out on the left channel\nSynth.after(x, \"help-In\", [\\out, 0, \\in, 1]);\n\nread from a  control bus:\n\n(\nSynthDef(\"help-InKr\", { |out = 0, in = 0|\n\tOut.ar(out,\n\t\tSinOsc.ar(In.kr(in, 1), 0, 0.1)\n\t)\n}).add;\nSynthDef(\"help-lfo\", { |out = 0|\n\tOut.kr(out, LFNoise1.kr(0.3, 200, 800))\n}).add;\n)\n\nb = Bus.control(s, 1);\nb.set(800);\n\nSynth(\"help-InKr\", [\\in, b.index]);\nb.set(400);\nb.set(300);\nSynth(\"help-lfo\", [\\out, b.index]);\n\nread control data from a synth later in the node order:\n\n(\nSynthDef(\"help-Infreq\", { |bus|\n\tOut.ar(0, FSinOsc.ar(In.kr(bus), 0, 0.5));\n}).add;\n\nSynthDef(\"help-Outfreq\", { |freq = 400, bus|\n\tOut.kr(bus, SinOsc.kr(1, 0, freq/40, freq));\n}).add;\n\nb = Bus.control(s, 1);\n)\n\n// add the first control Synth at the tail of the default server; no audio yet\nx = Synth.tail(s, \"help-Outfreq\", [\\bus, b.index]);\n\n// add the sound producing Synth BEFORE it; It receives x's data from the previous cycle\ny = Synth.before(x, \"help-Infreq\", [\\bus, b.index]);\n\n// add another control Synth before y, at the head of the server\n// It now overwrites x's cycle old data before y receives it\nz = Synth.head(s, \"help-Outfreq\", [\\bus, b.index, \\freq, 800]);\n\n// get another bus\nc = Bus.control(s, 1);\n\n// now y receives x's data even though z is still there\ny.set(\\bus, c.index); x.set(\\bus, c.index);\t// WARNING! gets loud!\n\nx.free; y.free; z.free;"
        }
      ],
      "description": "In.ar and In.kr read signals from audio and control buses, respectively. (See the Tutorials/Getting-Started/11-Busses##Busses chapter of the Tutorials/Getting-Started/00-Getting-Started-With-SC##Getting Started tutorial series for details on buses.)\n\nIn.ar and In.kr behave slightly differently with respect to signals left on the bus in the previous calculation cycle.\n\nIn.ar can access audio signals that were generated in the current calculation cycle by Synth nodes located earlier in the node tree (see Guides/Order-of-execution). It does not read signals left on an audio bus from the previous calculation cycle. If synth A reads from audio bus 0 and synth B writes to audio bus 0, and synth A is earlier than synth B, In.ar in synth A will read 0's (silence). This is to prevent accidental feedback. InFeedback supports audio signal feedback.\n\nIn.kr is for control buses. Control signals may be generated by Synth nodes within the server, or they may be set by the client and expected to hold steady. Therefore, In.kr does not distinguish between \"new\" and \"old\" data: it will always read the current value on the bus, whether it was generated earlier in this calculation cycle, left over from the last one, or set by the client.\n\nNote that using the Bus class to allocate a multichannel bus simply\nreserves a series of adjacent bus indices with the Server object's bus\nallocators. abus.index simply returns the first of those indices.\n\nWhen using a Bus with an In or  Out  UGen there is nothing to\nstop you from reading to or writing from a larger range, or from\nhardcoding to a bus that has been allocated. You are responsible for\nmaking sure that the number of channels match and that there are no\nconflicts. See the Reference/Server-Architecture and Bus helpfiles for more\ninformation on buses and how they are used.\n\nThe hardware input busses begin just after the hardware output busses and\ncan be read from using In.ar (See Reference/Server-Architecture for more\ndetails). The number of hardware input and output busses can vary\ndepending on your Server's options. For a convenient wrapper class which\ndeals with this issue see  SoundIn .",
      "related": [
        "InFeedback",
        "LagIn",
        "SoundIn"
      ],
      "parent": "AbstractIn",
      "signalRange": null
    },
    "InFeedback": {
      "name": "InFeedback",
      "summary": "Read signal from a bus with a current or one cycle old timestamp.",
      "categories": "UGens>InOut",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "bus",
          "default": 0,
          "doc": "The index of the bus to read in from."
        },
        {
          "name": "numChannels",
          "default": 1,
          "doc": "The number of channels (i.e. adjacent buses) to read in. The\ndefault is 1. You cannot modulate this number by assigning it to\nan argument in a SynthDef.\n\nExamples::\naudio feedback modulation:\n\n(\nSynthDef(\"help-InFeedback\", { |out = 0, in = 0|\n\tvar input, sound;\n\t\tinput = InFeedback.ar(in, 1);\n\t\tsound = SinOsc.ar(input * 1300 + 300, 0, 0.4);\n\t\tOut.ar(out, sound);\n\n}).play;\n)\n\nthis shows how a node can read audio from a bus that is being written to by a synth following it:\n\n(\nSynthDef(\"help-InFeedback\", { |out = 0, in = 0|\n\tOut.ar(out,\n\t\tInFeedback.ar(in, 1)\n\t);\n}).add;\nSynthDef(\"help-SinOsc\", { |out = 0, freq = 440|\n\tOut.ar(out, SinOsc.ar(freq, 0, 0.1))\n}).add;\n)\n\nx = Bus.audio(s, 1);\n\n// read from bus n play to bus 0 (silent)\na = Synth(\"help-InFeedback\", [\\in, x.index, \\out, 0]);\n\n// now play a synth after this one, playing to bus x\nb = Synth.after(a, \"help-SinOsc\", [\\out, x.index]);\n\n// add another synth before a which also writes to bus x\n// now you can't hear b, as its data is one cycle old, and is overwritten by c\nc = Synth.before(a, \"help-SinOsc\", [\\out, x.index, \\freq, 800]);\n\n// free c and you can hear b again\nc.free;\nx.free;\n\na.free; b.free;\n\nThe example below implements a resonator. Note that you must subtract the blockSize in order for the tuning to be correct. See LocalIn for an equivalent example.\n\n(\nvar play, imp, initial;\nSynthDef(\"testRes\", {\n\nplay = InFeedback.ar(10, 1); // 10 is feedback channel\nimp = Impulse.ar(1);\n\n// feedback\nOffsetOut.ar(10, DelayC.ar(imp + (play * 0.995), 1,\n\t440.reciprocal - ControlRate.ir.reciprocal)); // subtract block size\n\nOffsetOut.ar(0, play);\n\n}).play(s);\n\n// Compare with this for tuning\n{ SinOsc.ar(440, 0, 0.2) }.play(s, 1);\n)"
        }
      ],
      "description": "When the various output UGens (Out,\nOffsetOut, XOut) write data to a bus,\nthey mix it with any data from the current cycle, but overwrite any data\nfrom the previous cycle. (ReplaceOut  overwrites all\ndata regardless.) Thus depending on node order and what synths are\nwriting to the bus, the data on a given bus may be from the current cycle\nor be one cycle old at the time of reading. In.ar checks the timestamp of\nany data it reads in and zeros any data from the previous cycle (for use\nwithin that node; the data remains on the bus). This is fine for audio\ndata, as it avoids feedback, but for control data it is useful to be able\nto read data from any place in the node order. For this reason In.kr also\nreads data that is older than the current cycle.\n\nIn some cases we might also want to read audio from a node later in the\ncurrent node order. This is the purpose of InFeedback. The delay\nintroduced by this is one block size, which equals about 0.0014 sec at\nthe default block size and sample rate. (See the resonator example below\nto see the implications of this.)\n\nThe variably mixing and overwriting behaviour of the output UGens can\nmake order of execution crucial. (No pun intended.) For example with a\nnode order like the following the InFeedback UGen in Synth 2 will only\nreceive data from Synth 1 (→ = write out; ← = read in):\nlist::\n- Synth1 → busA (this synth overwrites the output of Synth3 before it reaches Synth2)\n- Synth2 (with InFeedback) ← busA\n- Synth3 → busA\n\nIf Synth1 were moved after Synth2 then Synth2's InFeedback would receive\na mix of the output from Synth1 and Synth3. This would also be true if\nSynth2 came after Synth1 and Synth3. In both cases data from Synth1 and\nSynth3 would have the same time stamp (either current or from the\nprevious cycle), so nothing would be overwritten.\n\nBecause of this it is often useful to allocate a separate bus for\nfeedback. With the following arrangement Synth2 will receive data from\nSynth3 regardless of Synth1's position in the node order:\n\nlist::\n- Synth1 → busA\n- Synth2 (with InFeedback) ← busB\n- Synth3 → busB + busA\n\nThe second example below demonstrates this issue.",
      "related": [
        "In",
        "LagIn",
        "LocalIn"
      ],
      "parent": "AbstractIn",
      "signalRange": null
    },
    "InRange": {
      "name": "InRange",
      "summary": "Tests if a signal is within a given range.",
      "categories": "UGens>Maths",
      "rates": [
        "ar",
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": null
        },
        {
          "name": "lo",
          "default": 0,
          "doc": null
        },
        {
          "name": "hi",
          "default": 1,
          "doc": null
        }
      ],
      "description": "If teletype::lo ≤ in ≤ hi::, output 1.0, otherwise output 0.0.",
      "related": [
        "InRect",
        "Schmidt"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "InRect": {
      "name": "InRect",
      "summary": "Test if a point is within a given rectangle.",
      "categories": "UGens>Maths",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "x",
          "default": null,
          "doc": null
        },
        {
          "name": "y",
          "default": null,
          "doc": null
        },
        {
          "name": "rect",
          "default": null,
          "doc": null
        }
      ],
      "description": "A pair of signals x and y are treated as a point (x, y) in 2-D; if they fall within the bounds of the rectangle, then this UGen outputs a one; else it outputs zero.",
      "related": [
        "InRange",
        "Schmidt"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "InTrig": {
      "name": "InTrig",
      "summary": "Generate a trigger anytime a bus is set.",
      "categories": "UGens>InOut, UGens>Triggers",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "bus",
          "default": 0,
          "doc": "The index of the bus to read in from."
        },
        {
          "name": "numChannels",
          "default": 1,
          "doc": "The number of channels (i.e. adjacent buses) to read in. You\ncannot modulate this number by assigning it to an argument in a\nSynthDef.\n\nExamples::\n\ns = Server.local;\nb = Bus.control(s, 1);\n\nSynthDef(\"help-InTrig\", { |out = 0, busnum = 0|\n\tvar inTrig;\n\tinTrig = InTrig.kr(busnum);\n\tOut.ar(out,\n\t\tEnvGen.kr(Env.perc, gate: inTrig, levelScale: inTrig) * SinOsc.ar\n\t)\n}).play(s, [\\out, 0, \\busnum, b.index]);\n\nb.set(1.0);\n\nb.value = 1.0;\n\nb.value = 0.2;\n\nb.value = 0.1;\n\ncompare with In example."
        }
      ],
      "description": "Any time the bus is \"touched\", ie. has its value set (using \"/c_set\"\netc.), a single impulse trigger will be generated. Its amplitude is the\nvalue that the bus was set to.\n\nIf the bus is set Classes/Bus#Synchronous Control Bus Methods#synchronously no trigger will be generated.",
      "related": [],
      "parent": "AbstractIn",
      "signalRange": null
    },
    "Index": {
      "name": "Index",
      "summary": "Index into a table with a signal",
      "categories": "UGens>Buffer",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": "Index of the buffer."
        },
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        }
      ],
      "description": "Index into a table with a signal.\nThe input signal value is truncated to an integer value and used as an\nindex into the table. Out-of-range index values are clipped to the valid\nrange.",
      "related": [
        "WrapIndex",
        "Shaper"
      ],
      "parent": "PureUGen",
      "signalRange": null
    },
    "IndexInBetween": {
      "name": "IndexInBetween",
      "summary": "Finds the (lowest) point in the Buffer at which the input signal lies in-between the two values",
      "categories": "UGens>Buffer",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": null
        },
        {
          "name": "in",
          "default": 0,
          "doc": null
        }
      ],
      "description": "Finds the (lowest) point in the Buffer at which the input signal lies in-between the two values, and returns the index. The fractional part of the index is suitable for linearly interpolating between the buffer slot values.\n\nFor example, if the Buffer contains [3, 21, 25, 26] and the input has the value 22, then the output will be 1.25, because the value 22 is in-between the values stored in indices 1 and 2 and in fact is one-quarter of the way along the interval between them.\n\nIndexInBetween is the complement of IndexL.",
      "related": [
        "Index",
        "IndexL",
        "SequenceableCollection"
      ],
      "parent": "Index",
      "signalRange": null,
      "inheritedFrom": "Index"
    },
    "IndexL": {
      "name": "IndexL",
      "summary": "Index into a table with a signal, linear interpolated",
      "categories": "UGens>Buffer",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": null
        },
        {
          "name": "in",
          "default": 0,
          "doc": null
        }
      ],
      "description": "The input signal value is used as an index into the table, with linear interpolation.\nOut of range index values are clipped to the valid range.",
      "related": [
        "Index",
        "IndexInBetween"
      ],
      "parent": "Index",
      "signalRange": null,
      "inheritedFrom": "Index"
    },
    "InfoUGenBase": {
      "name": "InfoUGenBase",
      "summary": "Base class for info ugens",
      "categories": "UGens>Base",
      "rates": [
        "ir"
      ],
      "args": [],
      "description": null,
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "Integrator": {
      "name": "Integrator",
      "summary": "A leaky integrator.",
      "categories": "UGens>Filters>Linear, UGens>Maths",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "coef",
          "default": 1,
          "doc": "Leak coefficient."
        }
      ],
      "description": "Integrates an input signal with a leak. The formula implemented is:\n\nout(0) = in(0) + (coef * out(-1))",
      "related": [],
      "parent": "Filter",
      "signalRange": null
    },
    "K2A": {
      "name": "K2A",
      "summary": "Control to audio rate converter.",
      "categories": "UGens>Conversion",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal.\n\nExamples::\n\n{ K2A.ar(WhiteNoise.kr(0.3)) }.scope;\n\n// compare:\n(\n{\n\t[\n\t\tK2A.ar(WhiteNoise.kr(0.3)),\n\t\tWhiteNoise.ar(0.3)\n\t]\n}.scope;\n)\n\n(\n{\n\tvar freq, blockSize, sampleRate;\n\tblockSize = s.options.blockSize; // usually 64\n\tsampleRate = s.sampleRate;\n\tfreq = MouseX.kr(0.1, 40, 1) / blockSize * sampleRate;\n\t[\n\t\tK2A.ar(LFNoise0.kr(freq)),\n\t\tLFNoise0.ar(freq)\n\t] * 0.3\n}.scope;\n)"
        }
      ],
      "description": "To be able to play a control rate UGen into an audio rate UGen,\nsometimes the rate must be converted. K2A converts via linear\ninterpolation.",
      "related": [
        "A2K"
      ],
      "parent": "PureUGen",
      "signalRange": null
    },
    "KeyState": {
      "name": "KeyState",
      "summary": "Respond to the state of a key",
      "categories": "UGens>User interaction",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "keycode",
          "default": 0,
          "doc": "The keycode value of the key to check. This corresponds to the\nkeycode values passed into the keyDownActions of SCViews. See the\nexample below."
        },
        {
          "name": "minval",
          "default": 0,
          "doc": "The value to output when the key is not pressed."
        },
        {
          "name": "maxval",
          "default": 1,
          "doc": "The value to output  when the key is pressed."
        },
        {
          "name": "lag",
          "default": 0.2,
          "doc": "A lag factor."
        }
      ],
      "description": "Respond to the state of a key.\n\n(Note: \nNote that this UGen does not prevent normal typing. It therefore may be\nhelpful to select a GUI window rather than an SC document when using\nKeyState, as the latter will be altered by any keystrokes.\n)\n\nWARNING::\nThis UGen will not work for Linux users using Wayland, as the Wayland protocol does not allow a global keyboard or mouse state to be captured.\nThe UGen will return MATH::0.0:: as constant value.\nFor more information see https://github.com/supercollider/supercollider/issues/4544\n\nWARNING::\nMacOS users will need to add the SuperCollider application to the Input Monitoring group in the Privacy & Security preferences to have all keys captured.\nSee https://support.apple.com/en-us/guide/mac-help/mchl4cedafb6/mac",
      "related": [
        "MouseButton",
        "MouseX",
        "MouseY"
      ],
      "parent": "UGen",
      "signalRange": "unipolar"
    },
    "KeyTrack": {
      "name": "KeyTrack",
      "summary": "Key tracker",
      "categories": "UGens>Analysis>Pitch",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "chain",
          "default": null,
          "doc": null
        },
        {
          "name": "keydecay",
          "default": 2,
          "doc": null
        },
        {
          "name": "chromaleak",
          "default": 0.5,
          "doc": null
        }
      ],
      "description": "A (12TET major/minor) key tracker based on a pitch class profile of energy across FFT bins and matching this to templates for major and minor scales in all transpositions. It assumes a 440 Hz concert A reference. Output is 0-11 C major to B major, 12-23 C minor to B minor.",
      "related": [
        "BeatTrack",
        "Loudness",
        "MFCC",
        "Onsets",
        "Pitch"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Klang": {
      "name": "Klang",
      "summary": "Sine oscillator bank",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "specificationsArrayRef",
          "default": null,
          "doc": "A Ref to an Array of three Arrays:\n\ndefinitionlist::\n- frequencies: || An Array of oscillator frequencies.\n- amplitudes: || an Array of oscillator amplitudes, or nil. If nil, then amplitudes default to 1.0.\n- phases: || an Array of initial phases, or nil. If nil, then phases default to 0.0."
        },
        {
          "name": "freqscale",
          "default": 1,
          "doc": "A scale factor multiplied by all frequencies at initialization time."
        },
        {
          "name": "freqoffset",
          "default": 0,
          "doc": "An offset added to all frequencies at initialization time."
        }
      ],
      "description": "Klang is a bank of fixed frequency sine oscillators. Klang is more\nefficient than creating individual oscillators but offers less\nflexibility.",
      "related": [
        "Klank",
        "DynKlang"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Klank": {
      "name": "Klank",
      "summary": "Bank of resonators",
      "categories": "UGens>Generators>Deterministic, UGens>Filters>Linear",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "specificationsArrayRef",
          "default": null,
          "doc": "A Ref to an Array of three Arrays:\n\ndefinitionlist::\n- frequencies: || An Array of filter frequencies.\n- amplitudes: || an Array of filter amplitudes, or nil. If nil, then amplitudes default to 1.0.\n- ring times: || an Array of 60 dB decay times in seconds for the filters.\n\nAll subarrays, if not nil, should have the same length."
        },
        {
          "name": "input",
          "default": null,
          "doc": "The excitation input to the resonant filter bank."
        },
        {
          "name": "freqscale",
          "default": 1,
          "doc": "A scale factor multiplied by all frequencies at initialization time."
        },
        {
          "name": "freqoffset",
          "default": 0,
          "doc": "An offset added to all frequencies at initialization time."
        },
        {
          "name": "decayscale",
          "default": 1,
          "doc": "A scale factor multiplied by all ring times at initialization time."
        }
      ],
      "description": "Klank is a bank of fixed frequency resonators which can be used to\nsimulate the resonant modes of an object. Each mode is given a ring time,\nwhich is the time for the mode to decay by 60 dB.\nNote::for dynamic changes of parameters refer to DynKlank ::\n\nNote::\nThe amplitude of the resulting signal depends on the server's sample rate. See link::Classes/Ringz#Interaction with sample rate#Ringz: Interaction with sample rate:: for details.\n\nKlank is a bank of Ringz filters. Formlet is equivalent to Ringz.ar(... decay...) - Ring.ar(... attack...). Therefore, a more efficient way to make a bank of fixed-parameter Formlet filters is Klank(`decaySpecs, ...) - Klank.ar(`attackSpecs, ...) or Klank.ar(`specs, ..., decayscale: decay) - Klank.ar(`specs, ..., decayscale: attack).",
      "related": [
        "DynKlank",
        "Klang"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "LFClipNoise": {
      "name": "LFClipNoise",
      "summary": "Clipped noise",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 500,
          "doc": "Approximate rate at which to generate random values."
        }
      ],
      "description": "Randomly generates the values -1 or +1 at a rate given by the nearest\ninteger division of the sample rate by the  freq argument. It is probably pretty hard on your speakers!",
      "related": [
        "LFDClipNoise",
        "LFDNoise0",
        "LFDNoise1",
        "LFDNoise3",
        "LFNoise0",
        "LFNoise1",
        "LFNoise2"
      ],
      "parent": "LFNoise0",
      "signalRange": null,
      "inheritedFrom": "LFNoise0"
    },
    "LFCub": {
      "name": "LFCub",
      "summary": "A sine like shape made of two cubic pieces",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 440,
          "doc": "Frequency in Hertz."
        },
        {
          "name": "iphase",
          "default": 0,
          "doc": "Initial phase offset. For efficiency reasons this is a value ranging from 0 to 2."
        }
      ],
      "description": "A sine like shape made of two cubic pieces. Smoother than\nLFPar .",
      "related": [
        "LFPar",
        "LFPulse",
        "LFSaw",
        "LFTri"
      ],
      "parent": "LFSaw",
      "signalRange": null,
      "inheritedFrom": "LFSaw"
    },
    "LFDClipNoise": {
      "name": "LFDClipNoise",
      "summary": "Dynamic clipped noise",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 500,
          "doc": "Approximate rate at which to generate random values."
        }
      ],
      "description": "Like LFClipNoise, it generates the values -1 or +1 at a rate given\nby the  freq  argument, with two differences:\nlist::\n- no time quantization\n- fast recovery from low freq values foot(Note: \nLFClipNoise, as well as  LFNoise0,\nLFNoise1  and  LFNoise2  quantize to the\nnearest integer division of the samplerate, and they poll the\nfreq  argument only when scheduled; thus they often\nseem to hang when freqs get very low.\n)\n\nIf you don't need very high or very low freqs, or use fixed freqs,\nLFClipNoise  is more efficient.",
      "related": [
        "LFClipNoise",
        "LFDNoise0",
        "LFDNoise1",
        "LFDNoise3",
        "LFNoise0",
        "LFNoise1",
        "LFNoise2"
      ],
      "parent": "LFNoise0",
      "signalRange": null,
      "inheritedFrom": "LFNoise0"
    },
    "LFDNoise0": {
      "name": "LFDNoise0",
      "summary": "Dynamic step noise",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 500,
          "doc": "Approximate rate at which to generate random values."
        }
      ],
      "description": "Like LFNoise0, it generates random values at a rate\ngiven by the  freq  argument, with two differences:\n\nlist::\n- no time quantization\n- fast recovery from low freq values foot(Note: \nLFNoise0, LFNoise1  and\nLFNoise2  quantize to the nearest integer division\nof the samplerate, and they poll the  freq\nargument only when scheduled; thus they often seem to hang\nwhen freqs get very low.\n)\n\nIf you don't need very high or very low freqs, or use fixed freqs,\nLFNoise0  is more efficient.",
      "related": [
        "LFClipNoise",
        "LFDClipNoise",
        "LFDNoise1",
        "LFDNoise3",
        "LFNoise0",
        "LFNoise1",
        "LFNoise2"
      ],
      "parent": "LFNoise0",
      "signalRange": null,
      "inheritedFrom": "LFNoise0"
    },
    "LFDNoise1": {
      "name": "LFDNoise1",
      "summary": "Dynamic ramp noise",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 500,
          "doc": "Approximate rate at which to generate random values."
        }
      ],
      "description": "Like LFNoise1, it generates linearly interpolated random\nvalues at a rate given by the freq argument, with two differences:\nlist::\n- no time quantization\n- fast recovery from low freq values foot(Note: \nLFNoise0, LFNoise1  and\nLFNoise2  quantize to the nearest integer division\nof the samplerate, and they poll the  freq\nargument only when scheduled; thus they often seem to hang\nwhen freqs get very low.\n)\n\nIf you don't need very high or very low freqs, or use fixed freqs,\nLFNoise1  is more efficient.",
      "related": [
        "LFClipNoise",
        "LFDClipNoise",
        "LFDNoise0",
        "LFDNoise3",
        "LFNoise0",
        "LFNoise1",
        "LFNoise2"
      ],
      "parent": "LFNoise0",
      "signalRange": null,
      "inheritedFrom": "LFNoise0"
    },
    "LFDNoise3": {
      "name": "LFDNoise3",
      "summary": "Dynamic cubic noise",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 500,
          "doc": "Approximate rate at which to generate random values."
        }
      ],
      "description": "Similar to  LFNoise2, it generates polynomially\ninterpolated random values at a rate given by the\nfreq  argument, with 3 differences:\nlist::\n- no time quantization\n- fast recovery from low freq values foot(Note: \nLFNoise0, LFNoise1  and\nLFNoise2  quantize to the nearest integer division\nof the samplerate, and they poll the  freq\nargument only when scheduled; thus they often seem to hang\nwhen freqs get very low.\n)\n- cubic instead of quadratic interpolation\n\nIf you don't need very high or very low freqs, or use fixed freqs,\nLFNoise2  is more efficient.",
      "related": [
        "LFClipNoise",
        "LFDClipNoise",
        "LFDNoise0",
        "LFDNoise1",
        "LFNoise0",
        "LFNoise1",
        "LFNoise2"
      ],
      "parent": "LFNoise0",
      "signalRange": null,
      "inheritedFrom": "LFNoise0"
    },
    "LFGauss": {
      "name": "LFGauss",
      "summary": "Gaussian function oscillator",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "duration",
          "default": 1,
          "doc": null
        },
        {
          "name": "width",
          "default": 0.1,
          "doc": null
        },
        {
          "name": "iphase",
          "default": 0,
          "doc": null
        },
        {
          "name": "loop",
          "default": 1,
          "doc": null
        },
        {
          "name": "doneAction",
          "default": 0,
          "doc": null
        }
      ],
      "description": "A non-band-limited gaussian function oscillator.\n\nteletype::LFGauss:: implements the formula:\nteletype::\nf(x) = exp((x - iphase)^2 / (-2.0 * width^2))\n\nwhere teletype::x:: in this context is the phase, which cycles in a range teletype::-1:: to teletype::1:: over the period duration.\nThe Gaussian function in this form is a bell-shaped link::https://mathworld.wolfram.com/ApodizationFunction.html##apodization function::, making it convenient for use as an envelope.\n\nIts minimum value occurs when the phase teletype::x = -1:: and teletype::x = 1::, and its maximum occurs when teletype::x = 0::.",
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "LFNoise0": {
      "name": "LFNoise0",
      "summary": "Step noise",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 500,
          "doc": "Approximate rate at which to generate random values."
        }
      ],
      "description": "Generates random values at a rate given by the nearest integer division\nof the sample rate by the  freq  argument.",
      "related": [
        "LFClipNoise",
        "LFDClipNoise",
        "LFDNoise0",
        "LFDNoise1",
        "LFDNoise3",
        "LFNoise1",
        "LFNoise2"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "LFNoise1": {
      "name": "LFNoise1",
      "summary": "Ramp noise",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 500,
          "doc": "Approximate rate at which to generate random values."
        }
      ],
      "description": "Generates linearly interpolated random values at a rate given by the\nnearest integer division of the sample rate by the\nfreq  argument.",
      "related": [
        "LFClipNoise",
        "LFDClipNoise",
        "LFDNoise0",
        "LFDNoise1",
        "LFDNoise3",
        "LFNoise0",
        "LFNoise2"
      ],
      "parent": "LFNoise0",
      "signalRange": null,
      "inheritedFrom": "LFNoise0"
    },
    "LFNoise2": {
      "name": "LFNoise2",
      "summary": "Quadratic noise.",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 500,
          "doc": "Approximate rate at which to generate random values."
        }
      ],
      "description": "Generates quadratically interpolated random values at a rate given by\nthe nearest integer division of the sample rate by the\nfreq  argument.\n\n(Note: \nquadratic interpolation means that the noise values can occasionally extend beyond the normal range of +-1, if the freq varies in certain ways. If this is undesirable then you might like to clip2 the values, or use a linearly-interpolating unit instead.\n)",
      "related": [
        "LFClipNoise",
        "LFDClipNoise",
        "LFDNoise0",
        "LFDNoise1",
        "LFDNoise3",
        "LFNoise0",
        "LFNoise1"
      ],
      "parent": "LFNoise0",
      "signalRange": null,
      "inheritedFrom": "LFNoise0"
    },
    "LFPar": {
      "name": "LFPar",
      "summary": "Parabolic oscillator",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 440,
          "doc": "Frequency in Hertz."
        },
        {
          "name": "iphase",
          "default": 0,
          "doc": "Initial phase offset. For efficiency reasons this is a value ranging from 0 to 4."
        }
      ],
      "description": "A sine-like shape made of two parabolas and the integral of a triangular wave.  It has audible odd harmonics and is non-band-limited.\nOutput ranges from -1 to +1.",
      "related": [
        "LFCub",
        "LFPulse",
        "LFSaw",
        "LFTri"
      ],
      "parent": "LFSaw",
      "signalRange": null,
      "inheritedFrom": "LFSaw"
    },
    "LFPulse": {
      "name": "LFPulse",
      "summary": "pulse oscillator",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 440,
          "doc": "frequency in Hertz"
        },
        {
          "name": "iphase",
          "default": 0,
          "doc": "initial phase offset in cycles (0..1)"
        },
        {
          "name": "width",
          "default": 0.5,
          "doc": "pulse width duty cycle from zero to one."
        }
      ],
      "description": "A non-band-limited pulse oscillator. Outputs a high value of one and a low value of zero.",
      "related": [
        "LFSaw"
      ],
      "parent": "PureUGen",
      "signalRange": "unipolar"
    },
    "LFSaw": {
      "name": "LFSaw",
      "summary": "Sawtooth oscillator",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 440,
          "doc": "Frequency in Hertz."
        },
        {
          "name": "iphase",
          "default": 0,
          "doc": "Initial phase offset. For efficiency reasons this is a value\nranging from 0 to 2.\nNote:: enter \"1\" for an initial phase of 0 radians.\nA value of 0 would start the cycle at pi radians. See the example below.::"
        }
      ],
      "description": "A non-band-limited sawtooth oscillator. Output ranges from -1 to +1.",
      "related": [
        "LFCub",
        "LFPar",
        "LFPulse",
        "LFTri",
        "Saw"
      ],
      "parent": "PureUGen",
      "signalRange": null
    },
    "LFTri": {
      "name": "LFTri",
      "summary": "Triangle oscillator",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 440,
          "doc": "Frequency in Hertz. For efficiency reasons, only positive values result in correct behavior."
        },
        {
          "name": "iphase",
          "default": 0,
          "doc": "Initial phase offset. For efficiency reasons this is a value\nranging from 0 to 4."
        }
      ],
      "description": "A non-band-limited triangle oscillator. Output ranges from -1 to +1.",
      "related": [
        "LFCub",
        "LFPar",
        "LFPulse",
        "LFSaw"
      ],
      "parent": "LFSaw",
      "signalRange": null,
      "inheritedFrom": "LFSaw"
    },
    "LPF": {
      "name": "LPF",
      "summary": "2nd order Butterworth lowpass filter",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "freq",
          "default": 440,
          "doc": "Cutoff frequency in Hertz.\nWARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!"
        }
      ],
      "description": "A second order low pass filter.",
      "related": [
        "BPF",
        "BRF",
        "HPF"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "LPZ1": {
      "name": "LPZ1",
      "summary": "Two point average filter",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        }
      ],
      "description": "A special case fixed filter. Implements the formula:\n\nout(i) = 0.5 * (in(i) + in(i-1))\n\nwhich is a two point averager.",
      "related": [
        "HPZ1"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "LPZ2": {
      "name": "LPZ2",
      "summary": "Two zero fixed lowpass",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        }
      ],
      "description": "A special case fixed filter. Implements the formula:\n\nout(i) = 0.25 * (in(i) + (2 * in(i - 1)) + in(i - 2)).",
      "related": [
        "BPZ2",
        "BRZ2",
        "HPZ2"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "Lag": {
      "name": "Lag",
      "summary": "Exponential lag",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "lagTime",
          "default": 0.1,
          "doc": "60 dB lag time in seconds."
        }
      ],
      "description": "This is essentially the same as  OnePole  except that\ninstead of supplying the coefficient directly, it is calculated from a 60\ndB lag time. This is the time required for the filter to converge to\nwithin 0.01% of a value. This is useful for smoothing out control\nsignals.\n\nFor linear and other alternatives, see VarLag.",
      "related": [
        "Lag2",
        "Lag3",
        "VarLag",
        "LagUD"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "Lag2": {
      "name": "Lag2",
      "summary": "Exponential lag",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "lagTime",
          "default": 0.1,
          "doc": "60 dB lag time in seconds."
        }
      ],
      "description": "Lag2 is equivalent to  Lag.kr(Lag.kr(in, time), time) , thus resulting in a\nsmoother transition. This saves on CPU as you only have to calculate the\ndecay factor once instead of twice. See  Lag  for more\ndetails.",
      "related": [
        "Lag",
        "Lag3",
        "Ramp",
        "Lag2UD"
      ],
      "parent": "Lag",
      "signalRange": null,
      "inheritedFrom": "Lag"
    },
    "Lag2UD": {
      "name": "Lag2UD",
      "summary": "Exponential lag",
      "categories": "UGens>Filters",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": null
        },
        {
          "name": "lagTimeU",
          "default": 0.1,
          "doc": null
        },
        {
          "name": "lagTimeD",
          "default": 0.1,
          "doc": null
        }
      ],
      "description": "Lag2 is equivalent to Lag.kr(Lag.kr(in, time), time), thus resulting in a smoother transition. This saves on CPU as you only have to calculate the decay factor once instead of twice. See Lag for more details.",
      "related": [
        "Lag",
        "Lag2",
        "Lag3",
        "LagUD",
        "Lag3UD"
      ],
      "parent": "LagUD",
      "signalRange": null,
      "inheritedFrom": "LagUD"
    },
    "Lag3": {
      "name": "Lag3",
      "summary": "Exponential lag",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "lagTime",
          "default": 0.1,
          "doc": "60 dB lag time in seconds."
        }
      ],
      "description": "Lag3 is equivalent to  Lag.kr(Lag.kr(Lag.kr(in, time), time), time) , thus\nresulting in a smoother transition. This saves on CPU as you only have to\ncalculate the decay factor once instead of three times. See\nLag  for more details.",
      "related": [
        "Lag",
        "Lag2",
        "Ramp",
        "Lag3UD"
      ],
      "parent": "Lag",
      "signalRange": null,
      "inheritedFrom": "Lag"
    },
    "Lag3UD": {
      "name": "Lag3UD",
      "summary": "Exponential lag",
      "categories": "UGens>Filters",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": null
        },
        {
          "name": "lagTimeU",
          "default": 0.1,
          "doc": null
        },
        {
          "name": "lagTimeD",
          "default": 0.1,
          "doc": null
        }
      ],
      "description": "Lag3UD is equivalent to LagUD.kr(LagUD.kr(LagUD.kr(in, timeU, timeD), timeU, timeD), timeU, timeD), thus resulting in a smoother transition. This saves on CPU as you only have to calculate the decay factor once instead of three times. See LagUD for more details.",
      "related": [
        "Lag",
        "Lag2",
        "Lag3",
        "LagUD",
        "Lag2UD"
      ],
      "parent": "LagUD",
      "signalRange": null,
      "inheritedFrom": "LagUD"
    },
    "LagControl": {
      "name": "LagControl",
      "summary": "Lagged control input",
      "categories": "UGens>Synth control",
      "rates": [
        "ar",
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "values",
          "default": null,
          "doc": "Initial value (Float or Array of Floats)."
        },
        {
          "name": "lags",
          "default": null,
          "doc": "Lag times (Float or Array of Floats)."
        }
      ],
      "description": "Control ugen with fixed-time lags.",
      "related": [
        "Control",
        "TrigControl"
      ],
      "parent": "Control",
      "signalRange": null
    },
    "LagIn": {
      "name": "LagIn",
      "summary": "Read a control signal from a bus with a lag",
      "categories": "UGens>InOut",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "bus",
          "default": 0,
          "doc": "The index of the bus to read in from."
        },
        {
          "name": "numChannels",
          "default": 1,
          "doc": "The number of channels (i.e. adjacent buses) to read in. You\ncannot modulate this number."
        },
        {
          "name": "lag",
          "default": 0.1,
          "doc": "Lag factor."
        }
      ],
      "description": "Read a control signal from a bus with a lag.",
      "related": [
        "In",
        "InFeedback"
      ],
      "parent": "AbstractIn",
      "signalRange": null
    },
    "LagUD": {
      "name": "LagUD",
      "summary": "Exponential lag",
      "categories": "UGens>Filters",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": null
        },
        {
          "name": "lagTimeU",
          "default": 0.1,
          "doc": null
        },
        {
          "name": "lagTimeD",
          "default": 0.1,
          "doc": null
        }
      ],
      "description": "This is essentially the same as Lag except that you can supply a different 60 dB time for when the signal goes up, from when the signal goes down. This is useful for smoothing out control signals, where \"fade in\" should be different from \"fade out\".",
      "related": [
        "Lag",
        "Lag2",
        "Lag3",
        "Lag2UD",
        "Lag3UD"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "LastValue": {
      "name": "LastValue",
      "summary": "Output the last value before the input changed",
      "categories": "UGens>Triggers",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "diff",
          "default": 0.01,
          "doc": "Difference threshold.\n\nExamples::\n\nd = { |freq = 440| SinOsc.ar(LastValue.ar(freq, 20), 0, 0.2) }.play;\n\nd.set(\\freq, 400);\nd.set(\\freq, 200);\nd.set(\\freq, 670);\nd.set(\\freq, 680);\nd.set(\\freq, 695);\nd.free;\n\nReturn the difference between current and the last changed:\n\n(\nd = { |out = 0, val = 1|\n\tSinOsc.ar(\n\t\t\tabs(val - LastValue.kr(val)) * 400 + 200,\n\t\t\t0, 0.2\n\t)\n}.play;\n)\n\nd.set(\\val, 3);\nd.set(\\val, 2);\nd.set(\\val, 0.2);\nd.set(\\val, 1);\nd.set(\\val, 2);\nd.free;"
        }
      ],
      "description": "Output the last value before the input changed more than a threshold.",
      "related": [
        "LeastChange",
        "MostChange"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Latch": {
      "name": "Latch",
      "summary": "Sample and hold",
      "categories": "UGens>Triggers",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "trig",
          "default": 0,
          "doc": "Trigger. Trigger can be any signal. A trigger happens when the\nsignal changes from non-positive to positive.\n\nExamples::\n\n{ Blip.ar(Latch.ar(WhiteNoise.ar, Impulse.ar(9)) * 400 + 500, 4, 0.2) }.play;\n\nThe above is just meant as example. LFNoise0 is a faster way to generate random steps:\n\n{ Blip.ar(LFNoise0.kr(9, 400, 500), 4, 0.2) }.play;"
        }
      ],
      "description": "Holds input signal value when triggered. Latch will output 0 until it receives its first trigger.",
      "related": [
        "Gate"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "LatoocarfianC": {
      "name": "LatoocarfianC",
      "summary": "Latoocarfian chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "a",
          "default": 1,
          "doc": null
        },
        {
          "name": "b",
          "default": 3,
          "doc": null
        },
        {
          "name": "c",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "d",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "xi",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "yi",
          "default": 0.5,
          "doc": null
        }
      ],
      "description": "A cubic-interpolating sound generator based on a function given in Clifford Pickover's book Chaos In Wonderland, pg 26. The function is:\n\nteletype::\n\tx(n+1) = sin(b * y(n)) + c * sin(b * x(n))\n\ty(n+1) = sin(a * x(n)) + d * sin(a * y(n))\n\nAccording to Pickover, parameters a and b should be in the range from -3 to +3, and parameters c and d should be in the range from 0.5 to 1.5. The function can, depending on the parameters given, give continuous chaotic output, converge to a single value (silence) or oscillate in a cycle (tone).\n\nsclang code translation:\n\n(\nvar a = 1, b = 3, c = 0.5, d = 0.5, xi = 0.5, yi = 0.5, size = 64;\nplot(size.collect { var x = xi;\nxi = sin(b * yi) + (c * sin(b * xi));\nyi = sin(a * x) + (d * sin(a * yi));\nxi\n});\n)\n\n(Note: This UGen is experimental and not optimized currently, so is rather hoggish of CPU.)",
      "related": [
        "LatoocarfianN",
        "LatoocarfianL"
      ],
      "parent": "LatoocarfianN",
      "signalRange": null,
      "inheritedFrom": "LatoocarfianN"
    },
    "LatoocarfianL": {
      "name": "LatoocarfianL",
      "summary": "Latoocarfian chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "a",
          "default": 1,
          "doc": null
        },
        {
          "name": "b",
          "default": 3,
          "doc": null
        },
        {
          "name": "c",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "d",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "xi",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "yi",
          "default": 0.5,
          "doc": null
        }
      ],
      "description": "A linear-interpolating sound generator based on a function given in Clifford Pickover's book Chaos In Wonderland, pg 26. The function is:\n\nteletype::\n\t\tx(n+1) = sin(b * y(n)) + c * sin(b * x(n))\n\t\ty(n+1) = sin(a * x(n)) + d * sin(a * y(n))\n\nAccording to Pickover, parameters a and b should be in the range from -3 to +3, and parameters c and d should be in the range from 0.5 to 1.5. The function can, depending on the parameters given, give continuous chaotic output, converge to a single value (silence) or oscillate in a cycle (tone).\n\nsclang code translation:\n\n(\nvar a = 1, b = 3, c = 0.5, d = 0.5, xi = 0.5, yi = 0.5, size = 64;\nplot(size.collect { var x = xi;\nxi = sin(b * yi) + (c * sin(b * xi));\nyi = sin(a * x) + (d * sin(a * yi));\nxi\n});\n)\n\n(Note: This UGen is experimental and not optimized currently, so is rather hoggish of CPU.)",
      "related": [
        "LatoocarfianC",
        "LatoocarfianN"
      ],
      "parent": "LatoocarfianN",
      "signalRange": null,
      "inheritedFrom": "LatoocarfianN"
    },
    "LatoocarfianN": {
      "name": "LatoocarfianN",
      "summary": "Latoocarfian chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "a",
          "default": 1,
          "doc": null
        },
        {
          "name": "b",
          "default": 3,
          "doc": null
        },
        {
          "name": "c",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "d",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "xi",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "yi",
          "default": 0.5,
          "doc": null
        }
      ],
      "description": "A non-interpolating sound generator based on a function given in Clifford Pickover's book Chaos In Wonderland, pg 26. The function is:\n\nteletype::\n        x(n+1) = sin(b * y(n)) + c * sin(b * x(n))\n        y(n+1) = sin(a * x(n)) + d * sin(a * y(n))\n\nAccording to Pickover, parameters a and b should be in the range from -3 to +3, and parameters c and d should be in the range from 0.5 to 1.5. The function can, depending on the parameters given, give continuous chaotic output, converge to a single value (silence) or oscillate in a cycle (tone).\n\nsclang code translation:\n\n(\nvar a = 1, b = 3, c = 0.5, d = 0.5, xi = 0.5, yi = 0.5, size = 64;\nplot(size.collect { var x = xi;\nxi = sin(b * yi) + (c * sin(b * xi));\nyi = sin(a * x) + (d * sin(a * yi));\nxi\n});\n)\n\n(Note: This UGen is experimental and not optimized currently, so is rather hoggish of CPU.)",
      "related": [
        "LatoocarfianL",
        "LatoocarfianC"
      ],
      "parent": "ChaosGen",
      "signalRange": null
    },
    "LeakDC": {
      "name": "LeakDC",
      "summary": "Remove DC",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "coef",
          "default": 0.995,
          "doc": "Leak coefficient."
        }
      ],
      "description": "This is a linear filter that removes DC bias from a signal. Specifically, this is a one-pole highpass filter implementing the formula  y[n] = x[n] - x[n-1] + coef * y[n-1] . The frequency response of this filter is dependent on the sample rate of the server and the calculation rate of the UGen.",
      "related": [
        "DC"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "LeastChange": {
      "name": "LeastChange",
      "summary": "Output least changed",
      "categories": "UGens>Maths",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "a",
          "default": 0,
          "doc": "Input signal A."
        },
        {
          "name": "b",
          "default": 0,
          "doc": "Input signal B."
        }
      ],
      "description": "Given two inputs a and b, let da[t] = abs(a[t] - a[t - 1]) and db[t] = abs(b[t] - b[t - 1]). Output a[t] if da[t] is smaller, and output b[t] if db[t] is smaller. If da[t] == db[t], use whichever input was used last (assume a for the first sample of output).",
      "related": [
        "MostChange",
        "LastValue"
      ],
      "parent": "MostChange",
      "signalRange": null,
      "inheritedFrom": "MostChange"
    },
    "Limiter": {
      "name": "Limiter",
      "summary": "Peak limiter",
      "categories": "UGens>Dynamics",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The signal to be processed."
        },
        {
          "name": "level",
          "default": 1,
          "doc": "The peak output amplitude level to which to normalize the input."
        },
        {
          "name": "dur",
          "default": 0.01,
          "doc": "Also called lookAheadTime.\nThe buffer delay time. Shorter times will produce smaller delays\nand quicker transient response times, but may introduce amplitude\nmodulation artifacts.\nThis parameter cannot be modulated.\n\nExamples::\n\n(\n// example signal to process\n{\n\tvar z;\n\tz = Decay2.ar(\n\t\tImpulse.ar(8, LFSaw.kr(0.25, -0.6, 0.7)),\n\t\t0.001, 0.3, FSinOsc.ar(500));\n\tz * 0.8\n}.play\n)\n\n(\n{\n\tvar z;\n\tz = Decay2.ar(\n\t\tImpulse.ar(8, LFSaw.kr(0.25, -0.6, 0.7)),\n\t\t0.001, 0.3, FSinOsc.ar(500));\n\t[z, Limiter.ar(z, 0.4, 0.01)] * 0.5\n}.play\n)"
        }
      ],
      "description": "Limits the input amplitude to the given level. Limiter will not overshoot\nlike  Compander  will, but it needs to look ahead in the\naudio. Thus there is a delay equal to twice the value of the\ndur  parameter.\n\nLimiter, unlike Compander, is completely transparent for an in range signal.",
      "related": [
        "Amplitude",
        "Compander",
        "CompanderD",
        "Normalizer"
      ],
      "parent": "Normalizer",
      "signalRange": null,
      "inheritedFrom": "Normalizer"
    },
    "LinCongC": {
      "name": "LinCongC",
      "summary": "Linear congruential chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "a",
          "default": 1.1,
          "doc": null
        },
        {
          "name": "c",
          "default": 0.13,
          "doc": null
        },
        {
          "name": "m",
          "default": 1,
          "doc": null
        },
        {
          "name": "xi",
          "default": 0,
          "doc": null
        }
      ],
      "description": "A cubic-interpolating sound generator based on the difference equation:\n\nteletype::\n\tx(n+1) = (a * x(n) + c) % m\n\nThe output signal is automatically scaled to a range of [-1, 1].\n\nsclang code translation:\n\n(\nvar a = 1.1, c = 0.13, m = 1, xi = 0, size = 64;\nplot(size.collect { xi = (a * xi + c) % m });\n)",
      "related": [
        "LinCongN",
        "LinCongL"
      ],
      "parent": "LinCongN",
      "signalRange": null,
      "inheritedFrom": "LinCongN"
    },
    "LinCongL": {
      "name": "LinCongL",
      "summary": "Linear congruential chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "a",
          "default": 1.1,
          "doc": null
        },
        {
          "name": "c",
          "default": 0.13,
          "doc": null
        },
        {
          "name": "m",
          "default": 1,
          "doc": null
        },
        {
          "name": "xi",
          "default": 0,
          "doc": null
        }
      ],
      "description": "A linear-interpolating sound generator based on the difference equation:\n\nteletype::\n        x(n+1) = (a * x(n) + c) % m\n\nThe output signal is automatically scaled to a range of [-1, 1].\n\nsclang code translation:\n\n(\nvar a = 1.1, c = 0.13, m = 1, xi = 0, size = 64;\nplot(size.collect { xi = (a * xi + c) % m });\n)",
      "related": [
        "LinCongC",
        "LinCongN"
      ],
      "parent": "LinCongN",
      "signalRange": null,
      "inheritedFrom": "LinCongN"
    },
    "LinCongN": {
      "name": "LinCongN",
      "summary": "Linear congruential chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "a",
          "default": 1.1,
          "doc": null
        },
        {
          "name": "c",
          "default": 0.13,
          "doc": null
        },
        {
          "name": "m",
          "default": 1,
          "doc": null
        },
        {
          "name": "xi",
          "default": 0,
          "doc": null
        }
      ],
      "description": "A non-interpolating sound generator based on the difference equation:\n\nteletype::\n        x(n+1) = (a * x(n) + c) % m\n\nThe output signal is automatically scaled to a range of [-1, 1].\n\nsclang code translation:\n\n(\nvar a = 1.1, c = 0.13, m = 1, xi = 0, size = 64;\nplot(size.collect { xi = (a * xi + c) % m });\n)",
      "related": [
        "LinCongL",
        "LinCongC"
      ],
      "parent": "ChaosGen",
      "signalRange": null
    },
    "LinExp": {
      "name": "LinExp",
      "summary": "Map a linear range to an exponential range",
      "categories": "UGens>Maths",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal to convert."
        },
        {
          "name": "srclo",
          "default": 0,
          "doc": "Lower limit of input range."
        },
        {
          "name": "srchi",
          "default": 1,
          "doc": "Upper limit of input range."
        },
        {
          "name": "dstlo",
          "default": 1,
          "doc": "Lower limit of output range."
        },
        {
          "name": "dsthi",
          "default": 2,
          "doc": "Upper limit of output range."
        }
      ],
      "description": "Converts a linear range of values to an exponential range of values.",
      "related": [
        "LinLin"
      ],
      "parent": "PureUGen",
      "signalRange": null
    },
    "LinPan2": {
      "name": "LinPan2",
      "summary": "Two channel linear pan.",
      "categories": "UGens>Multichannel>Panners",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "The input signal."
        },
        {
          "name": "pos",
          "default": 0,
          "doc": "Pan position, -1 is left, +1 is right."
        },
        {
          "name": "level",
          "default": 1,
          "doc": "A control rate level input.\n\nExamples::\n\n// hear the difference, LinPan having a slight drop in the middle (yeah, it's subtle)...\n{ LinPan2.ar(SinOsc.ar(440), Line.kr(-1, 1, 5)) }.play;\n\n// ... whereas Pan2 is more smooth\n{ Pan2.ar(SinOsc.ar(440), Line.kr(-1, 1, 5)) }.play;\n\n// other examples\n{ LinPan2.ar(PinkNoise.ar(0.4), FSinOsc.kr(2)) }.play;\n\n{ LinPan2.ar(FSinOsc.ar(800, 0, 0.1), FSinOsc.kr(3)) }.play;"
        }
      ],
      "description": "Two channel linear panner. The signal is lowered as it pans from left (or right) to center using a straight line from 1 (left or right) to 0.5 (center) for a 6dB reduction in the middle. A problem inherent to linear panning is that the perceived volume of the signal drops in the middle. Pan2 solves this by taking the square root of the linear scaling factor going from 1 (left or right) to 0.5.sqrt (~=0.707) in the center, which is about 3dB reduction. This is equal power panning.\nLinPan2 sounds more like the Rhodes tremolo than Pan2.",
      "related": [
        "Balance2",
        "Pan2",
        "Pan4",
        "PanAz"
      ],
      "parent": "Pan2",
      "signalRange": null,
      "inheritedFrom": "Pan2"
    },
    "LinXFade2": {
      "name": "LinXFade2",
      "summary": "Two channel linear crossfade.",
      "categories": "UGens>Multichannel>Select",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "inA",
          "default": null,
          "doc": "Input signal A."
        },
        {
          "name": "inB",
          "default": 0,
          "doc": "Input signal B."
        },
        {
          "name": "pan",
          "default": 0,
          "doc": "Cross fade position from -1 to +1."
        },
        {
          "name": "level",
          "default": 1,
          "doc": "A control rate level input.\n\nExamples::\n\nplay({ LinXFade2.ar(FSinOsc.ar(800, 0, 0.2), PinkNoise.ar(0.2), FSinOsc.kr(1)) });"
        }
      ],
      "description": "Two channel linear crossfader.",
      "related": [
        "XFade2"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Line": {
      "name": "Line",
      "summary": "Line generator.",
      "categories": "UGens>Envelopes",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "start",
          "default": 0,
          "doc": "Starting value."
        },
        {
          "name": "end",
          "default": 1,
          "doc": "Ending value."
        },
        {
          "name": "dur",
          "default": 1,
          "doc": "Duration in seconds."
        },
        {
          "name": "doneAction",
          "default": 0,
          "doc": "A doneAction to be evaluated when the Line is completed. See\n\nDone  for more detail.\n\nExamples::\n\n// XLine is usually better than Line for frequency\nplay({ SinOsc.ar(Line.kr(200, 17000, 10), 0, 0.1) });"
        }
      ],
      "description": "Generates a line from the start value to the end value.",
      "related": [
        "XLine"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Linen": {
      "name": "Linen",
      "summary": "Simple linear envelope generator.",
      "categories": "UGens>Envelopes",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "gate",
          "default": 1,
          "doc": "This triggers the envelope and holds it open while > 0.\n\nIf gate < 0, force release with time  -1.0 - gate . See Classes/EnvGen#Forced release."
        },
        {
          "name": "attackTime",
          "default": 0.01,
          "doc": "The duration of the attack portion."
        },
        {
          "name": "susLevel",
          "default": 1,
          "doc": "The level of the sustain portion."
        },
        {
          "name": "releaseTime",
          "default": 1,
          "doc": "The duration of the release portion."
        },
        {
          "name": "doneAction",
          "default": 0,
          "doc": "An integer representing an action to be executed when the\nenvelope is finished. See\nDone  for\nmore detail.\n\nExamples::\n\n// trigged\n(\nSynthDef(\"help-Linen\", { |out = 0|\n\tOut.ar(out,\n\t\tLinen.kr(Impulse.kr(2), 0.01, 0.6, 1.0, doneAction: Done.none) * SinOsc.ar(440, 0, 0.1)\n\t)\n}).play;\n)\n\n// play once and end the synth\n(\nSynthDef(\"help-Linen\", { |out = 0|\n\tOut.ar(out,\n\t\tLinen.kr(Impulse.kr(0), 0.01, 0.6, 1.0, doneAction: Done.freeSelf) * SinOsc.ar(440, 0, 0.1)\n\t)\n}).play;\n)\n\n// play once and sustain\n(\nx = SynthDef(\"help-Linen\", { |gate = 1, out = 0| // use gate arg for release\n\tOut.ar(out,\n\t\tLinen.kr(gate, 0.01, 0.6, 1.0, doneAction: Done.freeSelf) * SinOsc.ar(440, 0, 0.1)\n\t)\n}).play;\n)\nx.release(4); // change the release time\n\n// longer gate, can pass in duration\n(\nSynthDef(\"help-Linen\", { |out = 0, dur = 0.1|\n\tvar gate;\n\tgate = Trig.kr(1.0, dur);\n\tOut.ar(out,\n\t\tLinen.kr(gate, 0.01, 0.6, 1.0, doneAction: Done.freeSelf) * SinOsc.ar(440, 0, 0.1)\n\t)\n}).play(nil, [\\out, 0, \\dur, 2.0]);\n)\n\n// used below in a Routine varying the releaseTime\n(\nSynthDef(\"help-Linen\", { |out = 0, freq = 440, attackTime = 0.01, susLevel = 0.6, releaseTime = 0.1|\n\tOut.ar(out,\n\t\tLinen.kr(Impulse.kr(0), attackTime, susLevel, releaseTime, doneAction: Done.freeSelf)\n\t\t\t* SinOsc.ar(freq, 0, 0.1)\n\t)\n}).add;\n)\n\n(\n// debussey sleeping through math class\nx = Pbrown(0.01, 2.0, 0.2, inf).asStream;\nRoutine({\n\tloop({\n\t\tSynth.grain(\"help-Linen\", [\\freq, (rrand(20, 50) * 2).midicps, \\releaseTime, x.next]);\n\t\t0.25.wait;\n\t})\n}).play(TempoClock.default)\n)\n\n(\nSynthDef(\"help-Linen\", { |out = 0|\n\tOut.ar(out,\n\n\t\tLinen.kr(Impulse.kr(2),\n\t\t\t0.01,\n\t\t\t// sustain level is polled at time of trigger\n\t\t\tFSinOsc.kr(0.1).range(0, 1),\n\t\t\t1.0,\n\t\t\tdoneAction: Done.none)\n\n\t\t\t* SinOsc.ar(440, 0, 0.1)\n\t)\n}).play;\n)"
        }
      ],
      "description": "Simple linear envelope generator.",
      "related": [
        "EnvGen"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "LocalIn": {
      "name": "LocalIn",
      "summary": "Define and read from buses local to a synth.",
      "categories": "UGens>InOut",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "numChannels",
          "default": 1,
          "doc": "The number of channels (i.e. adjacent buses) to read in. You\ncannot modulate this number by assigning it to an argument in a\nSynthDef."
        },
        {
          "name": "default",
          "default": 0,
          "doc": "The initial value written to the bus once, so that it can be used before overwriting it with LocalOut. An array can be passed in to specify different values for each channel.\n\nExamples::\n\n(\n{\n\tvar source, local;\n\n\tsource = Decay.ar(Impulse.ar(0.3), 0.1) * WhiteNoise.ar(0.2);\n\tlocal = LocalIn.ar(2) + [source, 0]; // read feedback, add to source\n\tlocal = DelayN.ar(local, 0.2, 0.2); // delay sound\n\n\t// reverse channels to give ping pong effect, apply decay factor\n\tLocalOut.ar(local.reverse * 0.8);\n\n\tlocal\n}.play;\n)\n\n(\n{\n\tvar local, in;\n\n\tin = Mix.fill(12, {\n\t\tPan2.ar(\n\t\t\tDecay2.ar(Dust.ar(0.05), 0.1, 0.5, 0.1)\n\t\t\t\t* FSinOsc.ar(IRand(36, 84).midicps).cubed.max(0),\n\t\t\tRand(-1, 1))\n\t});\n\tin = in + Pan2.ar(Decay2.ar(Dust.ar(0.03), 0.04, 0.3) * BrownNoise.ar, 0);\n\n\t4.do { in = AllpassN.ar(in, 0.03, { Rand(0.005, 0.02) }.dup, 1) };\n\n\tlocal = LocalIn.ar(2) * 0.98;\n\tlocal = OnePole.ar(local, 0.5);\n\n\tlocal = Rotate2.ar(local[0], local[1], 0.23);\n\tlocal = AllpassN.ar(local, 0.05, { Rand(0.01, 0.05) }.dup, 2);\n\n\tlocal = DelayN.ar(local, 0.3, [0.19, 0.26]);\n\tlocal = AllpassN.ar(local, 0.05, { Rand(0.03, 0.15) }.dup, 2);\n\n\tlocal = LeakDC.ar(local);\n\tlocal = local + in;\n\n\tLocalOut.ar(local);\n\n\tlocal\n\n}.play;\n)\n\n(\n{\n\tvar local, in, amp;\n\n\tin = SoundIn.ar([0, 1]);\n\n\tamp = Amplitude.kr(Mix.ar(in));\n\tin = in * (amp > 0.02); // noise gate\n\n\tlocal = LocalIn.ar(2);\n\tlocal = OnePole.ar(local, 0.4);\n\tlocal = OnePole.ar(local, -0.08);\n\n\tlocal = Rotate2.ar(local[0], local[1], 0.2);\n\n\tlocal = DelayN.ar(local, 0.25, 0.25);\n\n\tlocal = LeakDC.ar(local);\n\tlocal = ((local + in) * 1.25).softclip;\n\n\tLocalOut.ar(local);\n\tlocal * 0.1;\n}.play;\n)\n\n// Resonator, must subtract blockSize for correct tuning\n(\n{\n\tvar in, imp, sound;\n\n\tin = LocalIn.ar(1);\n\timp = Impulse.ar(1);\n\tsound = DelayC.ar(imp + (in * 0.995), 1, 440.reciprocal - ControlRate.ir.reciprocal);\n\tLocalOut.ar(sound); // for feedback\n\tin\n}.play;\n\n// compare pitch\n{\n\tSinOsc.ar(440, 0, 0.2)\n}.play(s, 1);\n)"
        }
      ],
      "description": "LocalIn defines buses that are local to the enclosing synth. These are\nlike the global buses, but are more convenient if you want to implement a\nself contained effect that uses a feedback processing loop.\n\nThere can only be one audio rate and one control rate LocalIn per\nSynthDef. The audio can be written to the bus using\nLocalOut .\n\n(Warning: \nAudio written to a  LocalOut  will not be read by a\ncorresponding LocalIn until the next cycle, i.e. one block size of\nsamples later. Because of this it is important to take this additional\ndelay into account when using LocalIn to create feedback delays with\ndelay times shorter than the threshold of pitch (i. e. < 0.05\nseconds or > 20Hz), or where sample accurate alignment is required.\nSee the resonator example below.\n)",
      "related": [
        "LocalOut"
      ],
      "parent": "AbstractIn",
      "signalRange": null
    },
    "LocalOut": {
      "name": "LocalOut",
      "summary": "Write to buses local to a synth.",
      "categories": "UGens>InOut",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "channelsArray",
          "default": null,
          "doc": "An Array of channels or single output to write out. You cannot\nchange the size of this once a SynthDef has been built.\n\nExamples::\n\n(\n{\n\tvar source, local;\n\n\tsource = Decay.ar(Impulse.ar(0.3), 0.1) * WhiteNoise.ar(0.2);\n\tlocal = LocalIn.ar(2) + [source, 0]; // read feedback, add to source\n\tlocal = DelayN.ar(local, 0.2, 0.2); // delay sound\n\n\t// reverse channels to give ping pong effect, apply decay factor\n\tLocalOut.ar(local.reverse * 0.8);\n\n\tlocal\n}.play;\n)\n\n(\nz = SynthDef(\"tank\", { |out|\n\tvar local, in;\n\n\tin = Mix.fill(12, {\n\t\tPan2.ar(\n\t\t\tDecay2.ar(Dust.ar(0.05), 0.1, 0.5, 0.1)\n\t\t\t\t* FSinOsc.ar(IRand(36, 84).midicps).cubed.max(0),\n\t\t\tRand(-1, 1))\n\t});\n\tin = in + Pan2.ar(Decay2.ar(Dust.ar(0.03), 0.04, 0.3) * BrownNoise.ar, 0);\n\n\t4.do { in = AllpassN.ar(in, 0.03, { Rand(0.005, 0.02) }.dup, 1) };\n\n\tlocal = LocalIn.ar(2) * 0.98;\n\tlocal = OnePole.ar(local, 0.5);\n\n\tlocal = Rotate2.ar(local[0], local[1], 0.23);\n\tlocal = AllpassN.ar(local, 0.05, { Rand(0.01, 0.05) }.dup, 2);\n\n\tlocal = DelayN.ar(local, 0.3, [0.19, 0.26]);\n\tlocal = AllpassN.ar(local, 0.05, { Rand(0.03, 0.15) }.dup, 2);\n\n\tlocal = LeakDC.ar(local);\n\tlocal = local + in;\n\n\tLocalOut.ar(local);\n\n\tOut.ar(out, local);\n}).play;\n)\n\n(\nz = SynthDef(\"tape\", { |out|\n\tvar local, in, amp;\n\n\tin = SoundIn.ar([0, 1]);\n\n\tamp = Amplitude.kr(Mix.ar(in));\n\tin = in * (amp > 0.02); // noise gate\n\n\tlocal = LocalIn.ar(2);\n\tlocal = OnePole.ar(local, 0.4);\n\tlocal = OnePole.ar(local, -0.08);\n\n\tlocal = Rotate2.ar(local[0], local[1], 0.2);\n\n\tlocal = DelayN.ar(local, 0.25, 0.25);\n\n\tlocal = LeakDC.ar(local);\n\tlocal = ((local + in) * 1.25).softclip;\n\n\tLocalOut.ar(local);\n\n\tOut.ar(out, local * 0.1);\n}).play;\n)\n\n// Resonator, must subtract blockSize for correct tuning\n(\n\n{\n\tvar imp, local;\n\tlocal = LocalIn.ar(1);\n\timp = Impulse.ar(1);\n\n\t// for feedback\n\tLocalOut.ar(DelayC.ar(imp + (local * 0.995), 1, 440.reciprocal - ControlRate.ir.reciprocal));\n\n\tlocal\n\n}.play;\n\n{ SinOsc.ar(440, 0, 0.2) }.play; // compare pitch\n)"
        }
      ],
      "description": "LocalOut writes to buses that are local to the enclosing synth. The buses\nshould have been defined by a  LocalIn  ugen. The\nchannelsArray  must be the same number of channels\nas were declared in the  LocalIn . These are like the\nglobal buses, but are more convenient if you want to implement a self\ncontained effect that uses a feedback processing loop.\n\n(Warning: \n\nAudio written to a LocalOut will not be read by a corresponding\nLocalIn  until the next cycle, i.e. one block size of\nsamples later. Because of this it is important to take this additional\ndelay into account when using  LocalIn  to create\nfeedback delays with delay times shorter than the threshold of pitch\n(i. e. < 0.05 seconds or > 20Hz), or where sample accurate\nalignment is required. See the resonator example below.\n\n)",
      "related": [
        "LocalIn"
      ],
      "parent": "AbstractOut",
      "signalRange": null
    },
    "Logistic": {
      "name": "Logistic",
      "summary": "Chaotic noise function",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "chaosParam",
          "default": 3,
          "doc": "a parameter of the chaotic function with useful values from 0.0 to 4.0. Chaos occurs from 3.57 up. Don't use values outside this range if you don't want the UGen to blow up."
        },
        {
          "name": "freq",
          "default": 1000,
          "doc": "Frequency of calculation; if over the sampling rate, this is clamped to the sampling rate"
        },
        {
          "name": "init",
          "default": 0.5,
          "doc": null
        }
      ],
      "description": "A noise generator based on the logistic map:\n\ny = chaosParam * y * (1.0 - y)",
      "related": [
        "Crackle",
        "LatoocarfianN"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "LorenzL": {
      "name": "LorenzL",
      "summary": "Lorenz chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "s",
          "default": 10,
          "doc": null
        },
        {
          "name": "r",
          "default": 28,
          "doc": null
        },
        {
          "name": "b",
          "default": 2.667,
          "doc": null
        },
        {
          "name": "h",
          "default": 0.05,
          "doc": null
        },
        {
          "name": "xi",
          "default": 0.1,
          "doc": null
        },
        {
          "name": "yi",
          "default": 0,
          "doc": null
        },
        {
          "name": "zi",
          "default": 0,
          "doc": null
        }
      ],
      "description": "A strange attractor discovered by Edward N. Lorenz while studying mathematical models of the atmosphere. The system is composed of three ordinary differential equations:\n\nteletype::\n\tx' = s * (y - x)\n\ty' = x * (r - z) - y\n\tz' = x * y - b * z\n\nThe time step amount h determines the rate at which the ODE is evaluated. Higher values will increase the rate, but cause more instability. A safe choice is the default amount of 0.05.",
      "related": [],
      "parent": "ChaosGen",
      "signalRange": null
    },
    "Loudness": {
      "name": "Loudness",
      "summary": "Extraction of instantaneous loudness in sones",
      "categories": "UGens>Analysis>Amplitude",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "chain",
          "default": null,
          "doc": null
        },
        {
          "name": "smask",
          "default": 0.25,
          "doc": null
        },
        {
          "name": "tmask",
          "default": 1,
          "doc": null
        }
      ],
      "description": "A perceptual loudness function which outputs loudness in sones; this is a variant of an MP3 perceptual model, summing excitation in ERB bands. It models simple spectral and temporal masking, with equal loudness contour correction in ERB bands to obtain phons (relative dB), then a phon to sone transform. The final output is typically in the range of 0 to 64 sones, though higher values can occur with specific synthesised stimuli.\n\n(Note: Research note: This UGen is an informal juxtaposition of perceptual coding, and a Zwicker and Glasberg/Moore/Stone loudness model.)",
      "related": [
        "BeatTrack",
        "MFCC",
        "Onsets",
        "Pitch",
        "KeyTrack"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "MFCC": {
      "name": "MFCC",
      "summary": "Mel frequency cepstral coefficients",
      "categories": "UGens>Analysis",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "chain",
          "default": null,
          "doc": null
        },
        {
          "name": "numcoeff",
          "default": 13,
          "doc": null
        }
      ],
      "description": "Generates a set of MFCCs; these are obtained from a band-based frequency representation (using the Mel scale by default), and then a discrete cosine transform (DCT). The DCT is an efficient approximation for principal components analysis, so that it allows a compression, or reduction of dimensionality, of the data, in this case reducing 42 band readings to a smaller set of MFCCs. A small number of features (the coefficients) end up describing the spectrum. The MFCCs are commonly used as timbral descriptors.\n\nOutput values are somewhat normalised for the range 0.0 to 1.0, but there are no guarantees on exact conformance to this. Commonly, the first coefficient will be the highest value.\n\n(Note: Drafts of an MFCC UGen were prepared by both Dan Stowell and Nick Collins; their various ideas are combined here in a cross platform compatible UGen. Mel scale spacing with triangular crossfade overlap is used by default for the bands, approximately tracking the human critical band spacing and bandwidth. Variants such as BFCC (Bark) and EFCC (ERB) given similar results in practice; the Mel scale as used here is the standard as adapted from the speech recognition literature and now applied in music information retrieval.)",
      "related": [
        "BeatTrack",
        "Loudness",
        "Onsets",
        "Pitch",
        "KeyTrack"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "MantissaMask": {
      "name": "MantissaMask",
      "summary": "Reduce precision.",
      "categories": "UGens>Filters>Nonlinear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "bits",
          "default": 3,
          "doc": "The number of mantissa bits to preserve. A number from 0 to 23."
        }
      ],
      "description": "Masks off bits in the mantissa of the floating point sample value.\nThis introduces a quantization noise, but is less severe than linearly\nquantizing the signal.",
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "Median": {
      "name": "Median",
      "summary": "Median filter.",
      "categories": "UGens>Filters>Nonlinear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "length",
          "default": 3,
          "doc": "Number of input points in which to find the median. Must be an\nodd number from 1 to 31. If\nlength  is 1\nthen Median has no effect."
        },
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        }
      ],
      "description": "Returns the median of the last length input points. This non-linear\nfilter is good at reducing impulse noise from a signal.",
      "related": [],
      "parent": "Filter",
      "signalRange": null
    },
    "MidEQ": {
      "name": "MidEQ",
      "summary": "Parametric filter.",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "freq",
          "default": 440,
          "doc": "Center frequency of the band in Hertz."
        },
        {
          "name": "rq",
          "default": 1,
          "doc": "The reciprocal of Q (bandwidth / cutoffFreq)."
        },
        {
          "name": "db",
          "default": 0,
          "doc": "Amount of boost (db > 0) or attenuation (db < 0) of the\nfrequency band."
        }
      ],
      "description": "Attenuates or boosts a frequency band.",
      "related": [],
      "parent": "Filter",
      "signalRange": null
    },
    "ModDif": {
      "name": "ModDif",
      "summary": "Minimum difference of two values in modulo arithmetics",
      "categories": "UGens>Maths",
      "rates": [
        "ar",
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "x",
          "default": 0,
          "doc": "First input value"
        },
        {
          "name": "y",
          "default": 0,
          "doc": "Second input value"
        },
        {
          "name": "mod",
          "default": 1,
          "doc": "Modulo (maximum value, double of the maximal difference).\n\n// different moduli\n(\n{\n\tvar sig = LFSaw.ar(10);\n\tvar dist = ModDif.kr(sig, 0, (0..8) * MouseX.kr(0, 1/5));\n\tSplay.ar(SinOsc.ar(dist * 4000 + 400)) * 0.1\n}.play;\n)\n\n// wrapping amplitude crossfade\n(\n{\n\tvar numChan = 12;\n\tvar x = SinOsc.ar({ rrand(300.0, 800.0) } ! numChan);\n\tvar dist = ModDif.kr(MouseX.kr(0, numChan * 2), (0..numChan-1), numChan);\n\tx = x * max(0, 1 - dist);\n\tSplay.ar(x) * 0.1\n}.play;\n)"
        }
      ],
      "description": "Returns the minimum difference of two values in modulo arithmetics. On a circle, there are two distances between two points. This UGen returns the smaller value of the two.\n\n{ var a = Line.ar(0, 4, 0.01), d = ModDif.ar(a); [a, d] }.plot;\n{ var a = Line.ar(0, 4, 0.01); ModDif.ar(a, 0, (1..4)) }.plot;\n{ var a = Line.ar(0, 4, 0.01); ModDif.ar(a, (0, 0.25 .. 1), 1) }.plot;",
      "related": [
        "Clip",
        "Wrap"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "MoogFF": {
      "name": "MoogFF",
      "summary": "Moog VCF implementation, designed by Federico Fontana",
      "categories": "UGens>Filters",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [],
      "description": "A digital implementation of the Moog VCF (filter). foot(Note: \nThe design of this filter is described in the conference paper Fontana, F. (2007) Preserving the Digital Structure of the Moog VCF. In Proc. ICMC07, Copenhagen, 25-31 August 2007.\n)\nfoot(Note: \nOriginal Java code created by F. Fontana - August 2007 - federico.fontana@univr.it\nPorted to C++ for SuperCollider by Dan Stowell\n)",
      "related": [
        "RLPF",
        "LPF"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "MostChange": {
      "name": "MostChange",
      "summary": "Output most changed.",
      "categories": "UGens>Maths",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "a",
          "default": 0,
          "doc": "Input signal A."
        },
        {
          "name": "b",
          "default": 0,
          "doc": "Input signal B.\n\nExamples::\n\n(\nd = SynthDef(\"help-MostChange\", { |out, amp = 1.0|\n\tvar sound, in1, in2;\n\tin1 = LFNoise1.ar(800, amp);\n\tin2 = SinOsc.ar(800);\n\tsound = MostChange.ar(in1, in2) * 0.1;\n\tOut.ar(out, sound)\n}).play;\n)\n\nd.set(\\amp, 0.1);\nd.set(\\amp, 0);\nd.set(\\amp, 3);\nd.free;\n\n// the control that changed most is used for output:\n\n(\nd = SynthDef(\"help-MostChange\", { |out, freq = 440|\n\tvar sound, internalFreq;\n\tinternalFreq = LFNoise0.ar(0.3, 300, 800);\n\tsound = SinOsc.ar(\n\t\t\tMostChange.kr(freq, internalFreq)\n\t);\n\tOut.ar(out, sound * 0.1)\n}).play;\n)\n\nd.set(\\freq, 800);\nd.set(\\freq, 800); // nothing changed\nd.set(\\freq, 900);\nd.free;"
        }
      ],
      "description": "Given two inputs a and b, let da[t] = abs(a[t] - a[t - 1]) and db[t] = abs(b[t] - b[t - 1]). Output a[t] if da[t] is larger, and output b[t] if db[t] is larger. If da[t] == db[t], use whichever input was used last (assume a for the first sample of output).",
      "related": [
        "LeastChange",
        "LastValue"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "MouseButton": {
      "name": "MouseButton",
      "summary": "Mouse button UGen.",
      "categories": "UGens>User interaction",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "minval",
          "default": 0,
          "doc": "Value when the button is not pressed."
        },
        {
          "name": "maxval",
          "default": 1,
          "doc": "Value when the button is pressed."
        },
        {
          "name": "lag",
          "default": 0.2,
          "doc": "Lag factor.\n\nExamples::\n\n{ SinOsc.ar(MouseButton.kr(400, 440, 0.1), 0, 0.1) }.play;\n{ SinOsc.ar(MouseButton.kr(400, 740, 2), 0, 0.1) }.play;\n\n(\nSynthDef(\\mousexyb, { |out = 0|\n\tvar mousex, mousey, mousebutton;\n\tmousex = MouseX.kr(500, 1000); // this will determine the frequency of the sound (minimum value, maximum value, warp, lag)\n\tmousey = MouseY.kr(0, 0.3); // this will determine the amplitude of the sound\n\tmousebutton = MouseButton.kr(0, 1, 2); // this will turn the sound on or off (minimum value, maximum value, lag)\n\tOut.ar(out, SinOsc.ar(mousex, 0, mousey) * mousebutton);\n}).add\n)\n\nx = Synth.new(\\mousexyb);\nx.free;"
        }
      ],
      "description": "Mouse button UGen.\n\nWARNING::\nThis UGen will not work for Linux users using Wayland, as the Wayland protocol does not allow a global keyboard or mouse state to be captured.\nThe UGen will return MATH::0.0:: as constant value.\nFor more information see https://github.com/supercollider/supercollider/issues/4544",
      "related": [
        "KeyState",
        "MouseX",
        "MouseY"
      ],
      "parent": "UGen",
      "signalRange": "unipolar"
    },
    "MouseX": {
      "name": "MouseX",
      "summary": "Cursor tracking UGen.",
      "categories": "UGens>User interaction",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "minval",
          "default": 0,
          "doc": "Value corresponding to the left edge of the screen."
        },
        {
          "name": "maxval",
          "default": 1,
          "doc": "Value corresponding to the right edge of the screen."
        },
        {
          "name": "warp",
          "default": 0,
          "doc": "Mapping curve. 0 is linear, 1 is exponential (e. g. for freq or\ntimes). Alternatively you can specify: 'linear' or 'exponential'."
        },
        {
          "name": "lag",
          "default": 0.2,
          "doc": "Lag factor to dezipper cursor movement.\n\nExamples::\n\n{ SinOsc.ar(MouseX.kr(40, 10000, 1), 0, 0.1) }.play;\n{ SinOsc.ar(MouseX.kr(500, 10000, 1).poll, 0, 0.1) }.play;"
        }
      ],
      "description": "Cursor tracking UGen.\n\nWARNING::\nThis UGen will not work for Linux users using Wayland, as the Wayland protocol does not allow a global keyboard or mouse state to be captured.\nThe UGen will return a constant random value between MATH::0.0:: and MATH::1.0::.\nFor more information see https://github.com/supercollider/supercollider/issues/4544",
      "related": [
        "KeyState",
        "MouseButton",
        "MouseY"
      ],
      "parent": "UGen",
      "signalRange": "unipolar"
    },
    "MouseY": {
      "name": "MouseY",
      "summary": "Cursor tracking UGen.",
      "categories": "UGens>User interaction",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "minval",
          "default": 0,
          "doc": "Value corresponding to the bottom edge of the screen."
        },
        {
          "name": "maxval",
          "default": 1,
          "doc": "Value corresponding to the top edge of the screen."
        },
        {
          "name": "warp",
          "default": 0,
          "doc": "Mapping curve. 0 is linear, 1 is exponential (e. g. for freq or\ntimes). Alternatively you can specify: 'linear' or 'exponential'."
        },
        {
          "name": "lag",
          "default": 0.2,
          "doc": "Lag factor to dezipper cursor movement.\n\nExamples::\n\n{ SinOsc.ar(MouseY.kr(40, 10000, 1), 0, 0.1) }.play;"
        }
      ],
      "description": "Cursor tracking UGen.\n\nWARNING::\nThis UGen will not work for Linux users using Wayland, as the Wayland protocol does not allow a global keyboard or mouse state to be captured.\nThe UGen will return a constant random value between MATH::0.0:: and MATH::1.0::.\nFor more information see https://github.com/supercollider/supercollider/issues/4544",
      "related": [
        "KeyState",
        "MouseButton",
        "MouseX"
      ],
      "parent": "MouseX",
      "signalRange": null,
      "inheritedFrom": "MouseX"
    },
    "MultiplexAnalogIn": {
      "name": "MultiplexAnalogIn",
      "summary": "Read data from an analog input of the Bela board",
      "categories": "UGens>Bela",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "analogPin",
          "default": 0,
          "doc": "Analog pin number to read. Pin numbers begin at 0."
        },
        {
          "name": "muxChannel",
          "default": 0,
          "doc": "Multiplex channel to read. Pin numbers begin at 0."
        }
      ],
      "description": "Reads analog data from a multiplexed analog input of the Bela board, with the additional Multiplexer board.\n\n(Note: \nThis UGen only works on Bela\n)",
      "related": [
        "AnalogIn",
        "AnalogOut",
        "DigitalIn",
        "DigitalOut",
        "DigitalIO"
      ],
      "parent": "UGen",
      "signalRange": "unipolar"
    },
    "NodeID": {
      "name": "NodeID",
      "summary": null,
      "categories": null,
      "rates": [
        "ir"
      ],
      "args": [],
      "description": null,
      "related": [],
      "parent": "InfoUGenBase",
      "signalRange": null
    },
    "Normalizer": {
      "name": "Normalizer",
      "summary": "Flattens dynamics.",
      "categories": "UGens>Dynamics",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The signal to be processed."
        },
        {
          "name": "level",
          "default": 1,
          "doc": "The peak output amplitude level to which to normalize the input."
        },
        {
          "name": "dur",
          "default": 0.01,
          "doc": "Also called lookAheadTime.\nThe buffer delay time. Shorter times will produce smaller delays\nand quicker transient response times, but may introduce amplitude\nmodulation artifacts.\nThis parameter cannot be modulated.\n\nExamples::\n\n(\n// example signal to process\n{\n\tvar z;\n\tz = Decay2.ar(\n\t\tImpulse.ar(8, LFSaw.kr(0.25, -0.6, 0.7)),\n\t\t0.001, 0.3, FSinOsc.ar(500));\n\tz * 0.8\n}.play\n)\n\n(\n{\n\tvar z;\n\tz = Decay2.ar(\n\t\tImpulse.ar(8, LFSaw.kr(0.25, -0.6, 0.7)),\n\t\t0.001, 0.3, FSinOsc.ar(500));\n\t[z, Normalizer.ar(z, 0.4, 0.01)] * 0.5\n}.play\n)"
        }
      ],
      "description": "Normalizes the input amplitude to the given level. Normalizer will not\novershoot like  Compander  will, but it needs to look\nahead in the audio. Thus there is a delay equal to twice the value\nof the  dur  parameter.",
      "related": [
        "Amplitude",
        "Compander",
        "CompanderD",
        "Limiter"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "NumAudioBuses": {
      "name": "NumAudioBuses",
      "summary": "Number of audio busses.",
      "categories": "UGens>Info",
      "rates": [
        "ir"
      ],
      "args": [],
      "description": "Number of audio busses.",
      "related": [
        "NumBuffers",
        "NumControlBuses",
        "NumInputBuses",
        "NumOutputBuses",
        "NumRunningSynths"
      ],
      "parent": "InfoUGenBase",
      "signalRange": null
    },
    "NumBuffers": {
      "name": "NumBuffers",
      "summary": "Number of open buffers.",
      "categories": "UGens>Info",
      "rates": [
        "ir"
      ],
      "args": [],
      "description": "Number of open buffers.",
      "related": [
        "NumAudioBuses",
        "NumControlBuses",
        "NumInputBuses",
        "NumOutputBuses",
        "NumRunningSynths"
      ],
      "parent": "InfoUGenBase",
      "signalRange": null
    },
    "NumControlBuses": {
      "name": "NumControlBuses",
      "summary": "Number of control busses.",
      "categories": "UGens>Info",
      "rates": [
        "ir"
      ],
      "args": [],
      "description": "Number of control busses.",
      "related": [
        "NumAudioBuses",
        "NumBuffers",
        "NumInputBuses",
        "NumOutputBuses",
        "NumRunningSynths"
      ],
      "parent": "InfoUGenBase",
      "signalRange": null
    },
    "NumInputBuses": {
      "name": "NumInputBuses",
      "summary": "Number of input busses.",
      "categories": "UGens>Info",
      "rates": [
        "ir"
      ],
      "args": [],
      "description": "Number of input busses.",
      "related": [
        "NumAudioBuses",
        "NumControlBuses",
        "NumBuffers",
        "NumOutputBuses",
        "NumRunningSynths"
      ],
      "parent": "InfoUGenBase",
      "signalRange": null
    },
    "NumOutputBuses": {
      "name": "NumOutputBuses",
      "summary": "Number of output busses.",
      "categories": "UGens>Info",
      "rates": [
        "ir"
      ],
      "args": [],
      "description": "Number of output busses.",
      "related": [
        "NumAudioBuses",
        "NumControlBuses",
        "NumBuffers",
        "NumInputBuses",
        "NumRunningSynths"
      ],
      "parent": "InfoUGenBase",
      "signalRange": null
    },
    "NumRunningSynths": {
      "name": "NumRunningSynths",
      "summary": "Number of currently running synths.",
      "categories": "UGens>Info",
      "rates": [
        "kr"
      ],
      "args": [],
      "description": "Number of currently running synths.",
      "related": [
        "NumAudioBuses",
        "NumControlBuses",
        "NumBuffers",
        "NumInputBuses",
        "NumOutputBuses"
      ],
      "parent": "InfoUGenBase",
      "signalRange": null
    },
    "OffsetOut": {
      "name": "OffsetOut",
      "summary": "Write a signal to a bus with sample accurate timing.",
      "categories": "UGens>InOut",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "bus",
          "default": null,
          "doc": "The index of the bus to write out to. The lowest numbers are\nwritten to the audio hardware."
        },
        {
          "name": "channelsArray",
          "default": null,
          "doc": "An Array of channels or single output to write out. You cannot\nchange the size of this once a SynthDef has been built.\n\nExamples::\n\n(\nSynthDef(\"help-OffsetOut\",\n\t{ |out = 0, freq = 440, dur = 0.05|\n\t\tvar env;\n\t\tenv = EnvGen.kr(Env.perc(0.01, dur, 0.2), doneAction: Done.freeSelf);\n\t\tOffsetOut.ar(out, SinOsc.ar(freq, 0, env))\n}).send(s);\n\nSynthDef(\"help-Out\",\n\t{ |out = 0, freq = 440, dur = 0.05|\n\t\tvar env;\n\t\tenv = EnvGen.kr(Env.perc(0.01, dur, 0.2), doneAction: Done.freeSelf);\n\t\t// compare to Out:\n\t\tOut.ar(out, SinOsc.ar(freq, 0, env))\n}).send(s);\n)\n\n// these are in sync\n(\nRoutine({\n\tloop {\n\t\ts.sendBundle(0.2, [\"/s_new\", \"help-OffsetOut\", -1]);\n\t\t0.01.wait;\n\t}\n}).play;\n)\n\n// these are less reliably in sync and are placed at multiples of blocksize.\n(\nRoutine({\n\tloop {\n\t\ts.sendBundle(0.2, [\"/s_new\", \"help-Out\", -1]);\n\t\t0.01.wait;\n\t}\n}).play;\n)\n\nSynthDef(\"trig1\", {\n\tvar gate, tone;\n\tgate = Trig1.ar(1.0, t);\n\ttone = In.ar(10, 1); // tone comes in normally\n\t// but is then delayed when by the OffsetOut\n\tOffsetOut.ar(0,\n\t\ttone * EnvGen.ar(\n\t\t\t\tEnv([0, 0.1, 0.1, 0], [0.01, 1.0, 0.01], [-4, 4], 2),\n\t\t\t\tgate, doneAction: Done.freeSelf\n\t\t\t)\n\t)\n})"
        }
      ],
      "description": "Output signal to a bus, the sample offset within the bus is kept\nexactly; i.e. if the synth is scheduled to be started part way through a\ncontrol cycle, OffsetOut will maintain the correct offset by buffering\nthe output and delaying it until the exact time that the synth was\nscheduled for.\n\nFor achieving subsample accuracy see  SubsampleOffset\n\n(Note: \n\nNote that if you have an input to the synth, it will be coming in and\nits normal time, then mixed in your synth, and then delayed with the\noutput. So you shouldn't use OffsetOut for effects or gating.\n\n)\n\nSee the Reference/Server-Architecture and Bus helpfiles for more information on\nbuses and how they are used.",
      "related": [
        "Out",
        "ReplaceOut",
        "XOut"
      ],
      "parent": "Out",
      "signalRange": null,
      "inheritedFrom": "Out"
    },
    "OnePole": {
      "name": "OnePole",
      "summary": "One pole filter.",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "coef",
          "default": 0.5,
          "doc": "Feedback coefficient. Should be between -1 and +1"
        }
      ],
      "description": "A one pole filter. Implements the formula:\n\nout(i) = ((1 - abs(coef)) * in(i)) + (coef * out(i-1)).",
      "related": [
        "OneZero"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "OneZero": {
      "name": "OneZero",
      "summary": "One zero filter.",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "coef",
          "default": 0.5,
          "doc": "Feed forward coefficient.\n\n+0.5 makes a two point averaging filter\n(see also\nLPZ1).\n\n-0.5 makes a differentiator\n(see also\nHPZ1).\n\n+1 makes a single sample delay\n(see also\nDelay1).\n\n-1 makes an inverted single sample delay."
        }
      ],
      "description": "A one zero filter. Implements the formula:\n\nout(i) = ((1 - abs(coef)) * in(i)) + (coef * in(i-1)).",
      "related": [
        "OnePole"
      ],
      "parent": "OnePole",
      "signalRange": null,
      "inheritedFrom": "OnePole"
    },
    "Onsets": {
      "name": "Onsets",
      "summary": "Onset detector",
      "categories": "UGens>Analysis",
      "rates": [
        "kr"
      ],
      "args": [],
      "description": "An onset detector for musical audio signals - detects the beginning of notes/drumbeats/etc. Outputs a control-rate trigger signal which is 1 when an onset is detected, and 0 otherwise.\n\nFor more details of all the processes involved, the different onset detection functions, and their evaluation, see:\n\nD. Stowell and M. D. Plumbley. Adaptive whitening for improved real-time audio onset detection. Proceedings of the International Computer Music Conference (ICMC2007), Copenhagen, Denmark, August 2007. See\nhttp://c4dm.eecs.qmul.ac.uk/papers/2007/StowellPlumbley07-icmc.pdf",
      "related": [
        "BeatTrack",
        "Loudness",
        "MFCC",
        "Pitch",
        "KeyTrack"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Osc": {
      "name": "Osc",
      "summary": "Interpolating wavetable oscillator.",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": "Buffer index."
        },
        {
          "name": "freq",
          "default": 440,
          "doc": "Frequency in Hertz."
        },
        {
          "name": "phase",
          "default": 0,
          "doc": "Phase offset or modulator in radians.\n(Note: phase values should be within the range +-8pi. If your phase values are larger then simply use .mod(2pi) to wrap them.)"
        }
      ],
      "description": "Linear interpolating wavetable lookup oscillator with frequency and\nphase modulation inputs.\n\nThis oscillator requires a buffer to be filled with a wavetable format\nsignal. This preprocesses the Signal into a form which can be used\nefficiently by the Oscillator. The buffer size must be a power of 2.\n\nThis can be achieved by creating a Buffer object and sending it one of\nthe \"b_gen\" messages (Classes/Buffer#-sine1, Classes/Buffer#-sine2, Classes/Buffer#-sine3) with the wavetable flag set\nto true.\n\nThis can also be achieved by creating a Signal object and sending it\nthe 'asWavetable' message, thereby creating a Wavetable object in the required format. Then, the wavetable data may be transmitted to the server using the Classes/Buffer#*sendCollection or Classes/Buffer#*loadCollection methods.",
      "related": [
        "COsc",
        "OscN",
        "VOsc",
        "VOsc3",
        "Wavetable"
      ],
      "parent": "PureUGen",
      "signalRange": null
    },
    "OscN": {
      "name": "OscN",
      "summary": "Noninterpolating wavetable oscillator.",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": "Buffer index.  the buffer size must be a power of 2.\nThe buffer should NOT be filled using Wavetable format (b_gen\ncommands should set wavetable flag to false. Raw signals (not\nconverted with asWavetable) can be saved to disk and loaded\ninto the buffer."
        },
        {
          "name": "freq",
          "default": 440,
          "doc": "Frequency in Hertz."
        },
        {
          "name": "phase",
          "default": 0,
          "doc": "Phase offset or modulator in radians."
        }
      ],
      "description": "Noninterpolating wavetable lookup oscillator with frequency and phase\nmodulation inputs. It is usually better to use the interpolating\noscillator  Osc .",
      "related": [
        "COsc",
        "Osc",
        "VOsc",
        "VOsc3"
      ],
      "parent": "PureUGen",
      "signalRange": null
    },
    "Out": {
      "name": "Out",
      "summary": "Write a signal to a bus.",
      "categories": "UGens>InOut",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "bus",
          "default": null,
          "doc": "The index of the bus to write out to. The lowest numbers are\nwritten to the audio hardware."
        },
        {
          "name": "channelsArray",
          "default": null,
          "doc": "An Array of channels or single output to write out. You cannot\nchange the size of this once a SynthDef has been built.\n\nExamples::\n\n(\nSynthDef(\"help-out\", { |out = 0, freq = 440|\n\tvar source;\n\t\tsource = SinOsc.ar(freq, 0, 0.1);\n\n\t\t// write to the bus, adding to previous contents\n\t\tOut.ar(out, source);\n\n}).add;\n)\n\nSynth(\"help-out\", [\\freq, 500]);\nSynth(\"help-out\", [\\freq, 600]);\nSynth(\"help-out\", [\\freq, 700]);"
        }
      ],
      "description": "Write a signal to a bus.\n\nNote that using the Bus class to allocate a multichannel bus simply\nreserves a series of adjacent bus indices with the Server object's bus\nallocators. abus.index simply returns the first of those indices. When\nusing a Bus with an In or Out UGen there is nothing to stop you from\nreading to or writing from a larger range, or from hardcoding to a bus\nthat has been allocated. You are responsible for making sure that the\nnumber of channels match and that there are no conflicts.\n\n(Note: \n\nOut is subject to control rate jitter. Where sample accurate output is\nneeded, use  OffsetOut .\n\n)\n\nSee the Reference/Server-Architecture and Bus helpfiles for more information on\nbuses and how they are used.",
      "related": [
        "OffsetOut",
        "ReplaceOut",
        "XOut"
      ],
      "parent": "AbstractOut",
      "signalRange": null
    },
    "PSinGrain": {
      "name": "PSinGrain",
      "summary": "Very fast sine grain with a parabolic envelope",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 440,
          "doc": "Frequency in Hertz."
        },
        {
          "name": "dur",
          "default": 0.2,
          "doc": "Grain duration."
        },
        {
          "name": "amp",
          "default": 0.1,
          "doc": "Grain amplitude."
        }
      ],
      "description": "Very fast sine grain with a parabolic envelope.",
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "PV_Add": {
      "name": "PV_Add",
      "summary": "Complex addition.",
      "categories": "UGens>FFT",
      "rates": [],
      "args": [],
      "description": "Complex addition:\n\nRealA + RealB, ImagA + ImagB",
      "related": [
        "FFT",
        "IFFT",
        "PV_CopyPhase",
        "PV_MagMul",
        "PV_Max",
        "PV_Min",
        "PV_Mul"
      ],
      "parent": "PV_MagMul",
      "signalRange": null
    },
    "PV_Conj": {
      "name": "PV_Conj",
      "summary": "Complex conjugate",
      "categories": "UGens>FFT",
      "rates": [],
      "args": [],
      "description": "Converts the FFT frames to their complex conjugate (i.e. reverses the sign of their imaginary part). This is not usually a useful audio effect in itself, but may be a component of other analysis or transformation processes...",
      "related": [],
      "parent": "PV_MagSquared",
      "signalRange": null
    },
    "PV_Copy": {
      "name": "PV_Copy",
      "summary": "Copy an FFT buffer",
      "categories": "UGens>FFT",
      "rates": [],
      "args": [],
      "description": "Copies the spectral frame in bufferA to bufferB. This allows for parallel processing of spectral data without the need for multiple FFT UGens. Further it allows to extract data at a given point in the FFT chain e.g. for monitoring purposes. \n\n(Note: As of SC 3.7 instances of PV_Copy are added automatically where necessary for parallel processing. Please see Guides/FFT-Overview for the current implementation. \n\nThis document is provided for legacy purposes only. Existing code explicitly using PV_Copy should continue to work.)",
      "related": [],
      "parent": "PV_MagMul",
      "signalRange": null
    },
    "PV_CopyPhase": {
      "name": "PV_CopyPhase",
      "summary": "Copy magnitudes and phases.",
      "categories": "UGens>FFT",
      "rates": [],
      "args": [],
      "description": "Combines magnitudes of first input and phases of the second input.",
      "related": [
        "FFT",
        "IFFT",
        "PV_Add",
        "PV_MagMul",
        "PV_Max",
        "PV_Min",
        "PV_Mul"
      ],
      "parent": "PV_MagMul",
      "signalRange": null
    },
    "PV_Div": {
      "name": "PV_Div",
      "summary": "Complex division",
      "categories": "UGens>FFT",
      "rates": [],
      "args": [],
      "description": null,
      "related": [
        "PV_Mul",
        "PV_MagDiv"
      ],
      "parent": "PV_MagMul",
      "signalRange": null
    },
    "PV_HainsworthFoote": {
      "name": "PV_HainsworthFoote",
      "summary": "FFT onset detector.",
      "categories": "UGens>FFT",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "buffer",
          "default": null,
          "doc": "FFT buffer."
        },
        {
          "name": "proph",
          "default": 0,
          "doc": "What strength of detection signal from Hainsworth metric to use."
        },
        {
          "name": "propf",
          "default": 0,
          "doc": "What strength of detection signal from Foote metric to use. The\nFoote metric is normalised to (0..1)."
        },
        {
          "name": "threshold",
          "default": 1,
          "doc": "Threshold hold level for allowing a detection."
        },
        {
          "name": "waittime",
          "default": 0.04,
          "doc": "If triggered, minimum wait until a further frame can cause\nanother spot (useful to stop multiple detects on heavy signals).\n\nExamples::\n\n// just Hainsworth metric with low threshold\n(\nSynthDef(\\fftod, { |out|\n\tvar source1, detect;\n\tsource1 = SoundIn.ar(0);\n\tdetect = PV_HainsworthFoote.ar(FFT(LocalBuf(2048), source1), 1.0, 0.0);\n\tOut.ar(out, SinOsc.ar([440, 445], 0, Decay.ar(0.1 * detect, 0.1)));\n}).play(s);\n)\n\n// spot note transitions\n(\nSynthDef(\\fftod, { |out|\n\tvar source1, detect;\n\tsource1 = LFSaw.ar(LFNoise0.kr(1, 90, 400), 0, 0.5);\n\tdetect = PV_HainsworthFoote.ar(FFT(LocalBuf(2048), source1), 1.0, 0.0, 0.9, 0.5);\n\tOut.ar(out, Pan2.ar(source1, -1.0) + Pan2.ar(SinOsc.ar(440, 0, Decay.ar(0.1 * detect, 0.1)), 1.0));\n}).play(s);\n)\n\n// Foote solo - never triggers with threshold over 1.0, threshold under mouse control\n(\nSynthDef(\\fftod, { |out|\n\tvar source1, detect;\n\tsource1 = SoundIn.ar(0);\n\tdetect = PV_HainsworthFoote.ar(FFT(LocalBuf(2048), source1), 0.0, 1.0, MouseX.kr(0.0, 1.1), 0.02);\n\tOut.ar(out, Pan2.ar(source1, -1.0) + Pan2.ar(SinOsc.ar(440, 0, Decay.ar(0.1 * detect, 0.1)), 1.0));\n}).play(s);\n)\n\n// compare to Amplitude UGen\n(\nSynthDef(\\fftod, { |out|\n\t\tvar source1, detect;\n\t\tsource1 = SoundIn.ar(0);\n\t\tdetect = Amplitude.ar(source1) > MouseX.kr(0.0, 1.1);\n\t\tOut.ar(out, Pan2.ar(source1, -1.0) + Pan2.ar(SinOsc.ar(440, 0, Decay.ar(0.1 * detect, 0.1)), 1.0));\n\t}).play(s);\n)"
        }
      ],
      "description": "FFT onset detector based on work described in  Hainsworth, S. (2003) Techniques for the Automated Analysis of Musical Audio. PhD, University of Cambridge engineering dept. \nSee especially p128. The Hainsworth metric is a modification of the Kullback Liebler\ndistance.\n\nThe onset detector has general ability to spot spectral change, so may\nhave some ability to track chord changes  aside from obvious transient\njolts, but there's no guarantee it won't be confused by frequency\nmodulation artifacts.\n\nHainsworth metric on it's own gives good results but Foote might be\nuseful in some situations: experimental.",
      "related": [
        "PV_JensenAndersen"
      ],
      "parent": "PV_ChainUGen",
      "signalRange": null
    },
    "PV_JensenAndersen": {
      "name": "PV_JensenAndersen",
      "summary": "FFT feature detector for onset detection.",
      "categories": "UGens>FFT",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "buffer",
          "default": null,
          "doc": "FFT buffer."
        },
        {
          "name": "propsc",
          "default": 0.25,
          "doc": "Proportion of spectral centroid feature."
        },
        {
          "name": "prophfe",
          "default": 0.25,
          "doc": "Proportion of high frequency energy feature."
        },
        {
          "name": "prophfc",
          "default": 0.25,
          "doc": "Proportion of high frequency content feature."
        },
        {
          "name": "propsf",
          "default": 0.25,
          "doc": "Proportion of spectral flux feature."
        },
        {
          "name": "threshold",
          "default": 1,
          "doc": "Threshold level for allowing a detection."
        },
        {
          "name": "waittime",
          "default": 0.04,
          "doc": "If triggered, minimum wait until a further frame can cause\nanother spot (useful to stop multiple detects on heavy signals).\n\nExamples::\n\n(\nSynthDef(\\fftod, { |out|\n\tvar source1, detect, chain;\n\tsource1 = SoundIn.ar(0);\n\tchain = FFT(LocalBuf(2048), source1);\n\tdetect = PV_JensenAndersen.ar(chain, threshold: MouseX.kr(0.1, 1.0));\n\tOut.ar(out, SinOsc.ar([440, 445], 0, Decay.ar(0.1 * detect, 0.1)));\n}).play(s);\n)"
        }
      ],
      "description": "FFT feature detector for onset detection based on work described in\n\nJensen, K. & Andersen, T. H. (2003). Real-time Beat Estimation\nUsing Feature Extraction. In Proceedings of the Computer Music Modeling\nand Retrieval Symposium, Lecture Notes in Computer Science. Springer\nVerlag.\n\nFirst order derivatives of the features are taken.\nthreshold  may need to be set low to pick up on\nchanges.",
      "related": [
        "PV_HainsworthFoote"
      ],
      "parent": "PV_ChainUGen",
      "signalRange": null
    },
    "PV_LocalMax": {
      "name": "PV_LocalMax",
      "summary": "Pass bins which are a local maximum.",
      "categories": "UGens>FFT",
      "rates": [],
      "args": [],
      "description": "Passes only bins whose magnitude is above a threshold and above their nearest neighbors.",
      "related": [
        "FFT",
        "IFFT",
        "PV_MagAbove",
        "PV_MagBelow",
        "PV_MagClip"
      ],
      "parent": "PV_MagAbove",
      "signalRange": null
    },
    "PV_MagAllTimeAverage": {
      "name": "PV_MagAllTimeAverage",
      "summary": null,
      "categories": null,
      "rates": [],
      "args": [],
      "description": null,
      "related": [],
      "parent": "PV_MagSquared",
      "signalRange": null
    },
    "PV_MagBelow": {
      "name": "PV_MagBelow",
      "summary": "Pass bins below a threshold.",
      "categories": "UGens>FFT",
      "rates": [],
      "args": [],
      "description": "Passes only bins whose magnitude is below a threshold.",
      "related": [
        "FFT",
        "IFFT",
        "PV_MagAbove",
        "PV_LocalMax",
        "PV_MagClip"
      ],
      "parent": "PV_MagAbove",
      "signalRange": null
    },
    "PV_MagClip": {
      "name": "PV_MagClip",
      "summary": "Clip bins to a threshold.",
      "categories": "UGens>FFT",
      "rates": [],
      "args": [],
      "description": "Clips bin magnitudes to a maximum threshold.",
      "related": [
        "FFT",
        "IFFT",
        "PV_MagAbove",
        "PV_LocalMax",
        "PV_MagBelow"
      ],
      "parent": "PV_MagAbove",
      "signalRange": null
    },
    "PV_MagNoise": {
      "name": "PV_MagNoise",
      "summary": "Multiply magnitudes by noise.",
      "categories": "UGens>FFT",
      "rates": [],
      "args": [],
      "description": "Magnitudes are multiplied with noise.",
      "related": [
        "FFT",
        "IFFT"
      ],
      "parent": "PV_MagSquared",
      "signalRange": null
    },
    "PV_Max": {
      "name": "PV_Max",
      "summary": "Maximum magnitude.",
      "categories": "UGens>FFT",
      "rates": [],
      "args": [],
      "description": "Output copies bins with the maximum magnitude of the two inputs.",
      "related": [
        "FFT",
        "IFFT",
        "PV_Add",
        "PV_CopyPhase",
        "PV_MagMul",
        "PV_Min",
        "PV_Mul"
      ],
      "parent": "PV_MagMul",
      "signalRange": null
    },
    "PV_Min": {
      "name": "PV_Min",
      "summary": "Minimum magnitude.",
      "categories": "UGens>FFT",
      "rates": [],
      "args": [],
      "description": "Output copies bins with the minimum magnitude of the two inputs.",
      "related": [
        "FFT",
        "IFFT",
        "PV_Add",
        "PV_CopyPhase",
        "PV_MagMul",
        "PV_Max",
        "PV_Mul"
      ],
      "parent": "PV_MagMul",
      "signalRange": null
    },
    "PV_Mul": {
      "name": "PV_Mul",
      "summary": "Complex multiply.",
      "categories": "UGens>FFT",
      "rates": [],
      "args": [],
      "description": "Complex Multiplication:\n\n(RealA * RealB) - (ImagA * ImagB),\n(ImagA * RealB) + (RealA * ImagB)",
      "related": [
        "FFT",
        "IFFT",
        "PV_Add",
        "PV_CopyPhase",
        "PV_MagMul",
        "PV_Max",
        "PV_Min"
      ],
      "parent": "PV_MagMul",
      "signalRange": null
    },
    "PV_PhaseShift270": {
      "name": "PV_PhaseShift270",
      "summary": "Shift phase by 270 degrees.",
      "categories": "UGens>FFT",
      "rates": [],
      "args": [],
      "description": "Shift phase of all bins by 270 degrees.",
      "related": [
        "FFT",
        "IFFT",
        "PV_PhaseShift",
        "PV_PhaseShift90",
        "PV_Diffuser"
      ],
      "parent": "PV_MagSquared",
      "signalRange": null
    },
    "PV_PhaseShift90": {
      "name": "PV_PhaseShift90",
      "summary": "Shift phase by 90 degrees.",
      "categories": "UGens>FFT",
      "rates": [],
      "args": [],
      "description": "Shift phase of all bins by 90 degrees.",
      "related": [
        "FFT",
        "IFFT",
        "PV_PhaseShift",
        "PV_PhaseShift270",
        "PV_Diffuser"
      ],
      "parent": "PV_MagSquared",
      "signalRange": null
    },
    "PV_Scope": {
      "name": "PV_Scope",
      "summary": null,
      "categories": null,
      "rates": [],
      "args": [],
      "description": null,
      "related": [],
      "parent": "PV_ChainUGen",
      "signalRange": null
    },
    "PV_TimeAverageScope": {
      "name": "PV_TimeAverageScope",
      "summary": null,
      "categories": null,
      "rates": [],
      "args": [],
      "description": null,
      "related": [],
      "parent": "PV_Scope",
      "signalRange": null
    },
    "PV_TimeSmear": {
      "name": "PV_TimeSmear",
      "summary": null,
      "categories": null,
      "rates": [],
      "args": [],
      "description": null,
      "related": [],
      "parent": "PV_MagSmear",
      "signalRange": null
    },
    "Pan2": {
      "name": "Pan2",
      "summary": "Two channel equal power pan.",
      "categories": "UGens>Multichannel>Panners",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "The input signal."
        },
        {
          "name": "pos",
          "default": 0,
          "doc": "Pan position, -1 is left, +1 is right."
        },
        {
          "name": "level",
          "default": 1,
          "doc": "A control rate level input.\n\nExamples::\n\n// hear the difference, LinPan having a slight drop in the middle...\n{ LinPan2.ar(SinOsc.ar(440), Line.kr(-1, 1, 5)) }.play\n\n// ... whereas Pan2 is more smooth\n{ Pan2.ar(SinOsc.ar(440), Line.kr(-1, 1, 5)) }.play\n\n// other examples\n{ Pan2.ar(PinkNoise.ar(0.4), FSinOsc.kr(2), 0.3) }.play;"
        }
      ],
      "description": "Two channel equal power panner. Pan2 takes the square root of the linear scaling factor going from 1 (left or right) to 0.5.sqrt (~=0.707) in the center, which is about 3dB reduction. With linear panning (LinPan2) the signal is lowered as it approaches center using a straight line from 1 (left or right) to 0.5 (center) for a 6dB reduction in the middle. A problem inherent to linear panning is that the perceived volume of the signal drops in the middle. Pan2 solves this.",
      "related": [
        "Balance2",
        "LinPan2",
        "Pan4",
        "PanAz"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "Pan4": {
      "name": "Pan4",
      "summary": "Four channel equal power pan.",
      "categories": "UGens>Multichannel>Panners",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "The input signal."
        },
        {
          "name": "xpos",
          "default": 0,
          "doc": "X  pan position from -1 to +1 (left to right)."
        },
        {
          "name": "ypos",
          "default": 0,
          "doc": "Y pan position from -1 to +1 (back to front)."
        },
        {
          "name": "level",
          "default": 1,
          "doc": "A control rate level input.\n\nExamples::\n\n// You'll only hear the front two channels on a stereo setup.\n\n{ Pan4.ar(PinkNoise.ar, FSinOsc.kr(2), FSinOsc.kr(1.2), 0.3)) }.play;\n\n{ Pan4.ar(PinkNoise.ar, -1,  0, 0.3) }.play; // left pair\n{ Pan4.ar(PinkNoise.ar,  1,  0, 0.3) }.play; // right pair\n{ Pan4.ar(PinkNoise.ar,  0, -1, 0.3) }.play; // back pair\n{ Pan4.ar(PinkNoise.ar,  0,  1, 0.3) }.play; // front pair\n\n{ Pan4.ar(PinkNoise.ar,  0,  0, 0.3) }.play; // center"
        }
      ],
      "description": "Four channel equal power panner. Outputs are in order LeftFront,\nRightFront, LeftBack, RightBack.",
      "related": [
        "Balance2",
        "LinPan2",
        "Pan2",
        "PanAz"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "PanAz": {
      "name": "PanAz",
      "summary": "Azimuth panner",
      "categories": "UGens>Multichannel>Panners",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "numChans",
          "default": null,
          "doc": "Number of output channels. Must be a nonzero, positive integer. This is fixed when the SynthDef is compiled so cannot be assigned to a SynthDef argument."
        },
        {
          "name": "in",
          "default": null,
          "doc": "The input signal."
        },
        {
          "name": "pos",
          "default": 0,
          "doc": "pan position (kr or ar). Channels are evenly spaced over a cyclic period of 2.0 in pos with 0.0 equal to channel zero and 2.0/numChans equal to channel 1, 4.0/numChans equal to channel 2, etc.\n\nThus all channels will be cyclically panned through if a bipolar sawtooth wave from -1 to +1 is used to modulate the pos."
        },
        {
          "name": "level",
          "default": 1,
          "doc": "A control rate level input."
        },
        {
          "name": "width",
          "default": 2,
          "doc": "The width of the panning envelope.\nNominally this is 2.0 which pans between pairs of adjacent speakers.\nValues greater than 2 will spread the pan over greater numbers of speakers.\nValues less than 1 will leave silent gaps between speakers.\nThe absolute of this value is taken as negative values have no meaning (a width of -1 is the same as a width of 1)."
        },
        {
          "name": "orientation",
          "default": 0.5,
          "doc": "Should be 0 if the front is a vertex of the spanning polygon.\nThe first speaker will be directly in front. Should be 0.5 if the front\nbisects a side of the spanning polygon.\nThen the first speaker will be the one left of center."
        }
      ],
      "description": "Multichannel equal power panner.",
      "related": [
        "Balance2",
        "LinPan2",
        "Pan2",
        "Pan4"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "PanB": {
      "name": "PanB",
      "summary": "Ambisonic B-format panner.",
      "categories": "UGens>Multichannel>Ambisonics",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "The input signal."
        },
        {
          "name": "azimuth",
          "default": 0,
          "doc": "Azimuth in radians, -π to +π."
        },
        {
          "name": "elevation",
          "default": 0,
          "doc": "Elevation in radians, -0.5π to +0.5π."
        },
        {
          "name": "gain",
          "default": 1,
          "doc": "A control rate level input.\n\nExamples::\n\n// You'll only hear the first two channels on a stereo setup.\nplay({\n\t#w, x, y, z = PanB.ar(WhiteNoise.ar, LFSaw.kr(0.5, pi), FSinOsc.kr(0.31, 0.5pi), 0.3);\n\t// decode for 4 channels\n\tDecodeB2.ar(4, w, x, y, 0.5);\n});"
        }
      ],
      "description": "Ambisonic B format panner. Output channels are in order W, X, Y, Z.",
      "related": [
        "BiPanB2",
        "DecodeB2",
        "PanB2",
        "Rotate2"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "PanB2": {
      "name": "PanB2",
      "summary": "2D Ambisonic B-format panner.",
      "categories": "UGens>Multichannel>Ambisonics",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "The input signal."
        },
        {
          "name": "azimuth",
          "default": 0,
          "doc": "Position around the circle from -1 to +1. -1 is behind, -0.5 is\nleft, 0 is forward, +0.5 is right, +1 is behind."
        },
        {
          "name": "gain",
          "default": 1,
          "doc": "Amplitude control.\n\nExamples::\n\n(\n{\n\tvar w, x, y, p, a, b, c, d;\n\n\tp = PinkNoise.ar; // source\n\n\t// B-format encode\n\t#w, x, y = PanB2.ar(p, MouseX.kr(-1, 1), 0.1);\n\n\t// B-format decode to quad\n\t#a, b, c, d = DecodeB2.ar(4, w, x, y);\n\n\t[a, b, d, c] // reorder to my speaker arrangement: Lf Rf Lr Rr\n}.play;\n)"
        }
      ],
      "description": "Encodes a mono signal to 2-dimensional ambisonic B-format.",
      "related": [
        "BiPanB2",
        "DecodeB2",
        "PanB",
        "Rotate2"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "PartConv": {
      "name": "PartConv",
      "summary": "Real-time partitioned convolution",
      "categories": "UGens>FFT, UGens>Convolution",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": null
        },
        {
          "name": "fftsize",
          "default": null,
          "doc": null
        },
        {
          "name": "irbufnum",
          "default": null,
          "doc": null
        }
      ],
      "description": "Partitioned convolution. Various additional buffers must be supplied.\n\nMono impulse response only! If inputting multiple channels, you'll need independent PartConvs, one for each channel.\n\nBut the charm is: impulse response can be as large as you like (CPU load increases with IR size. Various tradeoffs based on fftsize choice, due to rarer but larger FFTs. This plug-in uses amortisation to spread processing and avoid spikes).\n\nNormalisation factors difficult to anticipate; convolution piles up multiple copies of the input on top of itself, so can easily overload.",
      "related": [
        "Convolution",
        "Convolution2",
        "Convolution2L",
        "Convolution3"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Pause": {
      "name": "Pause",
      "summary": "When triggered, pauses a node.",
      "categories": "UGens>Synth control",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "gate",
          "default": null,
          "doc": "When gate is 0, node is paused, when 1 it runs."
        },
        {
          "name": "id",
          "default": null,
          "doc": "Node to be paused.\n\nExamples::\n\ns.boot;\n\nSynthDef(\\a, { Out.ar(0, SinOsc.ar(800, 0, 0.2)) }).add;\n\nSynthDef(\\b, { |gate = 1| Out.ar(1, PinkNoise.ar(0.3)); Pause.kr(gate, 1001) }).add;\n\ns.sendMsg(\\s_new, \\a, 1001, 0, 0);\n\ns.sendMsg(\\s_new, \\b, 1002, 0, 0);\n\ns.sendMsg(\\n_set, 1002, \\gate, 0);\n\ns.sendMsg(\\n_set, 1002, \\gate, 1);"
        }
      ],
      "description": "When triggered, pauses a node.",
      "related": [
        "Free"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "PauseSelf": {
      "name": "PauseSelf",
      "summary": "When triggered, pause enclosing synth.",
      "categories": "UGens>Synth control",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "The input signal.\n\nExamples::\n\n(\nSynthDef(\"pauseSelf-help\", { |out, t_trig|\n\tPauseSelf.kr(t_trig);\n\tOut.ar(out, SinOsc.ar(400, 0, 0.2));\n}).add;\n)\n\ns.sendMsg(\"/s_new\", \"pauseSelf-help\", 1731);\ns.sendMsg(\"/n_set\", 1731, \\t_trig, 1);\ns.sendMsg(\"/n_run\", 1731, 1);\ns.sendMsg(\"/n_set\", 1731, \\t_trig, 1);\ns.sendMsg(\"/n_free\", 1731);"
        }
      ],
      "description": "Pause enclosing synth when input signal crosses from non-positive to\npositive.",
      "related": [
        "FreeSelf"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "PauseSelfWhenDone": {
      "name": "PauseSelfWhenDone",
      "summary": "FIXME: PauseSelfWhenDone purpose.",
      "categories": "UGens>Synth control, UGens>Undocumented",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "src",
          "default": null,
          "doc": "FIXME: explain parameter src."
        }
      ],
      "description": "FIXME: PauseSelfWhenDone description.",
      "related": [
        "Done",
        "FreeSelfWhenDone"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Peak": {
      "name": "Peak",
      "summary": "Track peak signal amplitude.",
      "categories": "UGens>Analysis>Amplitude",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "trig",
          "default": 0,
          "doc": "Trigger. Resets the output value to the current input value. A trigger happens when the signal changes from non-positive to positive.\n\nExamples::\n\n(\n{\n\tSinOsc.ar(\n\t\t\tPeak.ar(Dust.ar(20), Impulse.ar(0.4)) * 500 + 200,\n\t\t\t0, 0.2\n\t)\n\n}.play;\n)\n\n// follow a sine lfo, reset rate controlled by mouse x\n(\n{\n\tSinOsc.ar(\n\t\t\tPeak.kr(SinOsc.kr(0.2), Impulse.kr(MouseX.kr(0.01, 2, 1))) * 500 + 200,\n\t\t\t0, 0.2\n\t)\n\n}.play;\n)"
        }
      ],
      "description": "Outputs the peak amplitude of the signal received at the input. When\na trigger occurs at the  reset  input, the maximum\noutput value is reset to the current value.\n\nThe reported peak will always be positive, i.e. the absolute value \nof the signal at its peak amplitude, even when that peak is negative.\nTo obtain the minimum and maximum values of the signal as is, use the\nRunningMin  and  RunningMax  UGens.",
      "related": [
        "PeakFollower"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "PeakFollower": {
      "name": "PeakFollower",
      "summary": "Track peak signal amplitude.",
      "categories": "UGens>Analysis>Amplitude",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "decay",
          "default": 0.999,
          "doc": "Decay factor.\n\nExamples::\n\ns.boot;\n\n// no decay\n(\n{\n\tSinOsc.ar(\n\t\t\tPeakFollower.ar(Dust.ar(20, Line.kr(0, 1, 4)), 1.0) * 1500 + 200,\n\t\t\t0, 0.2\n\t)\n\n}.play;\n)\n\n// a little decay\n(\n{\n\tSinOsc.ar(\n\t\t\tPeakFollower.ar(Dust.ar(20, Line.kr(0, 1, 4)), 0.999) * 1500 + 200,\n\t\t\t0, 0.2\n\t)\n\n}.play;\n)\n\n// mouse x controls decay, center of the\n(\n{\n\tvar decay;\n\tdecay = MouseX.kr(0.99, 1.00001).min(1.0);\n\tSinOsc.ar(\n\t\t\tPeakFollower.ar(Dust.ar(20), decay) * 1500 + 200,\n\t\t\t0, 0.2\n\t);\n\n}.play;\n)\n\n// follow a sine lfo, decay controlled by mouse x\n(\n{\n\tvar decay;\n\tdecay = MouseX.kr(0, 1.1).min(1.0);\n\tSinOsc.ar(\n\t\t\tPeakFollower.kr(SinOsc.kr(0.2), decay) * 200 + 500,\n\t\t\t0, 0.2\n\t)\n\n}.play;\n)"
        }
      ],
      "description": "Outputs the peak amplitude of the signal received at the input. If level\nis below maximum, the level decreases by the factor given in\ndecay .\n\nInternally, the absolute value of the signal is used, to prevent\nunderreporting the peak value if there is a negative DC offset. To obtain\nthe minimum and maximum values of the signal as is, use the\nRunningMin  and  RunningMax  UGens.",
      "related": [
        "Peak"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Phasor": {
      "name": "Phasor",
      "summary": "A resettable linear ramp between two levels.",
      "categories": "UGens>Triggers, UGens>Buffer",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "trig",
          "default": 0,
          "doc": "When triggered, jump to resetPos (default: 0, equivalent to\nstart)."
        },
        {
          "name": "rate",
          "default": 1,
          "doc": "The amount of change per sample, i.e at a rate of 1 the value of\neach sample will be 1 greater than the preceding sample."
        },
        {
          "name": "start",
          "default": 0,
          "doc": "Start point of the ramp."
        },
        {
          "name": "end",
          "default": 1,
          "doc": "End point of the ramp."
        },
        {
          "name": "resetPos",
          "default": 0,
          "doc": "The value to jump to upon receiving a trigger.\n\nExamples::\n\n// basic: ramp between 'start' and 'end'\n// note that the ramp ends at 9, not 10\n{ Phasor.kr(0, 1, start: 0, end: 10) }.plot(0.03).plotMode_(\\dlines)\n\n// on trigger: ramp jumps to 'resetPos', goes until 'end' and wraps back to 'start'\n// note that the ramp starts from 'resetPos', since it receives a trigger immediately on its first sample\n(\n{\n\tvar trig = Impulse.kr(ControlRate.ir/5);\n\tvar ramp = Phasor.kr(trig, 1, start: 0, end: 10, resetPos: 7);\n\t[ramp, trig * 10]\n}.plot(0.03).plotMode_([\\dlines, \\dstems])\n)\n\n// phasor controls sine frequency: end frequency matches a second sine wave.\n\n(\n{ var trig, rate, x, sr;\n\trate = MouseX.kr(0.2, 2, 1);\n\ttrig = Impulse.ar(rate);\n\tsr = SampleRate.ir;\n\tx = Phasor.ar(trig, rate / sr);\n\tSinOsc.ar(\n\t\t[\n\t\t\tLinLin.kr(x, 0, 1, 600, 1000), // convert range from 0..1 to 600..1000\n\t\t\t1000 // constant second frequency\n\t\t], 0, 0.2)\n\n}.play;\n)\n\n// two phasors control two sine frequencies: mouse y controls resetPos of the second\n(\n{ var trig, rate, x, sr;\n\trate = MouseX.kr(1, 200, 1);\n\ttrig = Impulse.ar(rate);\n\tsr = SampleRate.ir;\n\tx = Phasor.ar(trig, rate / sr, 0, 1, [0, MouseY.kr(0, 1)]);\n\tSinOsc.ar(x * 500 + 500, 0, 0.2)\n}.play;\n)\n\n// use phasor to index into a sound file\n\n// allocate a buffer with a sound file\nb = Buffer.read(s, ExampleFiles.child);\n\n// simple playback (more examples: see BufRd)\n// Start and end here are defined as 0 and the number of frames in the buffer.\n// This means that the Phasor will output values from 0 to numFrames - 1 before looping,\n// which is perfect for driving BufRd. (See note above)\n{ BufRd.ar(1, b.bufnum, Phasor.ar(0, BufRateScale.kr(b.bufnum), 0, BufFrames.kr(b.bufnum))) }.play;\n\n// two phasors control two sound file positions: mouse y controls resetPos of the second\n(\n{ var trig, rate, framesInBuffer;\n\trate = MouseX.kr(0.1, 100, 1);\n\ttrig = Impulse.ar(rate);\n\tframesInBuffer = BufFrames.kr(b.bufnum);\n\tx = Phasor.ar(trig, BufRateScale.kr(b.bufnum), 0, framesInBuffer,\n\t\t[0, MouseY.kr(0, framesInBuffer)]);\n\tBufRd.ar(1, b.bufnum, x);\n}.play;\n)"
        }
      ],
      "description": "Phasor is a linear ramp between start and end values. When its trigger\ninput crosses from non-positive to positive, Phasor's output will jump to\nits reset position. Upon reaching the end of its ramp Phasor will wrap\nback to its start.\n\n(Note: \nN.B. Since end is defined as the wrap point, its value is never\nactually output.\n)\n\n(Note: \nIf one wants Phasor to output a signal with frequency teletype)freq:: oscillating between teletype::start:: and teletype::end::, then the rate should be teletype::(end - start) * freq / sr:: where teletype::sr:: is the sampling rate.\n\nPhasor is commonly used as an index control with BufRd and BufWr.",
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "PinkNoise": {
      "name": "PinkNoise",
      "summary": "Pink Noise.",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [],
      "description": "Generates noise whose spectrum falls off in power by 3 dB per octave, which gives equal power over the span of each octave.\nThis version is band-limited to 8 octaves.\n\nInternally, this UGen calculates its output by means of the Voss-McCartney algorithm.\nlink::http://www.firstpr.com.au/dsp/pink-noise/allan-2/spectrum2.html::\n\n(Note: \nThe values produced by this UGen were observed to lie with very high probability between approximately -0.65 and +0.81 (before being multiplied by mul). The signal's RMS is approximately -16 dB.\n)",
      "related": [
        "BrownNoise",
        "GrayNoise",
        "ClipNoise",
        "WhiteNoise"
      ],
      "parent": "WhiteNoise",
      "signalRange": null
    },
    "Pitch": {
      "name": "Pitch",
      "summary": "Autocorrelation pitch follower",
      "categories": "UGens>Analysis>Pitch",
      "rates": [
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": null
        },
        {
          "name": "initFreq",
          "default": 440,
          "doc": null
        },
        {
          "name": "minFreq",
          "default": 60,
          "doc": null
        },
        {
          "name": "maxFreq",
          "default": 4000,
          "doc": null
        },
        {
          "name": "execFreq",
          "default": 100,
          "doc": null
        },
        {
          "name": "maxBinsPerOctave",
          "default": 16,
          "doc": null
        },
        {
          "name": "median",
          "default": 1,
          "doc": null
        },
        {
          "name": "ampThreshold",
          "default": 0.01,
          "doc": null
        },
        {
          "name": "peakThreshold",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "downSample",
          "default": 1,
          "doc": null
        },
        {
          "name": "clar",
          "default": 0,
          "doc": null
        }
      ],
      "description": "This is a better pitch follower than ZeroCrossing, but more costly of CPU. For most purposes the default settings can be used and only in needs to be supplied. Pitch returns two values (via an Array of OutputProxys, see the OutputProxy help file), a freq which is the pitch estimate and hasFreq, which tells whether a pitch was found. Some vowels are still problematic, for instance a wide open mouth sound somewhere between a low pitched short 'a' sound as in 'sat', and long 'i' sound as in 'fire', contains enough overtone energy to confuse the algorithm.",
      "related": [],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "PitchShift": {
      "name": "PitchShift",
      "summary": "Time domain pitch shifter.",
      "categories": "UGens>Filters>Pitch",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "windowSize",
          "default": 0.2,
          "doc": "The size of the grain window in seconds. This value cannot be\nmodulated. The minimum value is 3 sample periods. If you supply a smaller\nvalue, it will be rounded up to the minimum."
        },
        {
          "name": "pitchRatio",
          "default": 1,
          "doc": "The ratio of the pitch shift. Must be from 0 to 4."
        },
        {
          "name": "pitchDispersion",
          "default": 0,
          "doc": "The maximum random deviation of the pitch from the\n\npitchRatio ."
        },
        {
          "name": "timeDispersion",
          "default": 0,
          "doc": "A random offset from zero to timeDispersion seconds is added to the\ndelay of each grain. Use of some dispersion can alleviate a hard\ncomb filter effect due to uniform grain placement. It can also be\nan effect in itself.\ntimeDispersion can be no larger than windowSize."
        }
      ],
      "description": "A time domain granular pitch shifter. Grains have a triangular amplitude\nenvelope and an overlap of 4:1, and use linear interpolation of the buffer.",
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "PlayBuf": {
      "name": "PlayBuf",
      "summary": "Sample playback oscillator.",
      "categories": "UGens>Buffer",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "numChannels",
          "default": null,
          "doc": "Number of channels that the buffer will be. This must be a fixed\ninteger. The architecture of the SynthDef cannot change after it\nis compiled."
        },
        {
          "name": "bufnum",
          "default": 0,
          "doc": "The index of the buffer to use.\n(Note: \nIf you supply a bufnum of a buffer with a differing number of channels\nthan the one specified in this PlayBuf, it will post a warning and output the channels it can.\n)"
        },
        {
          "name": "rate",
          "default": 1,
          "doc": "1.0 is the server's sample rate, 2.0 is one octave up, 0.5 is one\noctave down -1.0 is backwards normal rate… etc. Interpolation\nis cubic."
        },
        {
          "name": "trigger",
          "default": 1,
          "doc": "A trigger causes a jump to the startPos. A trigger occurs when a\nsignal changes from negative value to positive value."
        },
        {
          "name": "startPos",
          "default": 0,
          "doc": "Sample frame to start playback."
        },
        {
          "name": "loop",
          "default": 0,
          "doc": "1 means true, 0 means false. This is modulateable."
        },
        {
          "name": "doneAction",
          "default": 0,
          "doc": null
        }
      ],
      "description": "Plays back a sample resident in memory.",
      "related": [
        "RecordBuf",
        "DiskIn",
        "BufRd"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "Pluck": {
      "name": "Pluck",
      "summary": "A Karplus-Strong UGen",
      "categories": "UGens>Delays",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": null
        },
        {
          "name": "trig",
          "default": 1,
          "doc": null
        },
        {
          "name": "maxdelaytime",
          "default": 0.2,
          "doc": null
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": null
        },
        {
          "name": "decaytime",
          "default": 1,
          "doc": null
        },
        {
          "name": "coef",
          "default": 0.5,
          "doc": null
        }
      ],
      "description": "A Karplus-Strong UGen",
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "Poll": {
      "name": "Poll",
      "summary": "Print the current output value of a UGen",
      "categories": "UGens>Info",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "trig",
          "default": null,
          "doc": "a non-positive to positive transition telling Poll to return a value"
        },
        {
          "name": "in",
          "default": null,
          "doc": "the signal you want to poll"
        },
        {
          "name": "label",
          "default": null,
          "doc": "a string or symbol to be printed with the polled value"
        },
        {
          "name": "trigid",
          "default": -1,
          "doc": "if greater then 0, a '/tr' message is sent back to the client (similar to SendTrig)"
        }
      ],
      "description": "Print the current output value of a UGen, useful for debugging SynthDefs.\n\nWARNING:: Printing values from the Server in intensive for the CPU. Poll should be used for debugging purposes.::",
      "related": [
        "SendTrig",
        "OSCFunc"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Pulse": {
      "name": "Pulse",
      "summary": "Band limited pulse wave.",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 440,
          "doc": "Frequency in Hertz."
        },
        {
          "name": "width",
          "default": 0.5,
          "doc": "Pulse width ratio from zero to one. 0.5 makes a square wave."
        }
      ],
      "description": "Band limited pulse wave generator with pulse width modulation.",
      "related": [
        "LFPulse"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "PulseCount": {
      "name": "PulseCount",
      "summary": "Pulse counter.",
      "categories": "UGens>Triggers",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "trig",
          "default": 0,
          "doc": "Trigger. Trigger can be any signal. A trigger happens when the\nsignal changes from non-positive to positive."
        },
        {
          "name": "reset",
          "default": 0,
          "doc": "Resets the counter to zero when triggered.\n\nExamples::\n\nSynthDef(\"help-PulseCount\", { |out = 0|\n\tOut.ar(out,\n\t\tSinOsc.ar(\n\t\t\tPulseCount.ar(Impulse.ar(10), Impulse.ar(0.4)) * 200,\n\t\t\t0, 0.05\n\t\t)\n\t)\n}).play;"
        }
      ],
      "description": "Each trigger increments a counter which is output as a signal.",
      "related": [
        "Stepper"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "PulseDivider": {
      "name": "PulseDivider",
      "summary": "Pulse divider.",
      "categories": "UGens>Triggers",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "trig",
          "default": 0,
          "doc": "Trigger. Trigger can be any signal. A trigger happens when the\nsignal changes from non-positive to positive."
        },
        {
          "name": "div",
          "default": 2,
          "doc": "Number of triggers to count before outputting an impulse."
        },
        {
          "name": "start",
          "default": 0,
          "doc": "Starting value for the trigger count. This lets you start\nsomewhere in the middle of a count. If start is negative\nit adds that many counts to the first time the output is\ntriggered.\n\nExamples::\n\nSynthDef(\"help-PulseDivider\", { |out = 0|\n\tvar p, a, b;\n\tp = Impulse.ar(8);\n\ta = SinOsc.ar(1200, 0, Decay2.ar(p, 0.005, 0.1));\n\tb = SinOsc.ar(600, 0, Decay2.ar(PulseDivider.ar(p, 4), 0.005, 0.5));\n\n\tOut.ar(out, (a + b) * 0.4)\n}).play;"
        }
      ],
      "description": "Outputs one impulse each time it receives a certain number of triggers at\nits input.",
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "QuadC": {
      "name": "QuadC",
      "summary": "General quadratic map chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "a",
          "default": 1,
          "doc": null
        },
        {
          "name": "b",
          "default": -1,
          "doc": null
        },
        {
          "name": "c",
          "default": -0.75,
          "doc": null
        },
        {
          "name": "xi",
          "default": 0,
          "doc": null
        }
      ],
      "description": "A cubic-interpolating sound generator based on the difference equation:\n\nteletype::\n\tx(n+1) = a * x(n)^2 + b * x(n) + c\n\nsclang code translation:\n\n(\nvar a = 1, b = -1, c = -0.75, xi = 0, size = 64;\nplot(size.collect { xi = (a * (xi ** 2)) + (b * xi) + c; xi });\n)",
      "related": [
        "QuadN",
        "QuadL"
      ],
      "parent": "QuadN",
      "signalRange": null,
      "inheritedFrom": "QuadN"
    },
    "QuadL": {
      "name": "QuadL",
      "summary": "General quadratic map chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "a",
          "default": 1,
          "doc": null
        },
        {
          "name": "b",
          "default": -1,
          "doc": null
        },
        {
          "name": "c",
          "default": -0.75,
          "doc": null
        },
        {
          "name": "xi",
          "default": 0,
          "doc": null
        }
      ],
      "description": "A linear-interpolating sound generator based on the difference equation:\n\nteletype::\n\tx(n+1) = a * x(n)^2 + b * x(n) + c\n\nsclang code translation:\n\n(\nvar a = 1, b = -1, c = -0.75, xi = 0, size = 64;\nplot(size.collect { xi = (a * (xi ** 2)) + (b * xi) + c; xi });\n)",
      "related": [
        "QuadC",
        "QuadN"
      ],
      "parent": "QuadN",
      "signalRange": null,
      "inheritedFrom": "QuadN"
    },
    "QuadN": {
      "name": "QuadN",
      "summary": "General quadratic map chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "a",
          "default": 1,
          "doc": null
        },
        {
          "name": "b",
          "default": -1,
          "doc": null
        },
        {
          "name": "c",
          "default": -0.75,
          "doc": null
        },
        {
          "name": "xi",
          "default": 0,
          "doc": null
        }
      ],
      "description": "A non-interpolating sound generator based on the difference equation:\n\nteletype::\n        x(n+1) = a * x(n)^2 + b * x(n) + c\n\nsclang code translation:\n\n(\nvar a = 1, b = -1, c = -0.75, xi = 0, size = 64;\nplot(size.collect { xi = (a * (xi ** 2)) + (b * xi) + c; xi });\n)",
      "related": [
        "QuadL",
        "QuadC"
      ],
      "parent": "ChaosGen",
      "signalRange": null
    },
    "RHPF": {
      "name": "RHPF",
      "summary": "A resonant high pass filter.",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "freq",
          "default": 440,
          "doc": "Cutoff frequency in Hertz.\nWARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!"
        },
        {
          "name": "rq",
          "default": 1,
          "doc": "The reciprocal of Q (bandwidth / cutoffFreq)."
        }
      ],
      "description": "A resonant high pass filter.",
      "related": [
        "Formlet",
        "RLPF",
        "Resonz",
        "Ringz"
      ],
      "parent": "RLPF",
      "signalRange": null,
      "inheritedFrom": "RLPF"
    },
    "RLPF": {
      "name": "RLPF",
      "summary": "A resonant low pass filter.",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "freq",
          "default": 440,
          "doc": "Cutoff frequency in Hertz.\nWARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!"
        },
        {
          "name": "rq",
          "default": 1,
          "doc": "The reciprocal of Q (bandwidth / cutoffFreq)."
        }
      ],
      "description": "A resonant low pass filter.",
      "related": [
        "Formlet",
        "RHPF",
        "Resonz",
        "Ringz"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "RadiansPerSample": {
      "name": "RadiansPerSample",
      "summary": "Number of radians per sample.",
      "categories": "UGens>Info",
      "rates": [
        "ir"
      ],
      "args": [],
      "description": "Returns the number of radians per sample.",
      "related": [
        "ControlRate",
        "SampleDur",
        "SampleRate",
        "SubsampleOffset"
      ],
      "parent": "InfoUGenBase",
      "signalRange": null
    },
    "Ramp": {
      "name": "Ramp",
      "summary": "Break a continuous signal into line segments",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "lagTime",
          "default": 0.1,
          "doc": "segment duration in seconds."
        }
      ],
      "description": "Break a continuous signal into linearly interpolated segments with specific durations.\n\nFeeding Ramp with noise is similar to LFNoise1\n\nRamp.kr(WhiteNoise.kr(1), 0.5)\n\nis equal to:\n\nLFNoise1.kr(1 / 0.5)\n\nFor smoothing out control signals, take a look at Lag and VarLag",
      "related": [
        "Lag",
        "VarLag",
        "Slew"
      ],
      "parent": "Lag",
      "signalRange": null,
      "inheritedFrom": "Lag"
    },
    "RandID": {
      "name": "RandID",
      "summary": "Set the synth's random generator ID.",
      "categories": "UGens>Generators>Stochastic, UGens>Random",
      "rates": [
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "id",
          "default": 0,
          "doc": "The random number generator ID.\n\nExamples::\n\n// start a noise patch and set the id of the generator\n(\nSynthDef(\"help-RandID\", { |out = 0, id = 1|\n\tRandID.ir(id);\n\tOut.ar(out,\n\t\tWhiteNoise.ar(0.05) + Dust2.ar(70)\n\t)\n}).add;\n)\n\n// reset the seed of my rgen at a variable rate\n(\nSynthDef(\"help-RandSeed\", { |seed = 1910, id = 1|\n\t\tRandID.kr(id);\n\t\tRandSeed.kr(Impulse.kr(FSinOsc.kr(0.2, 0, 10, 11)), seed);\n}).add;\n\n)\n\n// start two noise synths on left and right channel with a different randgen id\na = Synth(\"help-RandID\", [\\out, 0, \\id, 1]);\nb = Synth(\"help-RandID\", [\\out, 1, \\id, 2]);\n\n// reset the seed of randgen 1\nx = Synth(\"help-RandSeed\", [\\id, 1]);\n\n// change the target randgen to 2 (affects right channel)\nx.set(\\id, 2);"
        }
      ],
      "description": "Choose which random number generator to use for this synth.\nAll synths that use the same generator reproduce the same sequence\nof numbers when the same seed is set again.",
      "related": [
        "RandSeed"
      ],
      "parent": "WidthFirstUGen",
      "signalRange": null
    },
    "RandSeed": {
      "name": "RandSeed",
      "summary": "Sets the synth's random generator seed.",
      "categories": "UGens>Generators>Stochastic, UGens>Random",
      "rates": [
        "ar",
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "trig",
          "default": 0,
          "doc": "The trigger. Trigger can be any signal. A trigger happens when\nthe signal changes from non-positive to positive."
        },
        {
          "name": "seed",
          "default": 56789,
          "doc": "The random seed.\n\nExamples::\n\n// start a noise patch\n\n(\n{\nvar noise, filterfreq;\nnoise = WhiteNoise.ar(0.05 ! 2) + Dust2.ar(70 ! 2);\nfilterfreq = LFNoise1.kr(3, 5500, 6000);\nResonz.ar(noise * 5, filterfreq, 0.5) + (noise * 0.5)\n}.play;\n)\n\n// reset the seed at a variable rate\n(\nx = { |seed = 1956|\n\t\tRandSeed.kr(Impulse.kr(MouseX.kr(0.1, 100)), seed);\n}.play;\n)\n\nx.set(\\seed, 2001);\nx.set(\\seed, 1798);\nx.set(\\seed, 1902);\n\n// above you can see that the sound of the LFNoise1 is not exactly reproduced (filter frequency)\n// this is due to interference between the internal phase of the noise ugen and the\n// seed setting rate.\n\n// a solution is to start a new synth:\n\n(\nSynthDef(\"pseudorandom\", { |out, sustain = 1, seed = 1967, id = 0|\n\tvar noise, filterfreq;\n\tRandID.ir(id);\n\tRandSeed.ir(1, seed);\n\n\tnoise = WhiteNoise.ar(0.05 ! 2) + Dust2.ar(70 ! 2);\n\tfilterfreq = LFNoise1.kr(3, 5500, 6000);\n\n\tOut.ar(out,\n\t\tResonz.ar(noise * 5, filterfreq, 0.5) + (noise * 0.5)\n\t\t*\n\t\tLine.kr(1, 0, sustain, doneAction: Done.freeSelf)\n\t)\n\n}).add;\n)\n\n// the exact same sound is reproduced\n(\nfork {\n\tloop {\n\t\tSynth(\"pseudorandom\");\n\t\t1.1.wait; // wait a bit longer than sustain, so sounds don't overlap\n\t}\n}\n)\n\n// changing the rand seed changes the sound:\n\n(\nfork {\n\t(1902..2005).do { |seed|\n\t\tseed.postln;\n\t\t3.do {\n\t\t\tSynth(\"pseudorandom\", [\\seed, seed]);\n\t\t\t1.1.wait;\n\t\t}\n\t}\n}\n)\n\n// cd skipper\n(\nfork {\n\t(1902..2005).do { |seed|\n\t\tseed.postln;\n\t\trrand(4, 10).do {\n\t\t\tSynth(\"pseudorandom\", [\\seed, seed, \\sustain, 0.05]);\n\t\t\t0.06.wait;\n\t\t}\n\t}\n}\n)\n\n// if the sounds overlap, this does not work as expected anymore\n// sounds vary.\n\n(\nfork {\n\tloop {\n\t\tSynth(\"pseudorandom\");\n\t\t0.8.wait; // instead of 1.1\n\t}\n}\n)\n\n// rand id can be used to restrict the resetting of the seed to each voice:\n\n(\nfork {\n\tvar id = 0;\n\t(1902..2005).do { |seed|\n\t\tseed.postln;\n\t\t3.do {\n\t\t\tSynth(\"pseudorandom\", [\\seed, seed, \\id, id]);\n\t\t\tid = id + 1 % 16; // there is 16 different random generators\n\t\t\t0.8.wait;\n\t\t}\n\t}\n}\n)"
        }
      ],
      "description": "When the trigger signal changes from nonpositive to positive, the synth's\nrandom generator seed is reset to the given value. All synths that use\nthe same random number generator reproduce the same sequence of numbers\nagain.\n\nSee  RandID  UGen for setting the randgen id and\nReference/randomSeed for the client side equivalent.",
      "related": [
        "RandID"
      ],
      "parent": "WidthFirstUGen",
      "signalRange": null
    },
    "RecordBuf": {
      "name": "RecordBuf",
      "summary": "Record or overdub into a Buffer.",
      "categories": "UGens>Buffer",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "inputArray",
          "default": null,
          "doc": "An Array of input channels."
        },
        {
          "name": "bufnum",
          "default": 0,
          "doc": "The index of the buffer to use."
        },
        {
          "name": "offset",
          "default": 0,
          "doc": "An offset into the buffer in samples."
        },
        {
          "name": "recLevel",
          "default": 1,
          "doc": "Value to multiply by input before mixing with existing data."
        },
        {
          "name": "preLevel",
          "default": 0,
          "doc": "Value to multiply to existing data in buffer before mixing with input."
        },
        {
          "name": "run",
          "default": 1,
          "doc": "If zero, then recording stops, otherwise recording proceeds."
        },
        {
          "name": "loop",
          "default": 1,
          "doc": "If zero then don't loop, otherwise do. This is modulatable."
        },
        {
          "name": "trigger",
          "default": 1,
          "doc": "a trigger causes a jump to the start of the Buffer. A trigger\noccurs when a signal changes from negative value to positive\nvalue."
        },
        {
          "name": "doneAction",
          "default": 0,
          "doc": null
        }
      ],
      "description": "Records input into a Buffer.\n\nIf recLevel is 1.0 and preLevel is 0.0 then the new input overwrites the\nold data. If they are both 1.0 then the new data is added to the existing\ndata. (Any other settings are also valid.)\n\n(Note:  The number of channels must be fixed for the SynthDef, it cannot vary depending on which buffer you use. )",
      "related": [
        "PlayBuf"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "ReplaceOut": {
      "name": "ReplaceOut",
      "summary": "Send signal to a bus, overwriting previous contents.",
      "categories": "UGens>InOut",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "bus",
          "default": null,
          "doc": "The index of the bus to write out to. The lowest numbers are\nwritten to the audio hardware."
        },
        {
          "name": "channelsArray",
          "default": null,
          "doc": "An Array of channels or single output to write out. You cannot\nchange the size of this once a SynthDef has been built.\n\nExamples::\n\n(\nSynthDef(\"ReplaceOutHelp\", { |out = 0, freq = 440|\n\tvar source;\n\t\tsource = SinOsc.ar(freq, 0, 0.1);\n\n\t\t// write to the bus, replacing previous contents\n\t\tReplaceOut.ar(out, source);\n\n}).add;\n)\n\n// each Synth replaces the output of the previous one\nx = Synth.tail(s, \"ReplaceOutHelp\", [\\freq, 500]);\ny = Synth.tail(s, \"ReplaceOutHelp\", [\\freq, 600]);\nz = Synth.tail(s, \"ReplaceOutHelp\", [\\freq, 700]);\n\n// release them in reverse order; the older Synths are still there.\nz.free;\ny.free;\nx.free;"
        }
      ],
      "description": "Out  adds it's output to a given bus, making it\navailable to all nodes later in the node tree (See Synth and\nGuides/Order-of-execution for more information). ReplaceOut overwrites those\ncontents. This can make it useful for processing.\n\nSee the Reference/Server-Architecture and Bus helpfiles for more information on\nbuses and how they are used.",
      "related": [
        "OffsetOut",
        "Out",
        "XOut"
      ],
      "parent": "Out",
      "signalRange": null,
      "inheritedFrom": "Out"
    },
    "Resonz": {
      "name": "Resonz",
      "summary": "Resonant filter.",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "freq",
          "default": 440,
          "doc": "Resonant frequency in Hertz.\nWARNING: due to the nature of its implementation frequency values close to 0 may cause glitches and/or extremely loud audio artifacts!"
        },
        {
          "name": "bwr",
          "default": 1,
          "doc": "Bandwidth ratio (reciprocal of Q). rq = bandwidth / centerFreq.\n\nThe reciprocal of Q is used rather than Q because it saves a\ndivide operation inside the unit generator."
        }
      ],
      "description": "This is the same as  Ringz, except that it has a constant gain at 0 dB instead of being constant skirt.\n\nIt is a two pole resonant filter with zeroes at\n\nz = ±1\n\nBased on  K. Steiglitz, \"A Note on Constant-Gain Digital Resonators\", Computer Music Journal, vol 18, no. 4, pp. 8-10, Winter 1994.",
      "related": [
        "Formlet",
        "RHPF",
        "RLPF",
        "Ringz"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "Ringz": {
      "name": "Ringz",
      "summary": "Ringing filter.",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "freq",
          "default": 440,
          "doc": "Resonant frequency in Hertz."
        },
        {
          "name": "decaytime",
          "default": 1,
          "doc": "The 60 dB decay time of the filter."
        }
      ],
      "description": "This is the same as  Resonz, except that it is a constant skirt gain filter, meaning that the peak gain depends on the value of Q. Also, instead of the\nresonance parameter in Resonz, the bandwidth is specified in a 60dB ring decay time. One Ringz is equivalent to one component of the\nKlank  UGen.",
      "related": [
        "Formlet",
        "RHPF",
        "RLPF",
        "Resonz"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "Rossler": {
      "name": "Rossler",
      "summary": null,
      "categories": null,
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "chaosParam",
          "default": 1.5,
          "doc": null
        },
        {
          "name": "dt",
          "default": 0.04,
          "doc": null
        }
      ],
      "description": null,
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "Rotate2": {
      "name": "Rotate2",
      "summary": "Rotate a sound field.",
      "categories": "UGens>Multichannel>Ambisonics, UGens>Multichannel>Panners",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "x",
          "default": null,
          "doc": "Input signal X."
        },
        {
          "name": "y",
          "default": null,
          "doc": "Input signal Y."
        },
        {
          "name": "pos",
          "default": 0,
          "doc": "angle to rotate around the circle from -1 to +1. -1 is 180\ndegrees, -0.5 is left, 0 is forward, +0.5 is right, +1 is behind.\n\nExamples::\n\n(\n{\n\tvar w, x, y, p, q, a, b, c, d;\n\n\tp = WhiteNoise.ar(0.05); // source\n\tq = LFSaw.ar(200, 0, 0.03)+LFSaw.ar(200.37, 0, 0.03)+LFSaw.ar(201, 0, 0.03);\n\n\t// B-format encode 2 signals at opposite sides of the circle\n\t#w, x, y = PanB2.ar(p, -0.5) + PanB2.ar(q, 0.5);\n\n\t#x, y = Rotate2.ar(x, y, MouseX.kr(-1, 1));\n\n\t// B-format decode to quad\n\t#a, b, c, d = DecodeB2.ar(4, w, x, y);\n\n\t[a, b, d, c] // reorder to my speaker arrangement: Lf Rf Lr Rr\n}.play;\n)\n\n// Rotation of stereo sound:\n(\n{\n\t// rotation via lfo\n\tvar x, y;\n\tx = PinkNoise.ar(0.4);\n\ty = LFTri.ar(800) * LFPulse.kr(3, 0, 0.3, 0.2);\n\t#x, y = Rotate2.ar(x, y, LFSaw.kr(0.1));\n\t[x, y]\n}.play;\n)\n\n{\n\t// rotation via mouse\n\tvar x, y;\n\tx = Mix.fill(4, { LFSaw.ar(200 + 2.0.rand2, 0, 0.1) });\n\ty = SinOsc.ar(900) * LFPulse.kr(3, 0, 0.3, 0.2);\n\t#x, y = Rotate2.ar(x, y, MouseX.kr(0, 2));\n\t[x, y]\n}.play;\n\n// Rotate B-format about Z axis:\n\nwout = win;\nzout = zin;\n#xout, yout = Rotate2.ar(xin, yin, pos);\n\n// Rotate B-format about Y axis:\n\nwout = win;\nyout = yin;\n#xout, zout = Rotate2.ar(xin, zin, pos);\n\n// Rotate B-format about X axis:\n\nwout = win;\nxout = xin;\n#yout, zout = Rotate2.ar(yin, zin, pos);"
        }
      ],
      "description": "Rotate2 can be used for rotating an ambisonic B-format sound field around\nan axis. Rotate2 does an equal power rotation so it also works well on\nstereo sounds. It takes two audio inputs (x, y) and an angle control\n(pos). It outputs two channels (x, y). It computes this:\n\nxout = cos(angle) * xin + sin(angle) * yin;\n\nyout = cos(angle) * yin - sin(angle) * xin;\n\nwhere angle = pos * pi, so that -1 becomes -pi and +1 becomes +pi. This\nallows you to use an LFSaw to do continuous rotation around a circle.",
      "related": [
        "BiPanB2",
        "DecodeB2",
        "PanB",
        "PanB2"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "RunningMax": {
      "name": "RunningMax",
      "summary": "Track maximum level.",
      "categories": "UGens>Maths",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "trig",
          "default": 0,
          "doc": "Resets the output value to the current input value. A trigger happens when the signal changes from non-positive to positive.\n\nExamples::\n\n(\n{\n\tSinOsc.ar(\n\t\t\tRunningMax.ar(Dust.ar(20), Impulse.ar(0.4)) * 500 + 200,\n\t\t\t0, 0.2\n\t)\n\n}.play;\n)\n\n// follow a sine lfo, reset rate controlled by mouse x\n(\n{\n\tSinOsc.ar(\n\t\t\tRunningMax.kr(SinOsc.kr(0.2), Impulse.kr(MouseX.kr(0.01, 2, 1))) * 500 + 200,\n\t\t\t0, 0.2\n\t)\n\n}.play;\n)"
        }
      ],
      "description": "Outputs the maximum value received at the input. When a trigger occurs at\nthe reset input, the maximum output value is reset to the current value.",
      "related": [
        "RunningMin",
        "RunningSum"
      ],
      "parent": "Peak",
      "signalRange": null,
      "inheritedFrom": "Peak"
    },
    "RunningMin": {
      "name": "RunningMin",
      "summary": "Track minimum level.",
      "categories": "UGens>Maths",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "trig",
          "default": 0,
          "doc": "Resets the output value to the current input value. A trigger happens when the signal changes from non-positive to positive.\n\nExamples::\n\n(\n{\n\tSinOsc.ar(\n\t\t\tRunningMin.ar(Dust.ar(20), Impulse.ar(0.4)) * 500 + 200,\n\t\t\t0, 0.2\n\t)\n\n}.play;\n)\n\n// follow a sine lfo, reset rate controlled by mouse x\n(\n{\n\tSinOsc.ar(\n\t\t\tRunningMin.kr(SinOsc.kr(0.2), Impulse.kr(MouseX.kr(0.01, 2, 1))) * 500 + 200,\n\t\t\t0, 0.2\n\t)\n\n}.play;\n)"
        }
      ],
      "description": "Outputs the minimum value received at the input. When a trigger occurs at\nthe reset input, the minimum output value is reset to the current value.",
      "related": [
        "RunningMax",
        "RunningSum"
      ],
      "parent": "Peak",
      "signalRange": null,
      "inheritedFrom": "Peak"
    },
    "RunningSum": {
      "name": "RunningSum",
      "summary": "Running sum over n frames",
      "categories": "UGens>Analysis, UGens>Maths",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "Input signal"
        },
        {
          "name": "numsamp",
          "default": 40,
          "doc": "How many samples to take the running sum over (initialisation time only, not modulatable. default: 40)"
        }
      ],
      "description": "A running sum over a user specified number of samples, useful for running RMS power windowing.",
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "SOS": {
      "name": "SOS",
      "summary": "Second order filter section (biquad).",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "signal input"
        },
        {
          "name": "a0",
          "default": 0,
          "doc": "See formula above."
        },
        {
          "name": "a1",
          "default": 0,
          "doc": "See formula above."
        },
        {
          "name": "a2",
          "default": 0,
          "doc": "See formula above."
        },
        {
          "name": "b1",
          "default": 0,
          "doc": "See formula above."
        },
        {
          "name": "b2",
          "default": 0,
          "doc": "See formula above."
        }
      ],
      "description": "A standard second order filter section. Filter coefficients are given\ndirectly rather than calculated for you. Formula is equivalent to:\n\nout(i) = (a0 * in(i)) + (a1 * in(i-1)) + (a2 * in(i-2)) + (b1 * out(i-1)) + (b2 * out(i-2))",
      "related": [
        "FOS"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "SampleDur": {
      "name": "SampleDur",
      "summary": "Duration of one sample.",
      "categories": "UGens>Info",
      "rates": [
        "ir"
      ],
      "args": [],
      "description": "Returns the current sample duration of the server.\nEquivalent to 1/SampleRate.",
      "related": [
        "ControlRate",
        "RadiansPerSample",
        "SampleRate",
        "SubsampleOffset"
      ],
      "parent": "InfoUGenBase",
      "signalRange": null
    },
    "SampleRate": {
      "name": "SampleRate",
      "summary": "Server sample rate.",
      "categories": "UGens>Info",
      "rates": [
        "ir"
      ],
      "args": [],
      "description": "Returns the current sample rate of the server.",
      "related": [
        "ControlRate",
        "RadiansPerSample",
        "SampleDur",
        "SubsampleOffset"
      ],
      "parent": "InfoUGenBase",
      "signalRange": null
    },
    "Sanitize": {
      "name": "Sanitize",
      "summary": "Remove infinity, NaN, and denormals",
      "categories": "UGens>Info",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [],
      "description": "Replaces infinities, NaNs, and subnormal numbers (denormals) with a given signal, zero by default. The method Classes/UGen#-sanitize provides a shorthand for this.\n\nSee also CheckBadValues, which allows you to discriminate specific kinds of bad values and print information about them to the post window.",
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "Saw": {
      "name": "Saw",
      "summary": "Band limited sawtooth.",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 440,
          "doc": "Frequency in Hertz."
        }
      ],
      "description": "Band limited sawtooth wave generator.",
      "related": [
        "SyncSaw",
        "VarSaw",
        "LFSaw"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Schmidt": {
      "name": "Schmidt",
      "summary": "Schmidt trigger.",
      "categories": "UGens>Maths",
      "rates": [
        "ar",
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "Signal to be tested."
        },
        {
          "name": "lo",
          "default": 0,
          "doc": "Low threshold."
        },
        {
          "name": "hi",
          "default": 1,
          "doc": "High threshold.\n\nExamples::\n\ns.boot;\n\n{ Schmidt.kr(SinOsc.kr(1, 0, 0.2), -0.15, 0.15) }.scope; // see the trigger\n\n{ Schmidt.kr(MouseX.kr(0, 1), 0.2, 0.8) }.scope; // try it with the cursor\n\n// threshold octave jumps\n(\n{\n\tvar in = LFNoise1.kr(3);\n\tvar octave = Schmidt.kr(in, -0.15, 0.15) + 1;\n\tSinOsc.ar(in * 200 + 500 * octave, 0, 0.1)\n}.scope;\n)"
        }
      ],
      "description": "If in > hi, output 1. If in < lo, output 0. Otherwise, repeat the\nlast sample of output, assumed to be 0 at initialization. In sclang-flavored\npseudocode:\n\nout[i] = if(in[i] < lo[i]) {\n    0\n} {\n    if(in[i] > hi[i]) {\n        1\n   } {\n        out[i-1]\n   }\n};",
      "related": [
        "InRange",
        "InRect"
      ],
      "parent": "InRange",
      "signalRange": null,
      "inheritedFrom": "InRange"
    },
    "ScopeOut": {
      "name": "ScopeOut",
      "summary": "FIXME: ScopeOut purpose.",
      "categories": "UGens>Buffer, UGens>Undocumented",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "inputArray",
          "default": null,
          "doc": "FIXME: explain parameter inputArray."
        },
        {
          "name": "bufnum",
          "default": 0,
          "doc": "FIXME: explain parameter bufnum."
        }
      ],
      "description": "FIXME: ScopeOut description.",
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "ScopeOut2": {
      "name": "ScopeOut2",
      "summary": null,
      "categories": null,
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "inputArray",
          "default": null,
          "doc": null
        },
        {
          "name": "scopeNum",
          "default": 0,
          "doc": null
        },
        {
          "name": "maxFrames",
          "default": 4096,
          "doc": null
        },
        {
          "name": "scopeFrames",
          "default": null,
          "doc": null
        }
      ],
      "description": null,
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "Select": {
      "name": "Select",
      "summary": "Select output from an array of inputs.",
      "categories": "UGens>Multichannel>Select",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "which",
          "default": null,
          "doc": "Integer index"
        },
        {
          "name": "array",
          "default": null,
          "doc": "Input array of signals\n\nExamples::\n\n(\nSynthDef(\"help-Select\", { |out = 0|\n\n\tvar a, cycle;\n\ta = [\n\t\t\tSinOsc.ar,\n\t\t\tSaw.ar,\n\t\t\tPulse.ar\n\t\t];\n\tcycle = a.size  * 0.5;\n\tOut.ar(out,\n\t\tSelect.ar(LFSaw.kr(1.0, 0.0, cycle, cycle), a) * 0.2\n\t)\n}).play;\n\n)\n\n// Here used as a sequencer:\n(\nSynthDef(\"help-Select-2\", { |out = 0|\n\n\tvar a, s, cycle;\n\ta = Array.fill(32, { rrand(30, 80) }).midicps;\n\ta.postln;\n\tcycle = a.size  * 0.5;\n\n\ts = Saw.ar(\n\t\t\tSelect.kr(\n\t\t\t\tLFSaw.kr(1.0, 0.0, cycle, cycle),\n\t\t\t\ta\n\t\t\t),\n\t\t\t0.2\n\t);\n\tOut.ar(out, s)\n}).play;\n)"
        }
      ],
      "description": "The output is selected from an array of inputs.\n\n(Note:  All the UGens are continuously running. This may not be the most efficient\nway if each input is CPU-expensive. )\n\nNote that the array is fixed at the time of writing the SynthDef, and the\nwhole array is embedded in the SynthDef file itself.  For small arrays\nthis is more efficient than reading from a buffer.",
      "related": [
        "SelectX",
        "SelectXFocus",
        "LinSelectX"
      ],
      "parent": "PureUGen",
      "signalRange": null
    },
    "SendPeakRMS": {
      "name": "SendPeakRMS",
      "summary": "Track peak and power of a signal for GUI applications.",
      "categories": "UGens>Analysis>Amplitude",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "sig",
          "default": null,
          "doc": "The input signal."
        },
        {
          "name": "replyRate",
          "default": 20,
          "doc": "Float or Integer. Specifies the number of replies that are sent to the clients\nper second."
        },
        {
          "name": "peakLag",
          "default": 3,
          "doc": "Float or Integer. Lag time, which is applied to the peak values. This option is\ncommonly used for GUI VU meters."
        },
        {
          "name": "cmdName",
          "default": "'/reply'",
          "doc": "Symbol or String. Address pattern for reply message."
        },
        {
          "name": "replyID",
          "default": -1,
          "doc": "Integer ID (similar to SendTrig).\n\nINSTANCEMETHODS::\nprivate:: numOutputs, writeOutputSpecs\n\nEXAMPLES::\n\n(\n{\n\tSendPeakRMS.kr(Dust.ar(20), 20, 3, \"/replyAddress\")\n}.play;\n)\n\n(\no = OSCFunc({ |msg|\n\t\"peak: %, rms: %\".format(msg[3], msg[4]).postln\n}, '/replyAddress');\n)\no.free;"
        }
      ],
      "description": "The SendPeakRMS unit generator computes peak and power of a signal and sends the\ncomputed values back to the clients. It does not produce any output.",
      "related": [
        "Peak",
        "PeakFollower",
        "OSCFunc"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "SendReply": {
      "name": "SendReply",
      "summary": "Send an array of values from the server to all notified clients",
      "categories": "UGens>Triggers",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "trig",
          "default": 0,
          "doc": null
        },
        {
          "name": "cmdName",
          "default": "'/reply'",
          "doc": null
        },
        {
          "name": "values",
          "default": null,
          "doc": null
        },
        {
          "name": "replyID",
          "default": -1,
          "doc": null
        }
      ],
      "description": "A message is sent to all notified clients. See Server.\n\nlist::\n- cmdName\n\tlist::\n\t## int - node ID\n\t## int - reply ID\n\t## ... floats - values.\n\t::",
      "related": [
        "SendTrig",
        "OSCFunc"
      ],
      "parent": "SendTrig",
      "signalRange": null
    },
    "SendTrig": {
      "name": "SendTrig",
      "summary": "Send a trigger message from the server back to the client.",
      "categories": "UGens>Triggers",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The trigger."
        },
        {
          "name": "id",
          "default": 0,
          "doc": "An integer that will be passed with the trigger message. This is\nuseful if you have more than one SendTrig in a SynthDef."
        },
        {
          "name": "value",
          "default": 0,
          "doc": "A UGen or float that will be polled at the time of trigger, and\nits value passed with the trigger message.\n\nExamples::\n\ns.boot;\n\n(\nSynthDef(\"help-SendTrig\", {\n\tSendTrig.kr(Dust.kr(1.0), 0, 0.9);\n}).add;\n\n// register to receive this message\no = OSCFunc({ |msg, time|\n\t[time, msg].postln;\n}, '/tr', s.addr);\n)\n\nSynth(\"help-SendTrig\");\n\no.free;"
        }
      ],
      "description": "On receiving a trigger (a non-positive to positive transition), send a\ntrigger message from the server back to the client.\n\nThe trigger message sent back to the client is this:\n\ntable::\n\n- /tr || A trigger message.\n\n- int: || Node ID.\n\n- int: || Trigger ID.\n\n- float: || Trigger value.\n\nThis command is the mechanism that synths can use to trigger events in\nclients. The node ID is the node that is sending the trigger. The trigger\nID and value are determined by inputs to the SendTrig unit generator\nwhich is the originator of this message.",
      "related": [
        "OSCFunc",
        "SendReply"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Shaper": {
      "name": "Shaper",
      "summary": "Wave shaper.",
      "categories": "UGens>Buffer",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": "The number of a buffer filled in wavetable format containing the\ntransfer function."
        },
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal.\n\nExamples::\n\ns.boot;\n\nb = Buffer.alloc(s, 512, 1, { |buf| buf.chebyMsg([1, 0, 1, 1, 0, 1]) });\n\n(\n{\n\tShaper.ar(\n\t\tb,\n\t\tSinOsc.ar(300, 0, Line.kr(0, 1, 6)),\n\t\t0.5\n\t)\n}.scope;\n)\n\nb.free;\n\nimage::chebyshevpolynomials.png::\n\nWave shaping transfer functions are typically designed by using Chebyshev polynomials to control which harmonics are generated when a cosine wave is passed in. The implementation in SuperCollider compensates for the DC offset due to even polynomial terms, making sure that when 0 is put into the transfer function, you get 0 out. By default, normalization is set to true, which avoids output overload. If you want to construct a transfer function without this, you need to be careful with the final output scaling, since it could easily overload the -1 to 1 range for audio.\n\n// I want the first harmonic at 0.25 amplitude, second at 0.5, third at 0.25\nb = Buffer.alloc(s, 512, 1, { |buf| buf.chebyMsg([0.25, 0.5, 0.25], false) });\n\n(\n{\n\tShaper.ar(\n\t\tb,\n\t\tSinOsc.ar(440, 0.5pi, Line.kr(0, 1, 6)), // input cosine wave\n\t\t0.5 // scale output down because otherwise it goes between -1.05 and 0.5, distorting...\n\t)\n}.scope;\n)\n\nb.free;\n\nFor those who like to make their own wavetables for arbitrary shapers, your buffer must be in wavetable format to have a valid transfer function. Wavetable format is a special representation to make linear interpolation faster (see at the bottom of this file). You don't have to worry about this directly, because there are two straight forward ways to get wavetables into a server buffer. First, the server can generate them (see the Buffer help file for the methods sine1, sine2, sine3 and cheby):\n\nb = Buffer.alloc(s, 1024, 1);\nb.cheby([1, 0.5, 1, 0.125]);\n\n(\n{ \tvar\tsig = Shaper.ar(b, SinOsc.ar(440, 0, 0.4));\n\tsig ! 2\n}.scope;\n)\n\nb.free;\n\nOr, you can calculate the transfer function in a client-side array (Signal class) then convert it to a wavetable and send the data over.\n\nb = Buffer.alloc(s, 1024, 1);\n\n// size must be power of two plus 1\nt = Signal.chebyFill(513, [1, 0.5, 1, 0.125]);\n\n// linear function\nt.plot\n\n// t.asWavetableNoWrap will convert it to the official Wavetable format at next power of two size\nb.sendCollection(t.asWavetableNoWrap);  // may also use loadCollection here\n\nb.plot\n\n(\n{ \tvar\tsig = Shaper.ar(b, SinOsc.ar(440, 0, 0.4));\n\tsig ! 2\n}.scope;\n)\n\nb.free;\n\nThis way of working then allows you to get creative with your transfer functions!\n\nb = Buffer.alloc(s, 1024, 1);\n\n// or, for an arbitrary transfer function, create the data at 1/2 buffer size + 1\nt = Signal.fill(513, { |i| i.linlin(0.0, 512.0, -1.0, 1.0) });\n\n// linear function\nt.plot\n\n// t.asWavetable will convert it to the official Wavetable format at twice the size\nb.sendCollection(t.asWavetableNoWrap);  // may also use loadCollection here\n\n// shaper has no effect because of the linear transfer function\n(\n{ \tvar\tsig = Shaper.ar(b, SinOsc.ar(440, 0, 0.4));\n\tsig ! 2\n}.scope;\n)\n\n// now for a twist\n(\na = Signal.fill(256, { |i|\n\tvar t = i/255.0;\n\tt + (0.1 * (max(t, 0.1) - 0.1) * sin(2pi * t * 80 + sin(2pi * 25.6 * t)))\n})\n);\n\na.plot\n\nd = (a.copy.reverse.neg) ++(Signal[0])++ a;\n\nd.plot\n\nd.size\t// must be buffer size/2 + 1, so 513 is fine\n\nb.sendCollection(d.asWavetableNoWrap);  // may also use loadCollection here\n\nb.plot // wavetable format!\n\n// test shaper\n(\n{\n\tShaper.ar(\n\t\tb,\n\t\tSinOsc.ar(440, 0.5, Line.kr(0, 0.9, 6))\n\t)\n}.scope\n)"
        }
      ],
      "description": "Performs waveshaping on the input signal by indexing into the table.",
      "related": [
        "Index",
        "WrapIndex",
        "Wavetable"
      ],
      "parent": "Index",
      "signalRange": null,
      "inheritedFrom": "Index"
    },
    "SimpleLoopBuf": {
      "name": "SimpleLoopBuf",
      "summary": null,
      "categories": null,
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "numChannels",
          "default": null,
          "doc": null
        },
        {
          "name": "bufnum",
          "default": 0,
          "doc": null
        },
        {
          "name": "loopStart",
          "default": 0,
          "doc": null
        },
        {
          "name": "loopEnd",
          "default": 99999,
          "doc": null
        },
        {
          "name": "trigger",
          "default": 0,
          "doc": null
        }
      ],
      "description": null,
      "related": [],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "SinOsc": {
      "name": "SinOsc",
      "summary": "Interpolating sine wavetable oscillator.",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 440,
          "doc": "Frequency in Hertz.\nSampled at audio-rate."
        },
        {
          "name": "phase",
          "default": 0,
          "doc": "Phase in radians.\nSampled at audio-rate.\n(Note: phase values should be within the range +-8pi. If your phase values are larger then simply use .mod(2pi) to wrap them.)"
        }
      ],
      "description": "Generates a sine wave.\nUses a wavetable lookup oscillator with linear interpolation.\nFrequency and phase modulation are provided for audio-rate modulation.\nTechnically, SinOsc uses the same implementation as  Osc  except that its table is fixed to be a sine wave made of 8192 samples.",
      "related": [
        "Osc",
        "FSinOsc",
        "SinOscFB",
        "PMOsc",
        "Klang"
      ],
      "parent": "PureUGen",
      "signalRange": null
    },
    "SinOscFB": {
      "name": "SinOscFB",
      "summary": "Feedback FM oscillator",
      "categories": "UGens>Generators>Deterministic, UGens>Generators>Chaotic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 440,
          "doc": "The base frequency of the sine oscillator in Hertz."
        },
        {
          "name": "feedback",
          "default": 0,
          "doc": "The second argument is the amplitude of phase feedback in radians."
        }
      ],
      "description": "SinOscFB is a sine oscillator that has phase modulation feedback; its output plugs back into the phase input.\nBasically this allows a modulation between a sine wave and a sawtooth like wave. Overmodulation causes chaotic oscillation. It may be useful if you want to simulate feedback FM synths.\n\nPlease note: The frequency of SinOscFB can be modulated at control rate. When trying to modulate the frequency of SinOscFB at audio rate, you will notice audible artefacts at higher frequency modulation frequencies. This is due to SinOscFB updating incoming frequency modulation values only once every control period (which is 64 samples long per default), instead of updating on every sample (like e.g. SinOsc).",
      "related": [
        "SinOsc",
        "FSinOsc",
        "PMOsc"
      ],
      "parent": "PureUGen",
      "signalRange": null
    },
    "Slew": {
      "name": "Slew",
      "summary": "Slew rate limiter.",
      "categories": "UGens>Filters>Nonlinear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "up",
          "default": 1,
          "doc": "Maximum upward slope in units per second."
        },
        {
          "name": "dn",
          "default": 1,
          "doc": "Maximum downward slope in units per second."
        }
      ],
      "description": "Limits the slope of an input signal. The slope is expressed in units per\nsecond.\n\nFor smoothing out control signals, take a look at Lag and VarLag",
      "related": [
        "Slope",
        "Ramp",
        "Lag",
        "VarLag"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "Slope": {
      "name": "Slope",
      "summary": "Slope of signal",
      "categories": "UGens>Analysis, UGens>Filters>Linear, UGens>Maths",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "Input signal to measure."
        }
      ],
      "description": "Measures the rate of change per second of a signal.\nFormula implemented is:\n\nout[i] = (in[i] - in[i-1]) * sampling_rate",
      "related": [],
      "parent": "Filter",
      "signalRange": null
    },
    "SpecCentroid": {
      "name": "SpecCentroid",
      "summary": "Spectral centroid",
      "categories": "UGens>FFT",
      "rates": [
        "kr"
      ],
      "args": [],
      "description": "Given an FFT chain, this measures the spectral centroid, which is the weighted mean frequency, or the \"centre of mass\" of the spectrum. (DC is ignored.)\n\nThis can be a useful indicator of the perceptual brightness of a signal.",
      "related": [
        "SpecFlatness",
        "SpecPcile"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "SpecFlatness": {
      "name": "SpecFlatness",
      "summary": "Spectral Flatness measure",
      "categories": "UGens>FFT",
      "rates": [
        "kr"
      ],
      "args": [],
      "description": "Given an FFT chain this calculates the Spectral Flatness measure, defined as a power spectrum's geometric mean divided by its arithmetic mean. This gives a measure which ranges from approx 0 for a pure sinusoid, to approx 1 for white noise.\n\nThe measure is calculated linearly. For some applications you may wish to convert the value to a decibel scale - an example of such conversion is shown below.",
      "related": [
        "SpecCentroid",
        "SpecPcile"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "SpecPcile": {
      "name": "SpecPcile",
      "summary": "Find a percentile of FFT magnitude spectrum",
      "categories": "UGens>FFT",
      "rates": [
        "kr"
      ],
      "args": [],
      "description": "Given an FFT chain this calculates the cumulative distribution of the frequency spectrum, and outputs the frequency value which corresponds to the desired percentile.\n\nFor example, to find the frequency at which 90% of the spectral energy lies below that frequency, you want the 90-percentile, which means the value of fraction should be 0.9. The 90-percentile or 95-percentile is often used as a measure of spectral roll-off.\n\nThe optional third argument interpolate (ir) specifies whether interpolation should be used to try and make the percentile frequency estimate more accurate, at the cost of a little higher CPU usage. Set it to 1 to enable this.\n\nOptional fourth argument is binout (ir) specifies whether to output the bin number instead of the frequency (default 0, set to 1 to enable). If interpolate is enabled, linear interpolation on the bin number is performed.",
      "related": [
        "SpecCentroid",
        "SpecFlatness"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Splay": {
      "name": "Splay",
      "summary": "Splay spreads an array of channels across the stereo field",
      "categories": "UGens>Multichannel>Panners",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "inArray",
          "default": null,
          "doc": null
        },
        {
          "name": "spread",
          "default": 1,
          "doc": null
        },
        {
          "name": "level",
          "default": 1,
          "doc": null
        },
        {
          "name": "center",
          "default": 0,
          "doc": null
        },
        {
          "name": "levelComp",
          "default": "true",
          "doc": null
        }
      ],
      "description": "Splay spreads an array of channels across the stereo field.\nOptional arguments are spread and center, and equal power levelCompensation.\nThe formula for the stereo position is ((0 .. (n - 1)) * (2 / (n - 1)) - 1) * spread + center",
      "related": [
        "SplayAz",
        "SplayZ",
        "LevelComp"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "SplayAz": {
      "name": "SplayAz",
      "summary": "Spreads an array of channels across a ring of channels",
      "categories": "UGens>Multichannel>Panners",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "numChans",
          "default": 4,
          "doc": null
        },
        {
          "name": "inArray",
          "default": null,
          "doc": null
        },
        {
          "name": "spread",
          "default": 1,
          "doc": null
        },
        {
          "name": "level",
          "default": 1,
          "doc": null
        },
        {
          "name": "width",
          "default": 2,
          "doc": null
        },
        {
          "name": "center",
          "default": 0,
          "doc": null
        },
        {
          "name": "orientation",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "levelComp",
          "default": "true",
          "doc": null
        }
      ],
      "description": "SplayAz spreads an array of channels across a ring of channels.\nOptional spread and center controls, and flexible levelCompensation\ntunable for equal power and/or equal amplitude.\nnumChans and orientation are as in PanAz.\n\n{ SplayAz.ar(5, [SinOsc.ar, Saw.ar], 0, 1) }.plot;",
      "related": [
        "Splay",
        "PanAz",
        "SelectXFocus",
        "LevelComp"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Spring": {
      "name": "Spring",
      "summary": "physical model of resonating spring",
      "categories": "UGens>Filters>Nonlinear, UGens>Generators>PhysicalModels",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "modulated input force"
        },
        {
          "name": "spring",
          "default": 1,
          "doc": "spring constant (incl. mass)"
        },
        {
          "name": "damp",
          "default": 0,
          "doc": "damping"
        }
      ],
      "description": "models the force of a resonating spring",
      "related": [
        "Ball",
        "TBall"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "StandardL": {
      "name": "StandardL",
      "summary": "Standard map chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "k",
          "default": 1,
          "doc": null
        },
        {
          "name": "xi",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "yi",
          "default": 0,
          "doc": null
        }
      ],
      "description": "A linear-interpolating sound generator based on the difference equations:\n\nteletype::\n\tx(n+1) = (x(n) + y(n+1)) % 2pi\n\ty(n+1) = (y(n) + k * sin(x(n))) % 2pi\n\nThe standard map is an area preserving map of a cylinder discovered by the plasma physicist Boris Chirikov.\n\nsclang code translation:\n\n(\nvar k = 1, xi = 0.5, yi = 0, size = 64;\nplot(size.collect { yi = yi + (k * sin(xi)) % 2pi; xi = (xi + yi) % 2pi; xi - pi * 0.3183098861837907 });\n)",
      "related": [
        "StandardN"
      ],
      "parent": "StandardN",
      "signalRange": null,
      "inheritedFrom": "StandardN"
    },
    "StandardN": {
      "name": "StandardN",
      "summary": "Standard map chaotic generator",
      "categories": "UGens>Generators>Chaotic",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "freq",
          "default": 22050,
          "doc": null
        },
        {
          "name": "k",
          "default": 1,
          "doc": null
        },
        {
          "name": "xi",
          "default": 0.5,
          "doc": null
        },
        {
          "name": "yi",
          "default": 0,
          "doc": null
        }
      ],
      "description": "A non-interpolating sound generator based on the difference equations:\n\nteletype::\n        x(n+1) = (x(n) + y(n+1)) % 2pi\n        y(n+1) = (y(n) + k * sin(x(n))) % 2pi\n\nThe standard map is an area preserving map of a cylinder discovered by the plasma physicist Boris Chirikov.\n\nsclang code translation:\n\n(\nvar k = 1, xi = 0.5, yi = 0, size = 64;\nplot(size.collect { yi = yi + (k * sin(xi)) % 2pi; xi = (xi + yi) % 2pi; xi - pi * 0.3183098861837907 });\n)",
      "related": [
        "StandardL"
      ],
      "parent": "ChaosGen",
      "signalRange": null
    },
    "Stepper": {
      "name": "Stepper",
      "summary": "Pulse counter.",
      "categories": "UGens>Triggers",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "trig",
          "default": 0,
          "doc": "The trigger. Trigger can be any signal. A trigger happens when\nthe signal changes from non-positive to positive."
        },
        {
          "name": "reset",
          "default": 0,
          "doc": "Resets the counter to\nresetval  when\ntriggered."
        },
        {
          "name": "min",
          "default": 0,
          "doc": "Minimum value of the counter."
        },
        {
          "name": "max",
          "default": 7,
          "doc": "Maximum value of the counter."
        },
        {
          "name": "step",
          "default": 1,
          "doc": "Step value each trigger. May be negative."
        },
        {
          "name": "resetval",
          "default": null,
          "doc": "Value to which the counter is reset when it receives a reset\ntrigger. If nil, then this is patched to\n\nmin .\n\nExamples::\n\nSynthDef(\"help-Stepper\", { |out = 0|\n\tOut.ar(out,\n\t\tSinOsc.ar(\n\t\t\tStepper.kr(Impulse.kr(10), 0, 4, 16, 1) * 100,\n\t\t\t0, 0.05\n\t\t)\n\t)\n}).play;\n\nSynthDef(\"help-Stepper\", { |out = 0|\n\tOut.ar(out,\n\t\tSinOsc.ar(\n\t\t\tStepper.kr(Impulse.kr(10), 0, 4, 16, -3) * 100,\n\t\t\t0, 0.05\n\t\t)\n\t)\n}).play;\n\nSynthDef(\"help-Stepper\", { |out = 0|\n\tOut.ar(out,\n\t\tSinOsc.ar(\n\t\t\tStepper.kr(Impulse.kr(10), 0, 4, 16, 4) * 100,\n\t\t\t0, 0.05\n\t\t)\n\t)\n}).play;\n\n///////////////////////////////////////////////////////////////////////////////////\n//\n// Using Stepper and BufRd for sequencing\n//\n\ns.boot;\n\ns.sendMsg(\\b_alloc, 10, 128);\n\nm = #[0, 3, 5, 7, 10];\n\na = ({ rrand(0, 15) }.dup(16).degreeToKey(m) + 36).midicps;\ns.performList(\\sendMsg, \\b_setn, 10, 0, a.size, a);\n\n(\nSynthDef(\\stepper, { |out|\n\tvar rate, clock, index, freq, ffreq, env, out, rev, lfo;\n\n\trate = MouseX.kr(1, 5, 1);\n\tclock = Impulse.kr(rate);\n\tenv = Decay2.kr(clock, 0.002, 2.5);\n\tindex = Stepper.kr(clock, 0, 0, 15, 1, 0);\n\tfreq = BufRd.kr(1, 10, index, 1, 1);\n\tfreq = Lag2.kr(freq) + [0, 0.3];\n\tffreq = MouseY.kr(80, 1600, 1) * (env * 4 + 2);\n\tout = Mix.ar(LFPulse.ar(freq * [1, 3/2, 2], 0, 0.3));\n\tout = RLPF.ar(out, ffreq, 0.3, env);\n\tout = RLPF.ar(out, ffreq, 0.3, env);\n\tout = out * 0.02;\n\n\t// echo\n\tout = CombL.ar(out, 1, 0.66/rate, 2, 0.8, out);\n\n\t// reverb\n\trev = out;\n\t5.do { rev = AllpassN.ar(rev, 0.05, { 0.05.rand }.dup, rrand(1.5, 2.0)) };\n\tout = out + (0.3 * rev);\n\n\tout = LeakDC.ar(out);\n\n\t// flanger\n\tlfo = SinOsc.kr(0.2, [0, 0.5pi], 0.0024, 0.0025);\n\t1.do { out = DelayL.ar(out, 0.1, lfo, 1, out) };\n\n\t// slight bass emphasis\n\tout = OnePole.ar(out, 0.9);\n\n\tOut.ar(out, out);\n\n}).add;\n)\n\ns.sendMsg(\\s_new, \\stepper, 1000, 0, 0);\n\na = ({ rrand(0, 15) }.dup(16).degreeToKey(m) + 38).midicps;\ns.performList(\\sendMsg, \\b_setn, 10, 0, a.size, a);\n\na = a * 2.midiratio; // transpose up 2 semitones\ns.performList(\\sendMsg, \\b_setn, 10, 0, a.size, a);\n\n(\na = [97.999, 195.998, 523.251, 466.164, 195.998, 233.082, 87.307, 391.995, 87.307, 261.626, 195.998, 77.782, 233.082, 195.998, 97.999, 155.563];\ns.performList(\\sendMsg, \\b_setn, 10, 0, a.size, a);\n)\n\ns.sendMsg(\\n_free, 1000);"
        }
      ],
      "description": "Each trigger increments a counter which is output as a signal. The\ncounter wraps between  min  and\nmax .",
      "related": [
        "PulseCount"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "StereoConvolution2L": {
      "name": "StereoConvolution2L",
      "summary": "Stereo real-time convolver with linear interpolation",
      "categories": "UGens>FFT, UGens>Convolution",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": null
        },
        {
          "name": "kernelL",
          "default": null,
          "doc": null
        },
        {
          "name": "kernelR",
          "default": null,
          "doc": null
        },
        {
          "name": "trigger",
          "default": 0,
          "doc": null
        },
        {
          "name": "framesize",
          "default": 2048,
          "doc": null
        },
        {
          "name": "crossfade",
          "default": 1,
          "doc": null
        }
      ],
      "description": "Strict convolution with fixed kernel which can be updated using a trigger signal. There is a linear crossfade between the buffers upon change.\n\nLike Convolution2L, but convolves with two buffers and outputs a stereo signal. This saves one FFT transformation per period, as compared to using two copies of Convolution2L.\n\nUseful applications could include stereo reverberation or HRTF convolution.\n\nSee Steven W Smith, The Scientist and Engineer's Guide to Digital Signal Processing, chapter 18: link::http://www.dspguide.com/ch18.htm::",
      "related": [
        "Convolution",
        "Convolution2L"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "SubsampleOffset": {
      "name": "SubsampleOffset",
      "summary": "Offset from synth start within one sample.",
      "categories": "UGens>Info",
      "rates": [
        "ir"
      ],
      "args": [],
      "description": "When a synth is created from a time stamped osc-bundle, it starts\ncalculation at the next possible block (normally 64 samples). Using an\nOffsetOut UGen, one can delay the audio so that it matches sample\naccurately.\n\nFor some synthesis methods, one needs subsample accuracy. SubsampleOffset\nprovides the information where, within the current sample, the synth was\nscheduled. It can be used to offset envelopes or resample the audio\noutput.",
      "related": [
        "ControlRate",
        "RadiansPerSample",
        "SampleDur",
        "SampleRate",
        "OffsetOut"
      ],
      "parent": "InfoUGenBase",
      "signalRange": null
    },
    "Sweep": {
      "name": "Sweep",
      "summary": "Triggered linear ramp",
      "categories": "UGens>Triggers",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "trig",
          "default": 0,
          "doc": "triggers when trig input crosses from non-positive to positive."
        },
        {
          "name": "rate",
          "default": 1,
          "doc": "rate/sec raise rate\n\nExamples::\n\n// using sweep to modulate sine frequency\n(\n{ var trig;\n\ttrig = Impulse.kr(MouseX.kr(0.5, 20, 1));\n\tSinOsc.ar(Sweep.kr(trig, 700) + 500, 0, 0.2)\n}.play;\n)\n\n// using sweep to index into a buffer\nb = Buffer.read(s, ExampleFiles.child);\n\n(\n{ var trig;\n\ttrig = Impulse.kr(MouseX.kr(0.5, 10, 1));\n\tBufRd.ar(1, b, Sweep.ar(trig, BufSampleRate.ir(0)))\n}.play;\n)\n\n// backwards, variable offset\n(\n{ var trig, pos, rate;\n\ttrig = Impulse.kr(MouseX.kr(0.5, 10, 1));\n\trate = BufSampleRate.ir(0);\n\tpos = Sweep.ar(trig, rate.neg) + (BufFrames.ir(0) * LFNoise0.kr(0.2));\n\tBufRd.ar(1, b, pos)\n}.play;\n)\n\n// raising rate\n(\n{ var trig, rate;\n\ttrig = Impulse.kr(MouseX.kr(0.5, 10, 1));\n\trate = Sweep.kr(trig, 2) + 0.5;\n\tBufRd.ar(1, b, Sweep.ar(trig, BufSampleRate.ir(0) * rate))\n}.play;\n)\n\nb.free\n\nSweep can be used as a resettable Phasor or Line - one that can start, pause, resume and stop. To get a resettable XLine behavior change the linlin to linexp in the SynthDef below.\n\n(\nSynthDef(\\lineReset, { |out, start = 0, end = 1, dur = 1, t_trig = 1, run = 1|\n\tvar phasor = Sweep.ar(t_trig, run / dur).linlin(0, 1, start, end, \\minmax);\n\tphasor.poll;\n\tOut.ar(out, SinOsc.ar(phasor, 0, 0.2));\n}).add;\n)\na = Synth(\\lineReset, [\\start, 400, \\end, 800, \\dur, 2])\na.set(\\t_trig, 1)\na.set(\\run, 0)\na.set(\\run, 1)\na.set(\\t_trig, 1)\na.free\n\n// shorter duration and downwards...\na = Synth(\\lineReset, [\\start, 1000, \\end, 500, \\dur, 0.5])\na.set(\\t_trig, 1)\na.set(\\run, 0)\na.set(\\run, 1)\na.set(\\t_trig, 1)\na.free"
        }
      ],
      "description": "Starts a linear raise by rate/sec from zero when trig input crosses from\nnon-positive to positive.\n\nWhen rate == 1, Sweep may be used to get a continually-updating measurement\nof the time (in seconds) since the last trigger.",
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "SyncSaw": {
      "name": "SyncSaw",
      "summary": "Hard sync sawtooth wave.",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "syncFreq",
          "default": 440,
          "doc": "Frequency of the fundamental."
        },
        {
          "name": "sawFreq",
          "default": 440,
          "doc": "Frequency of the synched sawtooth wave. Should always be greater than syncFreq.\n(Warning:  teletype)SyncSaw:: will go out of range if the frequency exceeds the sampling rate (which for control rate is s.sampleRate / s.options.blockSize).::"
        }
      ],
      "description": "A sawtooth wave that is hard synched to a fundamental pitch. This\nproduces an effect similar to  moving formants or pulse width modulation.\nThe sawtooth oscillator has its phase reset when the sync oscillator\ncompletes a cycle. This is not a band limited waveform, so it may alias.",
      "related": [
        "Saw",
        "VarSaw",
        "LFSaw"
      ],
      "parent": "PureUGen",
      "signalRange": null
    },
    "T2A": {
      "name": "T2A",
      "summary": "Control rate trigger to audio rate trigger converter",
      "categories": "UGens>Conversion, UGens>Triggers",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": null
        },
        {
          "name": "offset",
          "default": 0,
          "doc": null
        }
      ],
      "description": "Converts control rate trigger into audio rate trigger (maximally one per control period).",
      "related": [
        "T2K",
        "K2A",
        "A2K"
      ],
      "parent": "K2A",
      "signalRange": null
    },
    "TBall": {
      "name": "TBall",
      "summary": "physical model of bouncing object",
      "categories": "UGens>Filters>Nonlinear, UGens>Generators>PhysicalModels",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "modulated surface level"
        },
        {
          "name": "g",
          "default": 10,
          "doc": "gravity"
        },
        {
          "name": "damp",
          "default": 0,
          "doc": "damping on impact"
        },
        {
          "name": "friction",
          "default": 0.01,
          "doc": "proximity from which on attraction to surface starts"
        }
      ],
      "description": "models the impacts of a bouncing object that is reflected by a vibrating surface",
      "related": [
        "Ball",
        "Spring"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "TDuty": {
      "name": "TDuty",
      "summary": "Demand results as trigger from demand rate UGens.",
      "categories": "UGens>Demand",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "dur",
          "default": 1,
          "doc": "Time values. Can be a demand UGen or any signal. The next trigger\nvalue is acquired after duration."
        },
        {
          "name": "reset",
          "default": 0,
          "doc": "Trigger or reset time values. Resets the list of UGens and the\nduration UGen when triggered. The reset input may also be a\ndemand UGen, providing a stream of reset times."
        },
        {
          "name": "level",
          "default": 1,
          "doc": "Demand UGen providing the output values."
        },
        {
          "name": "doneAction",
          "default": 0,
          "doc": "A doneAction that is evaluated when the duration stream ends. See\n\nDone  for more detail."
        },
        {
          "name": "gapFirst",
          "default": 0,
          "doc": "when 0 (default), the UGen does the first level poll immediately and then waits for the first durational value. When this is 1, the UGen initially polls the first durational value, waits for that duration, and then polls the first level (along with polling the next durational value).\n\nExamples::\n\n// examples\n\ns.boot;\n\n// play a little rhythm\n\n{ TDuty.ar(Dseq([0.1, 0.2, 0.4, 0.3], inf)) }.play; // demand ugen as durations\n\n// amplitude changes\n(\n\t{\n\t\tvar trig;\n\t\ttrig = TDuty.ar(\n\t\t\t\tDseq([0.1, 0.2, 0.4, 0.3], inf), // demand ugen as durations\n\t\t\t\t0,\n\t\t\t\tDseq([0.1, 0.4, 0.01, 0.5, 1.0], inf) // demand ugen as amplitude\n\t\t\t);\n\t\tRingz.ar(trig, 1000, 0.1)\n\n\t}.play;\n)\n\n(\n\t{\n\t\tvar trig;\n\t\ttrig = TDuty.ar(\n\t\t\t\tMouseX.kr(0.001, 2, 1), // control rate ugen as durations\n\t\t\t\t0,\n\t\t\t\tDseq([0.1, 0.4, 0.01, 0.5, 1.0], inf)\n\t\t\t);\n\t\tRingz.ar(trig, 1000, 0.1)\n\n\t}.play;\n)\n\n// demand ugen as audio oscillator\n\n(\n\t{\n\t\tvar a, trig, n = 5, m = 64;\n\t\ta = {\n\t\t\tvar x;\n\t\t\tx = { 0.2.rand2 } ! m;\n\t\t\tx = x ++ ({  Drand({ 0.2.rand2 } ! n) } ! m.rand);\n\t\t\tDseq(x.scramble, inf)\n\t\t} ! n;\n\t\ttrig = TDuty.ar(\n\t\t\t\tMouseX.kr(1, 2048, 1) * SampleDur.ir * [1, 1.02],\n\t\t\t\t0,\n\t\t\t\tDswitch1(a, MouseY.kr(0, n-1))\n\t\t\t);\n\t\tRingz.ar(trig, 1000, 0.01)\n\n\t}.play;\n)\n\n// single impulses\n\n(\nSynthDef(\"delta_demand\", { |amp = 0.5, out|\n\tOffsetOut.ar(out,\n\t\tTDuty.ar(Dseq([0]), 0, amp, 2)\n\t)\n}).add;\n)\n\nfork { 10.do { s.sendBundle(0.2, [\"/s_new\", \"delta_demand\", -1]); 1.0.rand.wait } };\n\n// chain of impulses\n(\nSynthDef(\"delta_demand2\", {\n\tOffsetOut.ar(0,\n\t\tTDuty.ar(Dgeom(0.05, 0.9, 20), 0, 0.5, 2)\n\t)\n}).add;\n)\n\nfork { 10.do { s.sendBundle(0.2, [\"/s_new\", \"delta_demand2\", -1]); 1.0.rand.wait } };\n\n// multichannel expansion\n\n(\n\t{\n\t\tvar t;\n\t\tt = TDuty.ar(\n\t\t\t\tDrand([Dgeom(0.1, 0.8, 20), 1, 2], inf) ! 2,\n\t\t\t\t0,\n\t\t\t\t[Drand({ 1.0.rand } ! 8, inf), Dseq({ 1.0.rand } ! 8, inf)] * 2\n\t\t\t);\n\t\tx = Ringz.ar(t, [400, 700], 0.1) * 0.1;\n\n\t}.play;\n)"
        }
      ],
      "description": "A value is demanded each UGen in the list and output as a trigger\naccording to a stream of duration values. The unit generators in the list\nshould be 'demand' rate.\n\nWhen there is a trigger at the reset input, the demand rate UGens in the\nlist and the duration are reset. The reset input may also be a demand\nUGen, providing a stream of reset times.",
      "related": [
        "Demand",
        "Duty"
      ],
      "parent": "Duty",
      "signalRange": null
    },
    "TExpRand": {
      "name": "TExpRand",
      "summary": "Triggered exponential random number generator.",
      "categories": "UGens>Random, UGens>Triggers",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "lo",
          "default": 0.01,
          "doc": "Lower limit of the output range."
        },
        {
          "name": "hi",
          "default": 1,
          "doc": "Upper limit of the output range."
        },
        {
          "name": "trig",
          "default": 0,
          "doc": "The trigger. Trigger can be any signal. A trigger happens when\nthe signal changes from non-positive to positive.\n\nExamples::\n\n(\n{\n\tvar trig = Dust.kr(10);\n\tSinOsc.ar(\n\t\t\tTExpRand.kr(300.0, 3000.0, trig)\n\t\t) * 0.1\n}.play;\n)\n\n(\n{\n\tvar trig = Dust.ar(MouseX.kr(1, 8000, 1));\n\tSinOsc.ar(\n\t\t\tTExpRand.ar(300.0, 3000.0, trig)\n\t\t) * 0.1\n}.play;\n)"
        }
      ],
      "description": "Generates a random float value in exponential distribution from\nlo  to  hi  each time the\ntrigger signal changes from nonpositive to positive values\nlo  and  hi  must both have\nthe same sign and be non-zero.",
      "related": [
        "ExpRand",
        "IRand",
        "LinRand",
        "NRand",
        "Rand",
        "TIRand",
        "TRand"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "TGrains": {
      "name": "TGrains",
      "summary": "Buffer granulator.",
      "categories": "UGens>Buffer, UGens>Generators>Granular",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "numChannels",
          "default": null,
          "doc": "The number of output channels. Must be a nonzero, positive integer. This is fixed when the SynthDef is compiled so cannot be assigned to a SynthDef argument."
        },
        {
          "name": "trigger",
          "default": 0,
          "doc": "At each trigger, the following arguments are sampled and used as\nthe arguments of a new grain. A trigger occurs when a signal\nchanges from non-positive to a positive value.\n\nIf the trigger is audio rate then the grains will start with\nsample accuracy."
        },
        {
          "name": "bufnum",
          "default": 0,
          "doc": "The index of the buffer to use. It must be a one channel (mono)\nbuffer."
        },
        {
          "name": "rate",
          "default": 1,
          "doc": "1.0 is normal, 2.0 is one octave up, 0.5 is one octave down -1.0\nis backward normal rate… etc."
        },
        {
          "name": "centerPos",
          "default": 0,
          "doc": "The position in the buffer in seconds at which the grain envelope\nwill reach maximum amplitude."
        },
        {
          "name": "dur",
          "default": 0.1,
          "doc": "Duration of the grain in seconds."
        },
        {
          "name": "pan",
          "default": 0,
          "doc": "determines where to pan the output.\nlist::\n- If numChannels = 1, the pan argument is ignored.\n- If numChannels = 2, panning is similar to Pan2.\n- If numChannels > 2, panning is the same as PanAz."
        },
        {
          "name": "amp",
          "default": 0.1,
          "doc": "Amplitude of the grain."
        },
        {
          "name": "interp",
          "default": 4,
          "doc": "1, 2, or 4. Determines whether the grain uses (1) no\ninterpolation, (2) linear interpolation, or (4) cubic\ninterpolation.\n\nExamples::\n\ns.boot;\nb = Buffer.read(s, ExampleFiles.child);\n\n(\n{\n\tvar trate, dur, rate;\n\ttrate = MouseY.kr(2, 200, 1);\n\tdur = 4 / trate;\n\trate = Dseq([10, 1, 1, 0.5, 0.5, 0.2, 0.1], inf);\n\tTGrains.ar(2, Impulse.ar(trate), b, rate, MouseX.kr(0, BufDur.kr(b)), dur, Dseq([-1, 1], inf), 0.1, 2);\n}.scope(zoom: 4);\n)\n\n(\n{\n\tvar trate, dur, clk, pos, pan;\n\ttrate = MouseY.kr(8, 120, 1);\n\tdur = 12 / trate;\n\tclk = Impulse.kr(trate);\n\tpos = MouseX.kr(0, BufDur.kr(b)) + TRand.kr(0, 0.01, clk);\n\tpan = WhiteNoise.kr(0.6);\n\tTGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);\n}.scope(zoom: 4);\n)\n\n// 4 channels\n(\n{\n\tvar trate, dur, clk, pos, pan;\n\ttrate = MouseY.kr(8, 120, 1);\n\tdur = 12 / trate;\n\tclk = Impulse.kr(trate);\n\tpos = MouseX.kr(0, BufDur.kr(b)) + TRand.kr(0, 0.01, clk);\n\tpan = WhiteNoise.kr(0.6);\n\tTGrains.ar(4, clk, b, 1, pos, dur, pan, 0.1);\n}.scope(4, zoom: 4);\n)\n\n(\n{\n\tvar trate, dur, clk, pos, pan;\n\ttrate = MouseY.kr(8, 120, 1);\n\tdur = 4 / trate;\n\tclk = Dust.kr(trate);\n\tpos = MouseX.kr(0, BufDur.kr(b)) + TRand.kr(0, 0.01, clk);\n\tpan = WhiteNoise.kr(0.6);\n\tTGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);\n}.scope(zoom: 4);\n)\n\n(\n{\n\tvar trate, dur, clk, pos, pan;\n\ttrate = LinExp.kr(LFTri.kr(MouseY.kr(0.1, 2, 1)), -1, 1, 8, 120);\n\tdur = 12 / trate;\n\tclk = Impulse.ar(trate);\n\tpos = MouseX.kr(0, BufDur.kr(b));\n\tpan = WhiteNoise.kr(0.6);\n\tTGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);\n}.scope(zoom: 4);\n)\n\n(\n{\n\tvar trate, dur, clk, pos, pan;\n\ttrate = 12;\n\tdur = MouseY.kr(0.2, 24, 1) / trate;\n\tclk = Impulse.kr(trate);\n\tpos = MouseX.kr(0, BufDur.kr(b)) + TRand.kr(0, 0.01, clk);\n\tpan = WhiteNoise.kr(0.6);\n\tTGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);\n}.scope(zoom: 4);\n)\n\n(\n{\n\tvar trate, dur, clk, pos, pan;\n\ttrate = 100;\n\tdur = 8 / trate;\n\tclk = Impulse.kr(trate);\n\tpos = Integrator.kr(BrownNoise.kr(0.001));\n\tpan = WhiteNoise.kr(0.6);\n\tTGrains.ar(2, clk, b, 1, pos, dur, pan, 0.1);\n}.scope(zoom: 4);\n)\n\n(\n{\n\tvar trate, dur, clk, pos, pan;\n\ttrate = MouseY.kr(1, 400, 1);\n\tdur = 8 / trate;\n\tclk = Impulse.kr(trate);\n\tpos = MouseX.kr(0, BufDur.kr(b));\n\tpan = WhiteNoise.kr(0.8);\n\tTGrains.ar(2, clk, b, 2 ** WhiteNoise.kr(2), pos, dur, pan, 0.1);\n}.scope(zoom: 4);\n)\n\n(\n{\n\tvar trate, dur;\n\ttrate = MouseY.kr(2, 120, 1);\n\tdur = 1.2 / trate;\n\tTGrains.ar(2, Impulse.ar(trate), b, (1.2 ** WhiteNoise.kr(3).round(1)), MouseX.kr(0, BufDur.kr(b)), dur, WhiteNoise.kr(0.6), 0.1);\n}.scope(zoom: 4);\n)\n\n// demand ugens as inputs\n(\n{\n\tvar trate, dur, z, d;\n\ttrate = MouseX.kr(1, 100, 1);\n\td = { Dwhite(0.1, 0.2, 1) };\n\tz = {\n\t\tDrand([Dgeom(0.1, 1 + d.value, Diwhite(20, 40)), Dgeom(1, 1 - d.value, Diwhite(20, 40))])\n\t};\n\tTGrains.ar(2,\n\t\tImpulse.ar(trate),\n\t\tbufnum: 10,\n\t\trate: Dseq([1, 1, z.value, 0.5, 0.5, 0.2, 0.1, 0.1, 0.1, 0.1], inf) * 2 + 1,\n\t\tcenterPos: Dseq(z.dup(8), inf),\n\t\tdur: Dseq([1, d.value, 1, z.value, 0.5, 0.5, 0.1, z.value] * 2, inf) / trate,\n\t\tpan: Dseq([1, 1, 1, 0.5, 0.2, 0.1, 0, 0, 0], inf) * 2 - 1,\n\t\tamp: Dseq([1, 0, z.value, 0, 2, 1.0, 1, 0.1, 0.1], inf)\n\t);\n}.scope(zoom: 4);\n)\n\nb.free"
        }
      ],
      "description": "Triggers generate grains from a buffer. Each grain has a Hanning envelope\n\n(sin2(x) for x from 0 to π)\n\nand can be panned over multichannel output.",
      "related": [
        "GrainBuf"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "TIRand": {
      "name": "TIRand",
      "summary": "Triggered integer random number generator.",
      "categories": "UGens>Random, UGens>Triggers",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "lo",
          "default": 0,
          "doc": "Lower limit of the output range."
        },
        {
          "name": "hi",
          "default": 127,
          "doc": "Upper limit of the output range."
        },
        {
          "name": "trig",
          "default": 0,
          "doc": "The trigger. Trigger can be any signal. A trigger happens when\nthe signal changes from non-positive to positive.\n\nExamples::\n\n(\nSynthDef(\"help-TIRand\", {\n\tvar trig, outBus;\n\ttrig = Dust.kr(10);\n\toutBus = TIRand.kr(0, 1, trig); // play on random channel between 0 and 1\n\tOut.ar(outBus, PinkNoise.ar(0.2))\n\n}).play;\n)\n\n(\n{\n\tvar trig = Dust.kr(10);\n\tSinOsc.ar(\n\t\t\tTIRand.kr(4, 12, trig) * 100\n\t\t) * 0.1\n}.play;\n)\n\n(\n{\n\tvar trig = Dust.ar(MouseX.kr(1, 8000, 1));\n\tSinOsc.ar(\n\t\t\tTIRand.ar(4, 12, trig) * 100\n\t\t) * 0.1\n}.play;\n)"
        }
      ],
      "description": "Generates a random integer value in uniform distribution from\nlo  to  hi  each time the\ntrigger signal changes from nonpositive to positive values.",
      "related": [
        "ExpRand",
        "IRand",
        "LinRand",
        "NRand",
        "Rand",
        "TExpRand",
        "TRand",
        "TChoose"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "TRand": {
      "name": "TRand",
      "summary": "Triggered random number generator.",
      "categories": "UGens>Random, UGens>Triggers",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "lo",
          "default": 0,
          "doc": "Lower limit of the output range."
        },
        {
          "name": "hi",
          "default": 1,
          "doc": "Upper limit of the output range."
        },
        {
          "name": "trig",
          "default": 0,
          "doc": "The trigger. Trigger can be any signal. A trigger happens when\nthe signal changes from non-positive to positive.\n\nExamples::\n\n(\n{\n\tvar trig = Dust.kr(10);\n\tSinOsc.ar(\n\t\t\tTRand.kr(300, 3000, trig)\n\t\t) * 0.1\n}.play;\n)\n\n(\n{\n\tvar trig = Dust.ar(MouseX.kr(1, 8000, 1));\n\tSinOsc.ar(\n\t\t\tTRand.ar(300, 3000, trig)\n\t\t) * 0.1\n}.play;\n)"
        }
      ],
      "description": "Generates a random float value in uniform distribution from\nlo  to  hi  each time the\ntrigger signal changes from nonpositive to positive values.",
      "related": [
        "ExpRand",
        "IRand",
        "LinRand",
        "NRand",
        "Rand",
        "TExpRand",
        "TIRand"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "TWindex": {
      "name": "TWindex",
      "summary": "Triggered windex.",
      "categories": "UGens>Random, UGens>Triggers",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "The trigger. Trigger can be any signal. A trigger happens when\nthe signal changes from non-positive to positive."
        },
        {
          "name": "array",
          "default": null,
          "doc": "The list of probabilities. (Note: These should be control rate only.)"
        },
        {
          "name": "normalize",
          "default": 0,
          "doc": "Controls whether to normalize the probability values. (Control rate only.)\n\nExamples::\n\n// assuming normalized values\n(\na = SynthDef(\"help-TWindex\", { |out, w1 = 0.0, w2 = 0.5, w3 = 0.5|\n\tvar trig = Impulse.kr(6);\n\tvar index = TWindex.kr(trig, [w1, w2, w3]);\n\tOut.ar(out,\n\t\tSinOsc.ar(\n\t\t\tSelect.kr(index, [400, 500, 600]),\n\t\t\t0, 0.2\n\t\t)\n\t)\n}).play;\n)\n\na.setn(0, [0, 0, 1].normalizeSum);\na.setn(0, [1, 1, 1].normalizeSum);\na.setn(0, [1, 0, 1].normalizeSum);\n\n// modulating probability values\n(\n\na = SynthDef(\"help-TWindex\", { |out, w1 = 0.0, w2 = 0.5|\n\tvar trig = Impulse.kr(6);\n\tvar index = TWindex.kr(\n\t\ttrig,\n\t\t[w1, w2, SinOsc.kr(0.3, 0, 0.5, 0.5)], // modulate probability\n\t\t1 // do normalisation\n\t);\n\n\tOut.ar(out,\n\t\tSinOsc.ar(\n\t\t\tSelect.kr(index, [400, 500, 600]),\n\t\t\t0, 0.2\n\t\t)\n\t)\n}).play;\n\n)\n\na.setn(0, [0, 0]);\na.setn(0, [1, 1]);\na.setn(0, [1, 0]);\na.setn(0, [0, 1]);"
        }
      ],
      "description": "When triggered, returns a random index value based on array as a list of\nprobabilities. By default the list of probabilities should sum to 1.0,\nwhen the normalize flag is set to 1, the values get normalized\nby the UGen (less efficient).",
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "Tap": {
      "name": "Tap",
      "summary": "Single tap into a delay line",
      "categories": "UGens>Buffer, UGens>Delays>Buffer",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": 0,
          "doc": "The index of the buffer to use"
        },
        {
          "name": "numChannels",
          "default": 1,
          "doc": "Number of channels of the buffer"
        },
        {
          "name": "delaytime",
          "default": 0.2,
          "doc": "Tap delay; cannot be modulated"
        }
      ],
      "description": "The Tap UGen allows a single tap at a delay into a buffer.\n\nTap uses the PlayBuf UGen internally",
      "related": [
        "MultiTap",
        "PlayBuf"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Timer": {
      "name": "Timer",
      "summary": "Returns time since last triggered.",
      "categories": "UGens>Triggers",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "trig",
          "default": 0,
          "doc": "A trigger occurs when trig signal crosses from non-positive to positive.\n\nExamples::\n\n// using timer to modulate sine frequency: the slower the trigger is the higher the frequency\n(\n{ var trig;\n\ttrig = Impulse.kr(MouseX.kr(0.5, 20, 1));\n\tSinOsc.ar(Timer.kr(trig) * 500 + 500, 0, 0.2)\n}.play;\n)"
        }
      ],
      "description": "When triggered, Timer measures the time (in seconds) elapsed since the previous trigger, and outputs this time value as a constant. Its output will not change until the next trigger. The initial value is 0.\n\nIf you need the time since the last trigger, where the time is continually updated, see Sweep.",
      "related": [],
      "parent": "UGen",
      "signalRange": null
    },
    "ToggleFF": {
      "name": "ToggleFF",
      "summary": "Toggle flip flop.",
      "categories": "UGens>Triggers",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "trig",
          "default": 0,
          "doc": "Trigger input.\n\nExamples::\n\n(\nplay({\n\tSinOsc.ar((ToggleFF.ar(Dust.ar(XLine.kr(1, 1000, 60))) * 400) + 800, 0, 0.1)\n}))"
        }
      ],
      "description": "Toggles between 0 and 1 upon receiving a trigger.",
      "related": [
        "SetResetFF"
      ],
      "parent": "UGen",
      "signalRange": "unipolar"
    },
    "Trig": {
      "name": "Trig",
      "summary": "Timed trigger.",
      "categories": "UGens>Triggers",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "Trigger. Trigger can be any signal. A trigger happens when the\nsignal changes from non-positive to positive."
        },
        {
          "name": "dur",
          "default": 0.1,
          "doc": "Duration of the trigger output.\n\nExamples::\n\n{ Trig.ar(Dust.ar(1), 0.2) * FSinOsc.ar(800, 0.5) }.play\n\n{ Trig.ar(Dust.ar(4), 0.1) }.play"
        }
      ],
      "description": "When a nonpositive to positive transition occurs at the input, Trig\noutputs the level of the triggering input for the specified duration,\notherwise it outputs zero.",
      "related": [
        "Trig1"
      ],
      "parent": "Trig1",
      "signalRange": null,
      "inheritedFrom": "Trig1"
    },
    "Trig1": {
      "name": "Trig1",
      "summary": "Timed trigger.",
      "categories": "UGens>Triggers",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "Trigger. Trigger can be any signal. A trigger happens when the\nsignal changes from non-positive to positive."
        },
        {
          "name": "dur",
          "default": 0.1,
          "doc": "Duration of the trigger output.\n\nExamples::\n\n{ Trig1.ar(Dust.ar(1), 0.2) * FSinOsc.ar(800, 0.5) }.play\n\nTo create a fixed duration gate\n(\n\nSynthDef(\"trig1\", { |dur = 0.125|\n\tvar gate;\n\tgate = Trig1.kr(1.0, dur);\n\tOffsetOut.ar(0,\n\t\tSinOsc.ar(800, 0.3)\n\t\t* EnvGen.kr(\n\t\t\tEnv([0, 0.1, 0.1, 0], [0.01, 1.0, 0.01], [-4, 4], 2),\n\t\t\tgate,\n\t\t\tdoneAction: Done.freeSelf)\n\t)\n}).add;\n\nRoutine({\n\t1.0.wait;\n\t100.do({\n\t\ts.sendBundle(0.05, [\"s_new\", \"trig1\", -1, 0, 0, 0, rrand(0.02, 0.25)]);\n\t\t0.25.wait\n\t})\n}).play(SystemClock)\n\n)\n\nThis should sound like a continuous sine wave, although it is actually a series of 0.25 second synths.\n(\nSynthDef(\"trig1\", {\n\tvar gate;\n\tgate = Trig1.kr(1.0, 0.25);\n\tOffsetOut.ar(0,\n\t\tSinOsc.ar(800, 0.3)\n\t\t* EnvGen.kr(\n\t\t\tEnv([0, 0.1, 0.1, 0], [0.01, 1.0, 0.01], [-4, 4], 2),\n\t\t\tgate,\n\t\t\tdoneAction: Done.freeSelf)\n\t)\n}).add;\n\nRoutine({\n\t1.0.wait;\n\t100.do({\n\t\ts.sendBundle(0.05, [\"s_new\", \"trig1\", -1]);\n\t\t0.25.wait\n\t})\n}).play(SystemClock)\n\n)"
        }
      ],
      "description": "When a nonpositive to positive transition occurs at the input, Trig1\noutputs 1 for the specified duration, otherwise outputs 0.",
      "related": [
        "Trig"
      ],
      "parent": "UGen",
      "signalRange": "unipolar"
    },
    "TrigControl": {
      "name": "TrigControl",
      "summary": "FIXME: TrigControl purpose.",
      "categories": "UGens>Synth control, UGens>Undocumented",
      "rates": [
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "values",
          "default": null,
          "doc": "FIXME: explain parameter values."
        }
      ],
      "description": "FIXME: TrigControl description.",
      "related": [
        "Control",
        "LagControl"
      ],
      "parent": "Control",
      "signalRange": null,
      "inheritedFrom": "Control"
    },
    "TwoPole": {
      "name": "TwoPole",
      "summary": "Two pole filter.",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "freq",
          "default": 440,
          "doc": "Frequency of pole angle."
        },
        {
          "name": "radius",
          "default": 0.8,
          "doc": "Radius of pole. Should be between 0 and +1."
        }
      ],
      "description": "A two pole filter. This provides lower level access to setting of pole\nlocation. For general purposes  Resonz  is better.",
      "related": [
        "TwoZero"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "TwoZero": {
      "name": "TwoZero",
      "summary": "Two zero filter.",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "freq",
          "default": 440,
          "doc": "Frequency of zero angle."
        },
        {
          "name": "radius",
          "default": 0.8,
          "doc": "Radius of zero."
        }
      ],
      "description": "A two zero filter.",
      "related": [
        "TwoPole"
      ],
      "parent": "TwoPole",
      "signalRange": null,
      "inheritedFrom": "TwoPole"
    },
    "VDiskIn": {
      "name": "VDiskIn",
      "summary": "Stream in audio from a file, with variable rate",
      "categories": "UGens>InOut, UGens>Buffer",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "numChannels",
          "default": null,
          "doc": null
        },
        {
          "name": "bufnum",
          "default": null,
          "doc": null
        },
        {
          "name": "rate",
          "default": 1,
          "doc": null
        },
        {
          "name": "loop",
          "default": 0,
          "doc": null
        },
        {
          "name": "sendID",
          "default": 0,
          "doc": null
        }
      ],
      "description": "Continuously play a longer soundfile from disk. This requires a buffer to be preloaded with one buffer size of sound.",
      "related": [
        "PlayBuf",
        "BufRd",
        "DiskIn"
      ],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "VOsc": {
      "name": "VOsc",
      "summary": "Variable wavetable oscillator.",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "bufpos",
          "default": null,
          "doc": "Buffer index. Can be swept continuously among adjacent wavetable\nbuffers of the same size."
        },
        {
          "name": "freq",
          "default": 440,
          "doc": "Frequency in Hertz. (non-interpolated control-rate)"
        },
        {
          "name": "phase",
          "default": 0,
          "doc": "Phase offset or modulator in radians."
        }
      ],
      "description": "A wavetable lookup oscillator which can be swept smoothly across\nwavetables. Fractional values of table will interpolate between two adjacent tables.\n\nThis oscillator requires at least two buffers to be filled with a wavetable format\nsignal. This preprocesses the signal into a form which can be used efficiently by\nthe oscillator. All the wavetables must be allocated to the same size, and the size\nmust be a power of two.",
      "related": [
        "COsc",
        "Osc",
        "OscN",
        "VOsc3"
      ],
      "parent": "PureUGen",
      "signalRange": null
    },
    "VOsc3": {
      "name": "VOsc3",
      "summary": "Three variable wavetable oscillators.",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "bufpos",
          "default": null,
          "doc": "Buffer index. Can be swept continuously among adjacent wavetable\nbuffers of the same size."
        },
        {
          "name": "freq1",
          "default": 110,
          "doc": "Frequency in Hertz of the 1st oscillator. (non-interpolated control-rate)"
        },
        {
          "name": "freq2",
          "default": 220,
          "doc": "Frequency in Hertz of the 2nd oscillator. (non-interpolated control-rate)"
        },
        {
          "name": "freq3",
          "default": 440,
          "doc": "Frequency in Hertz of the 3rd oscillator. (non-interpolated control-rate)"
        }
      ],
      "description": "A wavetable lookup oscillator which can be swept smoothly across\nwavetables. Fractional values of table will interpolate between two adjacent tables.\nWhile VOsc cycles through its wavetable at one frequency,\nthis unit generator contains three oscillators at different frequencies,\nmixed together.\n\nThis oscillator requires at least two buffers to be filled with a wavetable format\nsignal. This preprocesses the signal into a form which can be used efficiently by\nthe oscillator. All the wavetables must be allocated to the same size, and the size\nmust be a power of two.",
      "related": [
        "COsc",
        "Osc",
        "OscN",
        "VOsc"
      ],
      "parent": "PureUGen",
      "signalRange": null
    },
    "VarLag": {
      "name": "VarLag",
      "summary": "Variable shaped lag",
      "categories": "UGens>Filters>Linear",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        },
        {
          "name": "time",
          "default": 0.1,
          "doc": "Lag time in seconds."
        },
        {
          "name": "curvature",
          "default": 0,
          "doc": "Control curvature if warp input is 5 (default).\n0 means linear, positive and negative numbers curve the segment up and down."
        },
        {
          "name": "warp",
          "default": 5,
          "doc": "Determines the shape. The possible values are:\ntable::\n- \\step || || flat segment\n- \\linear || \\lin || linear segment, the default\n- \\exponential || \\exp || natural exponential growth and decay. In this case, the levels must all be nonzero and the have the same sign.\n- \\sine || \\sin || sinusoidal S shaped segment.\n- \\welch || \\wel || sinusoidal segment shaped like the sides of a Welch window.\n- \\squared  || \\sqr || squared segment\n- \\cubed || \\cub || cubed segment\n\nAll values above will ignore curvature input.\n\n(Note: \nWhen controlling this from the outside, use Env.shapeNumber(symbol) to get the numeric value for each shape.\n)"
        },
        {
          "name": "start",
          "default": null,
          "doc": "Initial value. If not specified, same as the input signal."
        }
      ],
      "description": "Similar to Lag but with other curve shapes than exponential.\nA change on the input will take the specified time to reach the new value.\nUseful for smoothing out control (not audio) signals.\n\n(Warning:  VarLag.ar currently accepts audio-rate input, but the underlying implementation treats the input as control rate. Effectively, then, the \"sampling rate\" of VarLag's input is ControlRate.ir or server.sampleRate / server.options.blockSize, and the maximum safe frequency to feed into VarLag is half of this. VarLag does not currently yield correct results for full-bandwidth audio-rate signals. Use VarLag.ar at your own risk.)",
      "related": [
        "Lag",
        "Ramp",
        "Slew"
      ],
      "parent": "Filter",
      "signalRange": null
    },
    "VarSaw": {
      "name": "VarSaw",
      "summary": "Variable duty saw",
      "categories": "UGens>Generators>Deterministic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 440,
          "doc": null
        },
        {
          "name": "iphase",
          "default": 0,
          "doc": null
        },
        {
          "name": "width",
          "default": 0.5,
          "doc": null
        }
      ],
      "description": "Sawtooth-triangle oscillator with variable duty.",
      "related": [
        "Saw",
        "SyncSaw",
        "LFSaw"
      ],
      "parent": "PureUGen",
      "signalRange": null
    },
    "Vibrato": {
      "name": "Vibrato",
      "summary": "The Vibrato oscillator models a slow frequency modulation.",
      "categories": "UGens>Generators>Deterministic, UGens>Generators>Stochastic, UGens>Filters>Pitch",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "freq",
          "default": 440,
          "doc": "Fundamental frequency in Hertz. If the Vibrato UGen is running at audio rate, this must not be a constant, but an actual audio rate UGen (see example below)"
        },
        {
          "name": "rate",
          "default": 6,
          "doc": "Vibrato rate, speed of wobble in Hertz. Note that if this is set to a low value (and definitely with 0.0), you may never get vibrato back, since the rate input is only checked at the end of a cycle."
        },
        {
          "name": "depth",
          "default": 0.02,
          "doc": "Size of vibrato frequency deviation around the fundamental, as a proportion of the fundamental. 0.02 = 2% of the fundamental."
        },
        {
          "name": "delay",
          "default": 0,
          "doc": "Delay before vibrato is established in seconds (a singer tends to attack a note and then stabilise with vibrato, for instance)."
        },
        {
          "name": "onset",
          "default": 0,
          "doc": "Transition time in seconds from no vibrato to full vibrato after the initial delay time."
        },
        {
          "name": "rateVariation",
          "default": 0.04,
          "doc": "Noise on the rate, expressed as a proportion of the rate; can change once per cycle of vibrato."
        },
        {
          "name": "depthVariation",
          "default": 0.1,
          "doc": "Noise on the depth of modulation, expressed as a proportion of the depth; can change once per cycle of vibrato. The noise affects independently the up and the down part of vibrato shape within a cycle."
        },
        {
          "name": "iphase",
          "default": 0,
          "doc": "Initial phase of vibrato modulation, allowing starting above or below the fundamental rather than on it."
        },
        {
          "name": "trig",
          "default": 0,
          "doc": "Start again if transition from trig <= 0 to trig > 0.\nExamples::\n\n// vibrato at 1 Hz, note the use of DC.ar UGen; a constant of 400.0 doesn't work\n{ SinOsc.ar(Vibrato.ar(DC.ar(400.0), 1, 0.02)) }.play\n\n// compare: k-rate freq input can be a constant\n{ SinOsc.ar(Vibrato.kr(400.0, 1, 0.02)) }.play\n\n// control rate and rateVariation\n{ SinOsc.ar(Vibrato.ar(DC.ar(400.0), MouseX.kr(2.0, 100.0), 0.1, 1.0, 1.0, MouseY.kr(0.0, 1.0), 0.1)) }.play\n\n// control depth and depthVariation\n{ SinOsc.ar(Vibrato.ar(DC.ar(400.0), LFNoise1.kr(1, 3, 7), MouseX.kr(0.0, 1.0), 1.0, 1.0, MouseY.kr(0.0, 1.0), 0.1)) }.play"
        }
      ],
      "description": "Vibrato is a slow frequency modulation. Consider the systematic deviation in pitch of a singer around a fundamental frequency, or a violinist whose finger wobbles in position on the fingerboard, slightly tightening and loosening the string to add shimmer to the pitch. There is often also a delay before vibrato is established on a note. This UGen models these processes; by setting more extreme settings, you can get back to the timbres of FM synthesis. You can also add in some noise to the vibrato rate and vibrato size (modulation depth) to make for a more realistic motor pattern.\n\nThe vibrato output is a waveform based on a squared envelope shape with four stages marking out 0.0 to 1.0, 1.0 to 0.0, 0.0 to -1.0, and -1.0 back to 0.0. Vibrato rate determines how quickly you move through these stages.",
      "related": [],
      "parent": "PureUGen",
      "signalRange": null
    },
    "Warp1": {
      "name": "Warp1",
      "summary": "Warp a buffer with a time pointer",
      "categories": "UGens>Buffer, UGens>Generators>Granular",
      "rates": [
        "ar"
      ],
      "args": [
        {
          "name": "numChannels",
          "default": 1,
          "doc": "the number of channels in the soundfile used in bufnum. Must be a nonzero, positive integer. This is fixed when the SynthDef is compiled so cannot be assigned to a SynthDef argument."
        },
        {
          "name": "bufnum",
          "default": 0,
          "doc": "the buffer number of a mono soundfile."
        },
        {
          "name": "pointer",
          "default": 0,
          "doc": "the position in the buffer.  The value should be between 0 and 1, with 0 being the beginning\nof the buffer, and 1 the end."
        },
        {
          "name": "freqScale",
          "default": 1,
          "doc": "the amount of frequency shift. 1.0 is normal, 0.5 is one octave down, 2.0 is one octave up.\nNegative values play the soundfile backwards."
        },
        {
          "name": "windowSize",
          "default": 0.2,
          "doc": "the size of each grain window."
        },
        {
          "name": "envbufnum",
          "default": -1,
          "doc": "the buffer number containing a signal to use for the grain envelope. -1 uses a built-in\nHanning envelope."
        },
        {
          "name": "overlaps",
          "default": 8,
          "doc": "the number of overlapping windows."
        },
        {
          "name": "windowRandRatio",
          "default": 0,
          "doc": "the amount of randomness to the windowing function.  Must be between 0 (no\nrandomness) to 1.0 (probably too random actually)"
        },
        {
          "name": "interp",
          "default": 1,
          "doc": "the interpolation method used for pitchshifting grains. 1 = no interpolation. 2 = linear.\n\t\t4 = cubic interpolation (more computationally intensive)."
        }
      ],
      "description": "Inspired by Chad Kirby's SuperCollider2 Warp1 class, which was inspired by Richard Karpen's sndwarp for CSound. A granular time stretcher and pitchshifter.",
      "related": [],
      "parent": "MultiOutUGen",
      "signalRange": null
    },
    "WhiteNoise": {
      "name": "WhiteNoise",
      "summary": "White noise.",
      "categories": "UGens>Generators>Stochastic",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [],
      "description": "Generates noise whose spectrum has equal power at all frequencies.",
      "related": [
        "BrownNoise",
        "GrayNoise",
        "ClipNoise",
        "PinkNoise"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "Wrap": {
      "name": "Wrap",
      "summary": "Wrap a signal outside given thresholds.",
      "categories": "UGens>Maths",
      "rates": [
        "ar",
        "kr",
        "ir"
      ],
      "args": [
        {
          "name": "in",
          "default": null,
          "doc": "Signal to be wrapped."
        },
        {
          "name": "lo",
          "default": 0,
          "doc": "Low threshold of wrapping."
        },
        {
          "name": "hi",
          "default": 1,
          "doc": "High threshold of wrapping.\n\nExamples::\n\ns.boot;\n\n{ Wrap.ar(SinOsc.ar(440, 0, 0.2), -0.15, 0.15) }.scope;"
        }
      ],
      "description": "This differs from the  BinaryOpUGen  Overviews/Methods#wrap2#wrap2 in that it\nallows one to set both low and high thresholds.",
      "related": [
        "Clip",
        "Fold"
      ],
      "parent": "InRange",
      "signalRange": null,
      "inheritedFrom": "InRange"
    },
    "WrapIndex": {
      "name": "WrapIndex",
      "summary": "Index into a table with a signal.",
      "categories": "UGens>Buffer",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "bufnum",
          "default": null,
          "doc": "Index of the buffer."
        },
        {
          "name": "in",
          "default": 0,
          "doc": "The input signal."
        }
      ],
      "description": "The input signal value is truncated to an integer value and used as an\nindex into the table. Out-of-range index values are wrapped cyclically to\nthe valid range.",
      "related": [
        "Index",
        "Shaper"
      ],
      "parent": "Index",
      "signalRange": null,
      "inheritedFrom": "Index"
    },
    "XFade2": {
      "name": "XFade2",
      "summary": "Equal power two channel cross fade.",
      "categories": "UGens>Multichannel>Select",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "inA",
          "default": null,
          "doc": "Input signal A."
        },
        {
          "name": "inB",
          "default": 0,
          "doc": "Input signal B."
        },
        {
          "name": "pan",
          "default": 0,
          "doc": "Crossfade position from -1 to +1."
        },
        {
          "name": "level",
          "default": 1,
          "doc": "A control rate level input.\n\nExamples::\n\n{ XFade2.ar(Saw.ar, SinOsc.ar, LFTri.kr(0.1)) }.play"
        }
      ],
      "description": "Two channel equal power crossfader.",
      "related": [
        "LinXFade2"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "XLine": {
      "name": "XLine",
      "summary": "Exponential line generator.",
      "categories": "UGens>Envelopes",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "start",
          "default": 1,
          "doc": "Starting value."
        },
        {
          "name": "end",
          "default": 2,
          "doc": "Ending value."
        },
        {
          "name": "dur",
          "default": 1,
          "doc": "Duration in seconds."
        },
        {
          "name": "doneAction",
          "default": 0,
          "doc": "A doneAction to be evaluated when the line is completed. See\n\nDone  for more detail.\n\nExamples::\n\nplay({ SinOsc.ar(XLine.kr(200, 17000, 10), 0, 0.1) });"
        }
      ],
      "description": "Generates an exponential curve from the start value to the end value.\nBoth the start and end values must be non-zero and have the same sign.",
      "related": [
        "Line"
      ],
      "parent": "UGen",
      "signalRange": null
    },
    "XOut": {
      "name": "XOut",
      "summary": "Send signal to a bus, crossfading with previous contents.",
      "categories": "UGens>InOut",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "bus",
          "default": null,
          "doc": "The index of the bus to write out to. The lowest numbers are written to the audio hardware."
        },
        {
          "name": "xfade",
          "default": null,
          "doc": "Crossfade level."
        },
        {
          "name": "channelsArray",
          "default": null,
          "doc": "An Array of channels or single output to write out. You cannot change the size of this once a SynthDef has been built.\n\nExamples::\n\n(\nSynthDef(\"help-SinOsc\", { |freq = 440, out|\n\tOut.ar(out, SinOsc.ar(freq, 0, 0.1))\n}).add;\n\nSynthDef(\"help-XOut\", { |out = 0, xFade = 1|\n\tvar source;\n\t\tsource = PinkNoise.ar(0.05);\n\n\t\t// write to the bus, crossfading with previous contents\n\t\tXOut.ar(out, xFade, source);\n\n}).add;\n)\n\nSynth(\"help-SinOsc\", [\\freq, 500]);\na = Synth.tail(s, \"help-XOut\");\n\na.set(\\xFade, 0.7);\na.set(\\xFade, 0.4);\na.set(\\xFade, 0.0);"
        }
      ],
      "description": "Send signal to a bus, crossfading with previous contents.\nxfade  is a level for the crossfade between what\nis on the bus and what you are sending. The algorithm is equivalent to this:\n\nbus_signal = (input_signal * xfade) + (bus_signal * (1 - xfade));\n\nSee the Reference/Server-Architecture and Bus helpfiles for more information on\nbuses and how they are used.",
      "related": [
        "OffsetOut",
        "Out",
        "ReplaceOut"
      ],
      "parent": "AbstractOut",
      "signalRange": null
    },
    "ZeroCrossing": {
      "name": "ZeroCrossing",
      "summary": "Zero crossing frequency follower",
      "categories": "UGens>Analysis>Pitch",
      "rates": [
        "ar",
        "kr"
      ],
      "args": [
        {
          "name": "in",
          "default": 0,
          "doc": "Input signal."
        }
      ],
      "description": "Outputs a frequency based upon the distance between interceptions of the X axis. The X intercepts are determined via linear interpolation so this gives better than just integer wavelength resolution. This is a very crude pitch follower, but can be useful in some situations.",
      "related": [],
      "parent": "UGen",
      "signalRange": null
    }
  }
}